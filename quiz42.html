<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Scheduling (#42)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Scheduling (#42)</span>
			<p>by Hans Fugal</p>
			<p>You have a list of employees along with the hours they would _like_ to work, and the hours they _cannot_ work. You have a list of hours that need to be worked. (Extra credit for allowing for a different number of employees needed at different hours.)</p>
			<p>Write a scheduler that schedules employees without scheduling them on hours they cannot work. It would be nice if the employees got as many of the hours they wanted as possible. It would be nice if the employees didn't end up with split shifts, had more or less consistent hours from day to day (e.g. Joe gets scheduled in mornings), and so forth.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>The problem space of scheduling is vast and complicated, but it's not too hard to get some form of working solution.  The real trick is the quality of the schedule generated.</p>
			<p>I took a very easy approach, to keep the problem manageable.  My initial thought when reading the problem was to use a "Hill Climbing" algorithm.  I planned to start by just assigning every shift (ignoring availability and preference), and then swap shifts until I had a corrected schedule.  That process changed a bit when I was actually coding it up though.  More on that later.</p>
			<p>The first thing I needed was some notion of time.  I did consider using the built-in Time class, but I really wanted something simple.  My approach only considers time in hour slices and the main functionality I needed was support for use in a Range object.  Here's what I settled on:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby -w</span><br /><br />    require <span class="string">"yaml"</span><br /><br />    <span class="comment"># A representation of a single hour.  Usable in Ranges.</span><br />    <span class="keyword">class</span> Hour<br />        <span class="keyword">def</span> initialize( text )<br />            <span class="variable">@hour</span> = <span class="keyword">case</span> text<br />            <span class="keyword">when</span> <span class="string">"12 AM"</span><br />                0<br />            <span class="keyword">when</span> <span class="string">"12 PM"</span><br />                12<br />            <span class="keyword">when</span> <span class="string">/(\d+) PM/</span><br />                <span class="global">$1</span>.to_i + 12<br />            <span class="keyword">else</span><br />                text[<span class="string">/\d+/</span>].to_i<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        include Comparable<br /><br />        <span class="keyword">def</span> &lt;=&gt;( other )<br />            <span class="variable">@hour</span> &lt;=&gt; other.instance_eval { <span class="variable">@hour</span> }<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> succ<br />            next_hour = Hour.new(<span class="string">"12 AM"</span>)<br /><br />            next_time = (<span class="variable">@hour</span> + 1) % 24<br />            next_hour.instance_eval { <span class="variable">@hour</span> = next_time }<br /><br />            next_hour<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> to_s<br />            str = <span class="keyword">case</span> <span class="variable">@hour</span><br />            <span class="keyword">when</span> 0<br />                <span class="string">"12 AM"</span><br />            <span class="keyword">when</span> 12<br />                <span class="string">"12 PM"</span><br />            <span class="keyword">when</span> 13..23<br />                <span class="string">"#{@hour - 12} PM"</span><br />            <span class="keyword">else</span><br />                <span class="string">"#{@hour} AM"</span><br />            <span class="keyword">end</span><br />            <span class="string">"%5s"</span> % str<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The easiest way to get a unique and comparable representation of an hour I could think of was to use military time.  That's exactly what the constructor does.  I parse the string representation of a time and store the military hour (0-23) internally.</p>
			<p>If you glance down, you'll see that to_s() is simply the reverse of this process.  I use it in printing results.</p>
			<p>The other two methods are simple.  The documentation for Range say that you can use any object that supports &lt;=&gt;() and succ(), so that's what we have here.  The &lt;=&gt;() method just compares the military hours.  succ() builds a new Hour object then sets it to one hour ahead of the current object and returns the new Hour.</p>
			<p>You can see that I'm using instance_eval() in both of these methods to read and adjust the internal representation in other Hour objects.  That felt more correct than exposing the internal representation with an accessor and I think it's great that Ruby lets me make this choice.</p>
			<p>The other helper class I felt need for was something to represent a worker.  I wanted to be able to feed it the worker's requested schedule and then query it as needed.  Here's the code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># An object for tracking a worker's availability and preferences.</span><br />    <span class="keyword">class</span> Worker<br />        <span class="keyword">def</span> initialize( name )<br />            <span class="variable">@name</span>  = name<br /><br />            <span class="variable">@avail</span>   = Hash.new<br />            <span class="variable">@prefers</span> = Hash.new<br />        <span class="keyword">end</span><br /><br />        attr_reader :name<br /><br />        <span class="keyword">def</span> can_work( day, times )<br />            <span class="variable">@avail</span>[day] = parse_times(times)<br /><br />            <span class="variable">@prefers</span>[day] = <span class="keyword">if</span> times =~ <span class="string">/\((?:prefers )?([^)]+)\s*\)/</span><br />                parse_times(<span class="global">$1</span>)<br />            <span class="keyword">else</span><br />                Hour.new(<span class="string">"12 AM"</span>)..Hour.new(<span class="string">"11 PM"</span>)<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> available?( day, hour )<br />            <span class="keyword">if</span> <span class="variable">@avail</span>[day].nil?<br />                <span class="keyword">false</span><br />            <span class="keyword">else</span><br />                <span class="variable">@avail</span>[day].include?(hour)<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> prefers?( day, hour )<br />            <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">unless</span> available? day, hour<br /><br />            <span class="keyword">if</span> <span class="variable">@prefers</span>[day].nil?<br />                <span class="keyword">false</span><br />            <span class="keyword">else</span><br />                <span class="variable">@prefers</span>[day].include?(hour)<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> ==( other )<br />            <span class="variable">@name</span> == other.name<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> to_s<br />            <span class="variable">@name</span>.to_s<br />        <span class="keyword">end</span><br /><br />        private<br /><br />        <span class="keyword">def</span> parse_times( times )<br />            <span class="keyword">case</span> times<br />            <span class="keyword">when</span> <span class="string">/^\s*any\b/</span>i<br />                Hour.new(<span class="string">"12 AM"</span>)..Hour.new(<span class="string">"11 PM"</span>)<br />            <span class="keyword">when</span> <span class="string">/^\s*before (\d+ [AP]M)\b/</span>i<br />                Hour.new(<span class="string">"12 AM"</span>)..Hour.new(<span class="global">$1</span>)<br />            <span class="keyword">when</span> <span class="string">/^\s*after (\d+ [AP]M)\b/</span>i<br />                Hour.new(<span class="global">$1</span>)..Hour.new(<span class="string">"11 PM"</span>)<br />            <span class="keyword">when</span> <span class="string">/^\s*(\d+ [AP]M) to (\d+ [AP]M)\b/</span>i<br />                Hour.new(<span class="global">$1</span>)..Hour.new(<span class="global">$2</span>)<br />            <span class="keyword">when</span> <span class="string">/^\s*not available\b/</span>i<br />                <span class="keyword">nil</span><br />            <span class="keyword">else</span><br />                raise <span class="string">"Unexpected availability format."</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The constructor just makes note of the name for this Worker, then sets up two Hash objects to hold availability and preferred schedule.  The Hashes will use a day of the week as a key and a Range of Hour objects as the value.  An availability of "any" can be represented as a Range of all the Hours in a day.  This is easy to work with, but it can't handle split-shift style availabilities.  You could fix this by making the values Arrays of Ranges.</p>
			<p>The next three methods are all closely related.  First, can_work() takes a day String and a String representation of available times and uses those to set the previously mentioned Hashes.  The actual parsing is delegated to the private parse_time() method, which just uses Regexps to break down the input.  Once a schedule has been loaded, you can check availability for a given day and hour with available?().  The prefers?() method takes the same input but returns a preference instead.  A Worker must be available to work a given time to have a preference about it.</p>
			<p>Those are the only helper classes I built.  The rest is application code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />        <span class="keyword">unless</span> ARGV.size == 1 <span class="keyword">and</span> File.exists?(ARGV.first)<br />            puts <span class="string">"Usage:  #{File.basename($0)} SCHEDULE_FILE"</span><br />            exit<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># load the data</span><br />        data = File.open(ARGV.shift) { |file| YAML.load(file) }<br /><br />        <span class="comment"># build worker list</span><br />        workers = Array.new<br />        data[<span class="string">"Workers"</span>].each <span class="keyword">do</span> |name, avail|<br />            worker = Worker.new(name)<br />            avail.each { |day, times| worker.can_work(day, times) }<br />            workers &lt;&lt; worker<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>That's all pretty basic.  Check and display usage, if needed; load the YAML representation of workers and schedule hours to be filled; anf finally, build an Array of Worker objects that are aware of their availability and preferences.  Here's the YAML file I'm using:</p>
			<p class="example">--- <br />Schedule: <br />  Wed: 9 AM to 6 PM<br />  Sun: 9 AM to 10 PM<br />  Thu: 9 AM to 8 PM<br />  Mon: 9 AM to 6 PM<br />  Tue: 9 AM to 6 PM<br />  Sat: 9 AM to 10 PM<br />  Fri: 9 AM to 6 PM<br />Workers: <br />  James: <br />    Wed: any<br />    Sun: any (prefers before 5 PM)<br />    Thu: 12 PM to 3 PM<br />    Mon: before 3 PM (prefers before 12 PM)<br />    Tue: any<br />    Sat: not available<br />    Fri: 12 PM to 3 PM<br />  Brian: <br />    Wed: not available<br />    Sun: after 1 PM<br />    Thu: any (prefers 8 AM to 5 PM)<br />    Mon: any (prefers 8 AM to 5 PM)<br />    Tue: any (prefers 8 AM to 5 PM)<br />    Sat: any<br />    Fri: any (prefers 8 AM to 5 PM)</p>
			<p>The next step is to build a schedule.  Here's where I deviated from my original plan.  I realized that if I limit myself to just worrying about availability at first, I can build a correct schedule in those terms as I load it.  Here's how that turns out:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># create a legal schedule, respecting availability</span><br />        schedule = Hash.new<br />        data[<span class="string">"Schedule"</span>].each <span class="keyword">do</span> |day, times|<br />            schedule[day] = Array.new<br />            <span class="keyword">if</span> times =~ <span class="string">/^\s*(\d+ [AP]M) to (\d+ [AP]M)\b/</span>i<br />                start, finish = Hour.new(<span class="global">$1</span>), Hour.new(<span class="global">$2</span>)<br />            <span class="keyword">else</span><br />                raise <span class="string">"Unexpected schedule format."</span><br />            <span class="keyword">end</span><br /><br />            (start..finish).each <span class="keyword">do</span> |hour|<br />                started_with = workers.first<br />                loop <span class="keyword">do</span><br />                    <span class="keyword">if</span> workers.first.available? day, hour<br />                        schedule[day] &lt;&lt; [hour, workers.first]<br />                        <span class="keyword">break</span><br />                    <span class="keyword">else</span><br />                        workers &lt;&lt; workers.shift<br />                        <span class="keyword">if</span> workers.first == started_with<br />                            schedule[day] &lt;&lt; [hour, <span class="string">"No workers available!"</span>]<br />                            <span class="keyword">break</span><br />                        <span class="keyword">end</span><br />                    <span class="keyword">end</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />            workers &lt;&lt; workers.shift<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>A schedule is a Hash that stores day names paired with Arrays of Arrays.  The Arrays are a collection of Hour and Worker pairs, showing who is scheduled to work at that time.</p>
			<p>The second half of that code is what assembles the initial schedule.  It just walks every hour of every day assigning a worker.  It starts with the first worker in the list and keeps assigning them until them end of the day or until the worker has a schedule conflict.  Anytime either of those conditions happens, the worker list is rotated and we try the next worker.</p>
			<p>If we make it all the way through the list of workers without finding a person who could work at that time, we just set the Worker slot to a warning message and rely on the user to fix the problem.  Blowing up with an exception here seemed too drastic for what is likely a fairly common snag that I doubt software is qualified to resolve.</p>
			<p>The main issue with the above system is that it can assign people very long or very short shifts.  I think a good way to correct this would be to set minimum and maximum shift lengths and adjust the software to honor them.  Of course, this will create more conflicts so you either have to accept that or make them soft limitations.</p>
			<p>Now, my code does make a second pass adjusting shifts, but now the focus turns from availability to preference.  Let's examine that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># make schedule swaps for preferred times</span><br />        schedule.each <span class="keyword">do</span> |day, hours|<br />            hours.each_with_index <span class="keyword">do</span> |(hour, worker), index|<br />                <span class="keyword">next</span> <span class="keyword">unless</span> worker.is_a?(Worker)<br />                <span class="keyword">unless</span> worker.prefers?(day, hour)<br />                    alternate = workers.find { |w| w.prefers?(day, hour) }<br />                    hours[index][-1] = alternate <span class="keyword">unless</span> alternate.nil?<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here I'm just searching for people working hours they didn't prefer.  When found, I try to swap them out for someone who did prefer the time, if I can find such a person.  Otherwise, they have to stay.</p>
			<p>Again, this can create some odd schedules.  Mainly, people are traded on an hourly basis and this can cause scheduling of one hour shifts.  Again, I think the answer is minimum shift lengths as I mentioned above, but in practice this wasn't a chronic problem with availabilities like the ones in the YAML file.  When someone passed out of the times they preferred, it would generally cause the rest of their shift to be replaced with someone that did want to work the time.</p>
			<p>All that remains is to print the schedule:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># print schedule</span><br />        <span class="string">%w{Mon Tue Wed Thu Fri Sat Sun}</span>.each <span class="keyword">do</span> |day|<br />            puts <span class="string">"#{day}:"</span><br />            schedule[day].each <span class="keyword">do</span> |hour, worker|<br />                puts <span class="string">"  #{hour}:  #{worker}"</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That's as easy as it looks.  Walk the days, printing hours and who's working at that time.</p>
			<p>All-in-all it's an imperfect solution, but I think you could keep tuning it until you get what you need.  It works, but can certainly be made better.</p>
			<p>Next week's Ruby Quiz is the number game that's been requested of me twice now, so I really hope I'm not the only guy working that one...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/152401">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/152735">Gibbs Tanton</a></li>
			</ol>
			<p><a href="quiz42_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
