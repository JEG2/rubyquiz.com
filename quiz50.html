<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Text Image (#50)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Text Image (#50)</span>
			<p>This week's Ruby Quiz is to create a tool that will allow you to preview an image file at the command-line in pure text.</p>
			<p>Your program will need to read in an image, in whatever format you want to support, and respond with a text representation of the image that fits in the terminal.</p>
			<p>For example, given the image:</p>
			<p><a href="http://rubyquiz.com/images/Ducky.png">Ducky</a></p>
			<p>Your program might respond with something like:</p>
			<p class="example">........--**####**::::::::::::........<br />......--##oooooo\\**::::::::..........<br />......**oo==oooo\\\\::::..............<br />....--\\oooooooo\\$$**::..............<br />....**&amp;&amp;$$oooo\\$$$$%%................<br />....**\\oooo\\&lt;&lt;&lt;&lt;$$##................<br />....!!&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\\\##..........::::::<br />....::%%&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\$$^^....::**++**....<br />....^^%%&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;$$$$##**""==++++==****<br />....**oo&lt;&lt;&lt;&lt;&lt;&lt;$$&lt;&lt;&lt;&lt;\\oo==++++++==""""<br />..!!==oo&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;$$$$oo====++++==oo####<br />^^====oo\\&lt;&lt;$$\\oooooo==++======oo****<br />**++++====oooo====++++======oooo\\^^^^<br />++====++++========++======oooooo**....<br />""====++++==========oooooooooo##--....<br />""==================oooooooooo^^......<br />!!oo==oo======oooooooooo\\##^^::......<br />..""oooooooooooooooo\\oo""^^..........<br />..::**====oooooooooo==**::............<br />....::^^**""""""""!!..--::............<br />....::^^**""""""""!!..--::............</p>
			<p>Go for as much accuracy as you can possibly squeeze out of it.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I just love it when a totally crazy idea of mine blossoms into a popular quiz.  Who would a thunk it?</p>
			<p>As you've probably seen from the solutions, this quiz turns out to be fairly easy, thanks to great tools like RMagick and GD.  Those libraries can do the heavy lifting of loading an image, resizing it, and dropping it to a smaller color map.  With that, you're code just needs to replace colors with some symbols.</p>
			<p>Here's some RMagick code from Mr. RMagick himself, Timothy Hunter:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'RMagick'</span><br /><br />    CHARS = [ <span class="string">'W'</span>, <span class="string">'M'</span>, <span class="string">'$'</span>, <span class="string">'@'</span>, <span class="string">'#'</span>, <span class="string">'%'</span>, <span class="string">'^'</span>, <span class="string">'x'</span>, <span class="string">'*'</span>, <span class="string">'o'</span>, <span class="string">'='</span>, <span class="string">'+'</span>,<br />              <span class="string">':'</span>, <span class="string">'~'</span>, <span class="string">'.'</span>, <span class="string">' '</span> ]<br />    FONT_ROWS = 8<br />    FONT_COLS = 4<br /><br />    img = Magick::Image.read(ARGV[0] || <span class="string">"Flower_Hat.jpg"</span>).first<br /><br />    <span class="comment"># Resize too-large images. The resulting image is going to be</span><br />    <span class="comment"># about twice the size of the input, so if the original image is too</span><br />    <span class="comment"># large we need to make it smaller so the ASCII version won't be too</span><br />    <span class="comment"># big. The `change_geometry' method computes new dimensions for an</span><br />    <span class="comment"># image based on the geometry argument. The '320x320&gt;' argument says</span><br />    <span class="comment"># "If the image is too big to fit in a 320x320 square, compute the</span><br />    <span class="comment"># dimensions of an image that will fit, but retain the original aspect</span><br />    <span class="comment"># ratio. If the image is already smaller than 320x320, keep the same</span><br />    <span class="comment"># dimensions."</span><br />    img.change_geometry(<span class="string">'320x320&gt;'</span>) <span class="keyword">do</span> |cols, rows|<br />        img.resize!(cols, rows) <span class="keyword">if</span> cols != img.columns || rows != img.rows<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># Compute the image size in ASCII "pixels" and resize the image to have</span><br />    <span class="comment"># those dimensions. The resulting image does not have the same aspect</span><br />    <span class="comment"># ratio as the original, but since our "pixels" are twice as tall as</span><br />    <span class="comment"># they are wide we'll get our proportions back (roughly) when we render.</span><br />    pr = img.rows / FONT_ROWS<br />    pc = img.columns / FONT_COLS<br />    img.resize!(pc, pr)<br /><br />    img = img.quantize(16, Magick::GRAYColorspace)<br />    img = img.normalize<br /><br />    <span class="comment"># Draw the image surrounded by a border. The `view' method is slow but</span><br />    <span class="comment"># it makes it easy to address individual pixels. In grayscale images,</span><br />    <span class="comment"># all three RGB channels have the same value so the red channel is as</span><br />    <span class="comment"># good as any for choosing which character to represent the intensity of</span><br />    <span class="comment"># this particular pixel.</span><br />    border = <span class="string">'+'</span> + (<span class="string">'-'</span> * pc) + <span class="string">'+'</span><br />    puts border<br />    img.view(0, 0, pc, pr) <span class="keyword">do</span> |view|<br />        pr.times <span class="keyword">do</span> |i|<br />            putc <span class="string">'|'</span><br />            pc.times { |j| putc CHARS[view[i][j].red/16] }<br />            puts <span class="string">'|'</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br />    puts border<br /><br /></div></div>
			<p>That is wonderfully commented code, of course, so I'm not going to repeat what it does here.</p>
			<p>I will mention a trick I found while playing with my own similar solution though.  I couldn't decide how many symbols to use, so I played with different amounts.  After about the third time of changing the Array and the argument to quantize(), I realized that I could save myself a step.  The same can be done with the above code by changing two lines:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    img = img.quantize(CHARS.size, Magick::GRAYColorspace)<br /><br />    <span class="comment"># ...</span><br /><br />            pc.times { |j| putc CHARS[view[i][j].red/CHARS.size] }<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>With that, you can add and remove CHARS to play around and the code will just do the right thing.</p>
			<p>Here's how our mascot looks, when hit with the above code:</p>
			<p class="example">+-------------------------------------------------------------------------+<br />|                      .::+====+::                                        |<br />|                  .:==o======ooo*oo+.                                    |<br />|                 +oo=====++++===oo***+                                   |<br />|               :oo==++++===++==ooooo*^*.                                 |<br />|              :oo====++++====oooooooo*^*                                 |<br />|             .oo=====++++========ooo**^^o                                |<br />|            .ooo=====++++++======ooo**^^%:                               |<br />|           :*oo*o==============oooo****^^^.                              |<br />|          :ooo$WW^===========oooo****^^^^^=                              |<br />|          ooo*WWW%=========oooo^^*^**^^^^^^                              |<br />|          oooo=o::o=====oooo*%WWW$^^*^^^^*^:                             |<br />|          =ooo=:+====ooooo**o^WWW$***^****^:                             |<br />|          .*o*o*ooooo==ooo*^*+====o*^*****^.                             |<br />|           :o%$$$$$WW$$$%%^^^^**********^^=                              |<br />|            .oWWWWWWWWWWWWWW$%%^**o****^^=                   ::::::      |<br />|              %$$$$$$$W$$W$WWWW$^****^^o.              ...::::::::==:    |<br />|              =WWWW$$$W$$$$WW$$%^^****+. .........:::::::::::::::::=o+   |<br />|              :$WWWWWWWWWWWW%^****^%%%%%^^**oo====++:::::::::::::::+=o+  |<br />|           :+oo*$$WWWWWWW$%^*^^^^^%$$$%%%^**o===+:::::::::::::::::++==o: |<br />|         .:====o*^%$$$$$%^^%%^^^^%%%%%%%^^**o===+::::::::::::::::::===oo |<br />|       .:+++++==o*^%%%%%%$%%%%^^^^%%%^^^**oo===++:::::::::::::::::+==ooo |<br />|     .:+::::+++=oo*^%%%$%%%%%^^^^^*****ooo===+++::::::::::::::::++===oo= |<br />|    :++::::::+++=oo*^%%%%%%^^****ooooo=====++:::::::::::::++:::++====o*. |<br />|   :+::::::::::+===o**^^^^**ooo=====+=+++++::::::::::::+::==++++===ooo+  |<br />|  :+::::::::::::+++==oooooo====+::::+:::::+::::+::++::+::+==++=====oo=   |<br />| .+::::::::::::::::++=+=====+::::::+:::::+::::+:::+:::+++========ooo=    |<br />| :+::::::::::::::::::+:++++::::::++::::::::::+:::++:++==========ooo+     |<br />|.++++:::::::::::::::::::::::::::+:::::+::::+:::++++===========oooo:      |<br />|.++++::::::::::::::::::::::::::::::++:+::+=+++==============oooo=.       |<br />| +++++++::::::::::::::::::::::++::++::+==+=+===========o===ooo=:         |<br />| :==++++::::+:::::::::+:+:::::::::+++===++=============ooooo=:           |<br />| .===++++++++++::+++::+++:+++++::+===++====o==========o=o==:.            |<br />|  :=======+++++++++++++++++:++===============oo====oo=o==:.              |<br />|   :====================++++++==+=========o=====ooo====:                 |<br />|    .==================================ooooooo=oo===+:                   |<br />|      :+=============================oooo=o==oo==::.                     |<br />|        ::==========================o====oo===::.                        |<br />|           ::++==============+===========+::.                            |<br />|              ..:::++++==++=+++++++++::..                                |<br />|                    ....:.::::::...                                      |<br />+-------------------------------------------------------------------------+</p>
			<p>For an interesting different approach, Simon Kroeger wrote some code to outline the primary subject.  That makes our duck look like this:</p>
			<p class="example">          .:'''''''.<br />         .:          :.<br />        .:            :.<br />        :              :<br />       :'              ':<br />      .:                :<br />      : .':.            ::<br />     :'.'  :     ..     ':<br />     :  :..'    :' ':    :<br />     :.  '      :  .:    :<br />     ': '::'':.. ':'  .  :<br />      ::       ''..     :'       .:'':.<br />       ::  .      ':   .:     ..'   . '.<br />       ':  '''''  .: .:::::'''         :.<br />       ::       .:':                    :<br />     .:  :    .:'                       :<br />    .'   ''  ''                         :<br />   :'                                   :<br />  :                                     :<br />.'                                     :<br />:                       '             :'<br />:                                    .:<br />'                  :                .:<br />                   '                 :<br />:                                 .:<br />:                                .:<br />:                               .'<br />'.                             :'<br />  :.                          .'<br />   '.                       .:'<br />    ':.                   .:'<br />      ':.              .:'<br />         ''..........''</p>
			<p>I thought that was a surprising variation that got a great amount of detail across.  The bill is probably the easiest to make out here, compared with all the solutions.</p>
			<p>Let's see the code for that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'RMagick'</span><br />    require <span class="string">'generator'</span><br />    require <span class="string">'enumerator'</span><br /><br />    puts <span class="string">"Usage: #{$0} &lt;img&gt; [size]"</span> <span class="keyword">or</span> exit <span class="keyword">if</span> !ARGV[0]<br /><br />    img, size = Magick::ImageList.new(ARGV[0]), (ARGV[1]||40).to_f<br />    factor = [size*1.5<span class="string">/img.rows, size/</span>img.columns].min<br /><br />    img.resize!(img.columns*factor, 2*(img.rows*factor*0.75).round)<br />    img = img.edge.despeckle.despeckle.normalize.threshold(50)<br /><br />    pixels = img.get_pixels(0, 0, img.columns, img.rows).map{|c| c.red.zero?}<br /><br />    pixels.to_enum(:each_slice, img.columns).each_slice(2) <span class="keyword">do</span> |l|<br />      puts SyncEnumerator.new(*l).map{|p1, p2|<br />        [<span class="string">' '</span>, <span class="string">"'"</span>, <span class="string">"."</span>, <span class="string">":"</span>] [(p1 ? 0 : 1) + (p2 ? 0 : 2)]}.join(<span class="string">''</span>)<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Here we see RMagick used again to read in the picture and resize it to something closer to terminal dimensions.  Instead of dropping the color map here though, we get an interesting chain of filters designed to draw out the edges of the primary subject.  (Obviously, this works better on some images than others.)</p>
			<p>What's after that?  I honestly had no clue.  to_enum(), each_slice(), SyncEnumerator?  Did I switch languages and nobody told me?  Obviously those two harmless looking requires at the beginning of the program change some of the rules and we're going to need to learn a little bit about "generator" and "enumerator".</p>
			<p>So, what's the first step?  I tried http://www.ruby-doc.org/ because I'm a wimp.  Yep, there's "generator" but we're in trouble with "enumerator".  No documentation!  I clicked the link anyway, to see what I could learn.</p>
			<p>Seems each_slice() is added to Enumerable by the library and it expects one argument.  Well, that's something.  It's a little hard to tell how it's being used in Simon's code (complicated by to_enum()), so I figure, just put something in an Array and try to call it.  That should tell us something.  irb to the rescue!</p>
			<p class="example">&gt;&gt; require "enumerator"<br />=&gt; true<br />&gt;&gt; pixels = (1..10).to_a<br />=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br />&gt;&gt; pixels.each_slice(2) { |slice| p slice }<br />[1, 2]<br />[3, 4]<br />[5, 6]<br />[7, 8]<br />[9, 10]<br />=&gt; nil</p>
			<p>Perfect!  That was all we need to see.  It allows you to take off chunks of an Array, it seems.  Dang that's cool!  Why didn't any of you tell me that was there?!</p>
			<p>Anybody see the Tic-Tac-Toe code posted to Ruby Talk on Tuesday?  Look how simple drawing the board can be:</p>
			<p class="example">&gt;&gt; board = Array.new(9) { rand &gt; 0.5 ? "X" : "O" }<br />=&gt; ["X", "O", "O", "O", "O", "O", "O", "X", "O"]<br />&gt;&gt; board.each_slice(3) { |row| puts row.join }<br />XOO<br />OOO<br />OXO<br />=&gt; nil</p>
			<p>Okay, we've got each_slice() figured out.  Let's do some more detective work.  Let's see if we can figure out to_enum().  When it is called in Simon's code it seems to get passed a method name (the one we just learned!) and a number.  Well, we know each_slice() requires a number, so maybe that's the argument to it?  Again, let's just see if we can call it:</p>
			<p class="example">&gt;&gt; pixels<br />=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br />&gt;&gt; enum = pixels.to_enum(:each_slice, 2)<br />=&gt; #&lt;Enumerable::Enumerator:0x342b58&gt;</p>
			<p>Well, we got... something.  Hmm, I wonder what it can do?</p>
			<p class="example">&gt;&gt; enum.methods  <br />=&gt; ["reject", "method", "send", "object_id", "enum_for", "singleton_methods",<br />"member?", "__send__", "equal?", "taint", "find", "frozen?",<br />"instance_variable_get", "each_with_index", "enum_cons", "kind_of?", "to_a",<br />"instance_eval", "collect", "all?", "entries", "type", "enum_with_index",<br />"protected_methods", "extend", "detect", "eql?", "display", "zip",<br />"instance_variable_set", "hash", "is_a?", "map", "to_s", "any?", "sort",<br />"class", "each_slice", "min", "tainted?", "private_methods", "find_all",<br />"untaint", "each", "id", "inspect", "inject", "==", "===", "sort_by", "clone",<br />"public_methods", "enum_slice", "max", "respond_to?", "select", "freeze",<br />"__id__", "to_enum", "partition", "=~", "methods", "grep", "nil?", "dup",<br />"each_cons", "instance_variables", "include?", "instance_of?"]</p>
			<p>Okay, it seems to be Enumerable.  Let's just see what each entry is:</p>
			<p class="example">&gt;&gt; enum.each { |e| p e }<br />[1, 2]<br />[3, 4]<br />[5, 6]<br />[7, 8]<br />[9, 10]<br />=&gt; nil</p>
			<p>Now I get it.  We turned an each_slice(2) call into an each() call.  That's interesting.</p>
			<p>It always bugs me that Strings iterate over lines instead of characters, by default, and now I have the tool to fix it:</p>
			<p class="example">&gt;&gt; char_str = "team".to_enum(:each_byte)<br />=&gt; #&lt;Enumerable::Enumerator:0x322d30&gt;<br />&gt;&gt; if char_str.any? { |c| c == ?i }<br />&gt;&gt;   puts "Huh?!"<br />&gt;&gt; else<br />?&gt;   puts "There's no I in T-E-A-M!"<br />&gt;&gt; end<br />There's no I in T-E-A-M!<br />=&gt; nil<br />&gt;&gt; char_str.to_a<br />=&gt; [116, 101, 97, 109]</p>
			<p>Notice how I was able to use any?() and to_a() there, because we switched each_byte() to each() and all other Enumerable methods use each().</p>
			<p>One more mysterious piece of the puzzle, but this one is documented, which almost takes all the fun out of it.  Here's the example right out of the documentation, minus some irb noise:</p>
			<p class="example">&gt;&gt; require "generator"<br />=&gt; true<br />&gt;&gt; s = SyncEnumerator.new([1, 2, 3], %w{a b c})<br />=&gt; #&lt;SyncEnumerator:0x1b339c ...&gt;<br />&gt;&gt; s.each { |row| puts row.join(", ") }<br />1, a<br />2, b<br />3, c<br />=&gt; #&lt;SyncEnumerator:0x1b339c ...&gt;</p>
			<p>Obviously, that just let's you traverse two Enumerable objects at once.  First you get the first entry of both, then the second, etc.  Nothing too tricky there.</p>
			<p>Still remember the code that started all this?</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    pixels.to_enum(:each_slice, img.columns).each_slice(2) <span class="keyword">do</span> |l|<br />      puts SyncEnumerator.new(*l).map{|p1, p2|<br />        [<span class="string">' '</span>, <span class="string">"'"</span>, <span class="string">"."</span>, <span class="string">":"</span>] [(p1 ? 0 : 1) + (p2 ? 0 : 2)]}.join(<span class="string">''</span>)<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This code iterates over rows of pixels (pixels.to_enum(:each_slice, img.columns) ...), two at-a-time (... .each_slice(2) ...).  It then traverses those two rows pixel-by-pixel in tandem (SyncEnumerator.new(*l).map{|p1, p2| ... }), averaging the two on/off values (... [' ', "'", ".", ":"] [(p1 ? 0 : 1) + (p2 ? 0 : 2)] ...), and printing the results (puts ... .join('')).  Work through that slowly, until it sinks in.  I know it took me a couple of tries.</p>
			<p>I better wrap this up, since it's already quite lengthy, but don't forget to take a peek at the other solutions.  Harold Hausman rolled his own code for analyzing bitmap images and others are now golfing that solution on Ruby Talk.  Rob Rypka and Brian Schroeder also did some sensational work mapping colors to characters, producing some nice gradients.</p>
			<p>A big thank you to all the enlightening solutions to this week's quiz.  The combined intelligence of the Ruby Quiz community is beyond measure.</p>
			<p>Tomorrow, I have a new game for you.  I figure it's The RubyConf Collective verses the rest of us in the tournament, right?</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159775">Simon Kr&ouml;ger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159778">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159780">Timothy Hunter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159840">Brian Fundakowski Feldman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159908">Rob Rypka</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159917">Brian Schr&ouml;der</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/160099">Simon Kr&ouml;ger (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/160131">Harold Hausman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/160192">daz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/160207">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/160269">Anthony Moralez</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/160316">Adam Shelly</a></li>
			</ol>
			<p><a href="quiz50_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
