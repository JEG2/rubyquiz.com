<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Chess960 (#106)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Chess960 (#106)</span>
			<p>by Kieran Wild</p>
			<p>Chess960, is a chess variant produced by Grandmaster Bobby Fischer by formalizing the rules of Shuffle Chess. Its goal was to create a chess variant in which chess creativity and talent would be more important than memorization and analysis of opening moves. His approach was to create a randomized initial chess position, which would thus make memorizing chess opening move sequences far less helpful. The initial position is set up in a special way and there are 960 such positions, thus the name Chess960.</p>
			<p>The starting position for Chess960 must meet certain rules. White pawns are placed on the second rank as in chess. All remaining white pieces are placed randomly on the first rank, but with the following restrictions:</p>
			<p class="example">* The king is placed somewhere between the two rooks.<br />* The bishops are placed on opposite-colored squares.</p>
			<p>The black pieces are placed equal-and-opposite to the white pieces. For example, if the white king is placed on b1, then the black king is placed on b8. Note that the king never starts on file a or h, because there would be no room for a rook</p>
			<p>Can I suggest a nice little ruby program to generates all 960 possible starting
positions and outputs a random one on request.</p>
			<p>Output could be as follows.</p>
			<p class="example">Starting Position 432:<br /><br />White<br /><br />a1 b1 c1 d1 e1 f1 g1 h1<br />N  B  B   R  K  R  Q  N<br /><br />Black<br /><br />a8 b8 c8 d8 e8 f8 g8 h8<br />N  B  B   R  K  R  Q  N</p>
			<p>Or some better output.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>There are a surprising number of ways to think about this problem, each leading to a different solution.  Let's examine several.</p>
			<p>First, you can think of this as a constraints problem.  We have the rules of a board setup which are the constraints and any board meeting those rules is one of the 960 positions.  Way back when we did the Constraint Processing Ruby Quiz, I learned that the Amb library is a fun way to handle such problems.  Here's my solution, using Amb:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">"amb"</span><br /><br />    setup = Amb.new<br />    count = 0<br />    seen  = Hash.new<br />    <span class="keyword">begin</span><br />      squares = Array.new(8) { setup.choose(*<span class="string">%w[r n b q k b n r]</span>) }<br /><br />      <span class="string">%w[r n b]</span>.each <span class="keyword">do</span> |piece|<br />        setup.assert(squares.select { |s| s == piece }.size == 2)<br />      <span class="keyword">end</span><br />      <span class="string">%w[k q]</span>.each <span class="keyword">do</span> |piece|<br />        setup.assert(squares.select { |s| s == piece }.size == 1)<br />      <span class="keyword">end</span><br />      king = squares.index(<span class="string">"k"</span>)<br />      setup.assert(squares.index(<span class="string">"r"</span>) &lt; king)<br />      setup.assert(squares.rindex(<span class="string">"r"</span>) &gt; king)<br />      setup.assert((squares.index(<span class="string">"b"</span>) + squares.rindex(<span class="string">"b"</span>)) % 2 == 1)<br />      board = squares.join(<span class="string">' '</span>)<br />      setup.assert(seen[board].nil?)<br /><br />      puts <span class="string">"#{count += 1}: #{board}"</span><br /><br />      seen[board] = <span class="keyword">true</span><br />      setup.failure<br />    <span class="keyword">rescue</span><br />      <span class="comment"># do nothing, we're done</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>What I really love above this approach is that it requires almost no thought.  All I am doing here is translating the rules to code.  Ruby and Amb do the rest.</p>
			<p>The above code works by building an Amb object that is considering piece placement in eight squares.  After that, I define the rules for placement.</p>
			<p>Since I gave it all eight pieces as possible choices for each square, the first two rules have to establish the allowed counts for each piece.  This prevents Amb from building a position of eight rooks or similar wrong setups.</p>
			<p>For the next two rules I locate the king and verify that we have a rook to the left of him as well as to the right.  The following rule adds the locations of the two bishops and verifies that we got an odd number.  This ensures the bishops are on different colors, since an even plus an odd will be odd but even plus even or odd plus odd both yield even numbers.  This group of rules covers the constraints from the quiz description.</p>
			<p>The final rule prevents duplicate positions being found.  It's needed because positions like the following example seem different to the computer, but not to a chess player:</p>
			<p class="example">N1 B1 B2 R1 K R2 Q N2<br />N2 B2 B1 R2 K R1 Q N1</p>
			<p>With the rules in place, Amb will have found a viable solution.  I print that out, then manually trigger a failure(), to cause it to find another.  When it fails to find one an Exception will be thrown.  I catch that and exit quietly since we will have seen all 960 positions at that point.</p>
			<p>The downside of this approach is that Amb uses Ruby's continuations to under the hood to backtrack and find new solutions.  Those are a bit on the slow side and this simple script of mine takes about six and a half minutes to complete, on my box.  One solution to this is just to generate the positions once and cache them for future runs but there were other solutions that could think a lot faster.</p>
			<p>For a faster solution, let's shift how we are thinking about the problem.  Another approach is to think of this challenge as a permutations problem.  We really just need to examine all possible permutations of the eight pieces and select those that match the quiz rules.  Multiple solutions did this, including the following code from David Tran:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> permutation(pieces)<br />     <span class="keyword">return</span> [pieces] <span class="keyword">if</span> pieces.length &lt;= 1<br />     result = []<br />     pieces.uniq.each <span class="keyword">do</span> |p|<br />       _pieces = pieces.dup<br />       _pieces.delete_at(pieces.index(p))<br />       permutation(_pieces).each <span class="keyword">do</span> |perm|<br />         result &lt;&lt; (perm &lt;&lt; p)<br />       <span class="keyword">end</span><br />     <span class="keyword">end</span><br />     result<br />    <span class="keyword">end</span><br /><br />    results = permutation(<span class="string">"RNBKQBNR"</span>.split(<span class="string">//</span>)).select <span class="keyword">do</span> |position|<br />     r1 = position.index(<span class="string">'R'</span>)<br />     r2 = position.rindex(<span class="string">'R'</span>)<br />     b1 = position.index(<span class="string">'B'</span>)<br />     b2 = position.rindex(<span class="string">'B'</span>)<br />     k = position.index(<span class="string">'K'</span>)<br />     r1 &lt; k &amp;&amp; k &lt; r2 &amp;&amp; ((b1+b2) % 2 != 0)<br />    <span class="keyword">end</span><br /><br />    puts <span class="string">"Total positions = #{results.length}"</span><br />    puts results[rand(results.length)].join(<span class="string">' '</span>)<br /><br /></div></div>
			<p>The permutation() method here is a recursive generator of all possible permutations.  It works by adding each() uniq() piece to all possible smaller permutations.  Those are found by removing one piece from the set each time and recursing.</p>
			<p>The rest of the code calls that method and then select()s the positions matching the quiz rules.  Those rules are almost identical to my implementation of them that we examined earlier.</p>
			<p>This code does the same thing as mine but runs in under a second on my box.</p>
			<p>Shifting the approach again, several methods have been developed to help players create positions using these rules as needed, some using dice.  Bodlaender's dice-rolling method is a pretty easy system to translate into code and Jamie Macey did just that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Chess960<br />     attr_reader :board_id, :board<br /><br />     <span class="keyword">def</span> initialize<br />       <span class="variable">@board</span> = generate_board(bodlaender_line)<br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> generate_board(white)<br />       <span class="comment"># Black's starting line is mirror of white's</span><br />       black = white.map{|piece| piece.downcase}<br /><br />       <span class="comment"># middle of board is always the same</span><br />       middle = [<br />         <span class="string">%w(p p p p p p p p)</span>,<br />         <span class="string">%w(_ _ _ _ _ _ _ _)</span>,<br />         <span class="string">%w(_ _ _ _ _ _ _ _)</span>,<br />         <span class="string">%w(_ _ _ _ _ _ _ _)</span>,<br />         <span class="string">%w(_ _ _ _ _ _ _ _)</span>,<br />         <span class="string">%w(P P P P P P P P)</span><br />       ]<br /><br />       <span class="comment"># add back rows</span><br />       [black] + middle + [white]<br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> bodlaender_line<br />       free = (0...8).to_a<br />       white = []<br /><br />       dark_bishop = rand(4) * 2<br />       light_bishop = rand(4) * 2 + 1<br />       white[dark_bishop] = <span class="string">'B'</span><br />       white[light_bishop] = <span class="string">'B'</span><br />       free.delete(dark_bishop)<br />       free.delete(light_bishop)<br /><br />       queen = rand(6)<br />       white[free[queen]] = <span class="string">'Q'</span><br />       free.delete_at(queen)<br /><br />       knight1 = rand(5)<br />       white[free[knight1]] = <span class="string">'N'</span><br />       free.delete_at(knight1)<br />       knight2 = rand(4)<br />       white[free[knight2]] = <span class="string">'N'</span><br />       free.delete_at(knight2)<br /><br />       white[free[0]] = <span class="string">'R'</span><br />       white[free[1]] = <span class="string">'K'</span><br />       white[free[2]] = <span class="string">'R'</span><br />       white<br />     <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The first two methods are trivial with initialize() kicking off the process and generate_board() building a board representation.  The interesting stuff happens in bodlaender_line().</p>
			<p>This algorithm works with a collection of free indices and an Array of the final piece arrangement.  As pieces are placed in the Array, those indices are pulled from the free list so they won't be reused.</p>
			<p>The first step is to place both bishops.  That's done by choosing a random number between one and four and placing it on the selected light or dark square.  After that, a random selection places the queen on one of the six remaining squares.  The same technique is used to place the knights on the remaining five and then four squares.  That leaves us three empty squares which must be R, K, and R, in that order, to satisfy the rules.</p>
			<p>Making one more leap of thought with regard to this problem, there has been an effort to enumerate all 960 positions.  This has a lot of value to chess players since we can record the game using our usual techniques and just add a note like, "Started from Chess960 position #351."  Even better, once you have a system for enumerating the positions, you can use that system to build the entire list or select a position.  Morton Goldberg gave us the code for that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Chess960<br />       BISHOP_TABLE = [<br />          <span class="string">"BB------"</span>, <span class="comment">#0</span><br />          <span class="string">"B--B----"</span>, <span class="comment">#1</span><br />          <span class="string">"B----B--"</span>, <span class="comment">#2</span><br />          <span class="string">"B------B"</span>, <span class="comment">#3</span><br />          <span class="string">"-BB-----"</span>, <span class="comment">#4</span><br />          <span class="string">"--BB----"</span>, <span class="comment">#5</span><br />          <span class="string">"--B--B--"</span>, <span class="comment">#6</span><br />          <span class="string">"--B----B"</span>, <span class="comment">#7</span><br />          <span class="string">"-B--B---"</span>, <span class="comment">#8</span><br />          <span class="string">"---BB---"</span>, <span class="comment">#9</span><br />          <span class="string">"----BB--"</span>, <span class="comment">#10</span><br />          <span class="string">"----B--B"</span>, <span class="comment">#11</span><br />          <span class="string">"-B----B-"</span>, <span class="comment">#12</span><br />          <span class="string">"---B--B-"</span>, <span class="comment">#13</span><br />          <span class="string">"-----BB-"</span>, <span class="comment">#14</span><br />          <span class="string">"------BB"</span>  <span class="comment">#15</span><br />       ]<br /><br />       N5N_TABLE = [<br />          <span class="string">"NN---"</span>, <span class="comment">#0</span><br />          <span class="string">"N-N--"</span>, <span class="comment">#1</span><br />          <span class="string">"N--N-"</span>, <span class="comment">#2</span><br />          <span class="string">"N---N"</span>, <span class="comment">#3</span><br />          <span class="string">"-NN--"</span>, <span class="comment">#4</span><br />          <span class="string">"-N-N-"</span>, <span class="comment">#5</span><br />          <span class="string">"-N--N"</span>, <span class="comment">#6</span><br />          <span class="string">"--NN-"</span>, <span class="comment">#7</span><br />          <span class="string">"--N-N"</span>, <span class="comment">#8</span><br />          <span class="string">"---NN"</span>  <span class="comment">#9</span><br />       ]<br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>The official numbering scheme, invented by Reinhard Scharnagl, works by using simple charts to position the pieces.  Above you can see Morton's translation of the two charts he will use, giving piece placements and their indices.  The knight charts are narrower because they are placed after the bishops and queen, taking three squares out of consideration.</p>
			<p>Here's the main algorithm from Morton's code (with a minor fix from me):</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="keyword">def</span> initialize(number)<br />          q, <span class="variable">@bishop_index</span> = number.divmod 16<br />          <span class="variable">@knight_index</span>, <span class="variable">@queen_index</span> = q.divmod 6<br />          <span class="variable">@white_pieces</span> = BISHOP_TABLE[<span class="variable">@bishop_index</span>].split(<span class="string">''</span>)<br />          <span class="variable">@white_pieces</span>[nth_dash(<span class="variable">@queen_index</span>)] = <span class="string">'Q'</span><br />          knights = N5N_TABLE[<span class="variable">@knight_index</span>]<br />          m = knights.index(<span class="string">'N'</span>)<br />          n = knights.index(<span class="string">'N'</span>, m + 1)<br />          m, n = nth_dash(m), nth_dash(n)<br />          <span class="variable">@white_pieces</span>[m] = <span class="string">'N'</span><br />          <span class="variable">@white_pieces</span>[n] = <span class="string">'N'</span><br />          <span class="variable">@white_pieces</span>[<span class="variable">@white_pieces</span>.index(<span class="string">'-'</span>)] = <span class="string">'R'</span><br />          <span class="variable">@white_pieces</span>[<span class="variable">@white_pieces</span>.index(<span class="string">'-'</span>)] = <span class="string">'K'</span><br />          <span class="variable">@white_pieces</span>[<span class="variable">@white_pieces</span>.index(<span class="string">'-'</span>)] = <span class="string">'R'</span><br />       <span class="keyword">end</span><br /><br />       <span class="keyword">def</span> nth_dash(n)<br />          dashes = []<br />          <span class="variable">@white_pieces</span>.each_with_index { |ch, i| dashes &lt;&lt; i <span class="keyword">if</span> ch == <span class="string">'-'</span> }<br />          dashes[n]<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>Most of the clever work is done in initialize().  First, a little math is used to find the lookup index on the bishop's chart, an index for the queen, and an index on the knight's chart.  The row selected from the bishop's chart becomes the basis for the final arrangement of pieces and nth_dash() is used to properly slot the queen in that template.  The knight's are then pulled from their chart by index and nth_dash() is again used to place them.  The three squares left then must be a rook, king, and rook in that order.</p>
			<p>The rest of Morton's code (again with minor changes by me) is just for displaying the results:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="keyword">def</span> inspect<br />          <span class="variable">@white_pieces</span>.join<br />       <span class="keyword">end</span><br /><br />       <span class="keyword">def</span> to_s<br />          white_pieces = <span class="variable">@white_pieces</span>.join + <span class="string">"\n"</span><br />          white_pawns = <span class="string">'P'</span> * 8 + <span class="string">"\n"</span><br />          black_pieces = white_pieces.downcase<br />          black_pawns = <span class="string">'p'</span> * 8 + <span class="string">"\n"</span><br />          empty = (<span class="string">'.'</span> * 8 + <span class="string">"\n"</span>) * 4<br />          black_pieces + black_pawns + empty + white_pawns + white_pieces<br />       <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />       <span class="keyword">begin</span><br />          <span class="keyword">if</span> ARGV.empty? <span class="keyword">then</span> n = rand(960)<br />          <span class="keyword">else</span><br />             n = ARGV.first.to_i<br />             raise StandardError <span class="keyword">unless</span> (0..959).include?(n)<br />          <span class="keyword">end</span><br />          puts <span class="string">"Initial position #{n}"</span><br />          print Chess960.new(n).to_s<br />       <span class="keyword">rescue</span> StandardError<br />          puts <span class="string">"Usage:  #{$PROGRAM_NAME} [&lt;integer&gt;]"</span><br />          puts <span class="string">"where &lt;integer&gt; is in 0..959"</span><br />          puts <span class="string">"Omitting &lt;integer&gt; produces a random initial position"</span><br />       <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>If you want to read more about the systems for assigning pieces, check out:</p>
			<p><a href="http://en.wikipedia.org/wiki/Chess960_starting_position">Chess960 Starting Position</a></p>
			<p>and:</p>
			<p><a href="http://en.wikipedia.org/wiki/Chess960_Enumbering_Scheme">Chess960 Enumbering Scheme</a></p>
			<p>There were a lot more creative elements in the solutions I didn't cover.  Jamie Macey even built a complete Camping application to display the positions.  Definitely take the time to look over them.  It's worth it.</p>
			<p>My thanks to all for another great quiz.  I'm a big chess nut some problems like this always thrill me.</p>
			<p>There will be no Ruby Quiz tomorrow.  I'll be busy having a merry Christmas and I wish the same for others.  See you in a week!</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230001">Chunyun Zhao</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230021">Darren Smith</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230034">William James</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230042">Robert Dober</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230053">Mushfeq Khan</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230062">Robert Dober (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230086">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230091">Jamie Macey</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230099">Ken Bloom</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230126">Eric I.</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230133">Pedro Fortuny Ayuso</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230143">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230145">William James (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230149">Morton Goldberg</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230151">Rob Biedenharn</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230200">Eric I. (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230264">Daniel Finnie</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230265">Daniel Finnie (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230335">Gordon Thiesfeld</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230413">Bob Showalter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230430">Robert Dober (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230460">James Cunningham</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/230486">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/231814">Alex Watt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/231815">Alex Watt (2)</a></li>
			</ol>
			<p><a href="quiz106_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
