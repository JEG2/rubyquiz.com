<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - QAPrototype (#91)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">QAPrototype (#91)</span>
			<p>by Caleb Tennis</p>
			<p>I remember playing with some old AI programs of which you could ask questions and if it didn't know the answer, it would ask you what the answer is:</p>
			<p class="example">Hi, I'm an AI program.  What's your question?<br /><br />&gt;&gt; How are you today?<br /><br />I'm afraid I don't know the answer to that.  Please tell me what I should say.<br /><br />&gt;&gt;&gt; Just fine, thanks.<br /><br />Okay, I will remember that.  Please ask a question.<br /><br />&gt;&gt;&gt; How are you today?<br /><br />Just fine, thanks.<br />Please ask another question.</p>
			<p>This got me thinking about an interesting concept in Ruby.</p>
			<p>Your Quiz: Write a Ruby module that can be mixed into a class.  The module does the following: upon receiving a method call that is unknown to the class, have Ruby inform the user that it doesn't know that particular method call.  Then, have it ask the user for Ruby code as input to use for that method call the next time it is called.</p>
			<p>Example:</p>
			<p class="example">&gt; object.some_unknown_method<br /><br />some_unknown_method is undefined<br />Please define what I should do (end with a newline):<br /><br />&gt;&gt; @foo = 5<br />&gt;&gt; puts "The value of foo is #{@foo}"<br />&gt;&gt;<br /><br />Okay, I got it.<br /><br />&gt;&gt;&gt; object.some_unknown_method<br />"The value of foo is 5"</p>
			<p>[Editor's Note:</p>
			<p>I envision this could actually be handy for prototyping classes IRb.  Bonus points if you can later print the source for all methods interactively defined.</p>
			<p>--JEG2]</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>While this quiz is based on the fun idea of an interactive Ruby conversation, the answers reinforced my belief that it holds practical value in prototyping Ruby objects.  Here's a sample run of me playing with one of the solutions:</p>
			<p class="example">$ irb -r qap.rb -r enumerator<br /><br />Call #start if you want to get a head start on QAPrototype...<br /><br />&gt;&gt; class PascalsTriangle; include QAPrototype; end<br />=&gt; PascalsTriangle<br />&gt;&gt; tri = PascalsTriangle.new<br />=&gt; #&lt;PascalsTriangle:0x33082c&gt;<br />&gt;&gt; tri.next<br /><br />next is undefined.<br />Please define what I should do, starting with arguments<br />this method should accept (skip and end with newline):<br /><br />def next <br />  case row<br />  when 0 then (@rows = [[1]]).last<br />  when 1 then (@rows &lt;&lt; [1, 1]).last<br />  else<br />    ( @rows &lt;&lt;<br />      [1] + @rows.last.enum_for(:each_cons, 2).map { |l, r| l + r } + [1]<br />      ).last<br />  end<br />  ensure<br />    @row += 1<br />  <br />end<br /><br />Okay, I got it.<br /><br /><br />Calling the method now!<br /><br /><br />row is undefined.<br />Please define what I should do, starting with arguments<br />this method should accept (skip and end with newline):<br /><br />def row <br />  @row ||= 0<br />  <br />end<br /><br />Okay, I got it.<br /><br /><br />Calling the method now!<br /><br />=&gt; [1]<br />&gt;&gt; tri.next<br />=&gt; [1, 1]<br />&gt;&gt; tri.next<br />=&gt; [1, 2, 1]<br />&gt;&gt; tri.next<br />=&gt; [1, 3, 3, 1]<br />&gt;&gt; tri.dump<br />class PascalsTriangle<br />  def next <br />    case row<br />    when 0 then (@rows = [[1]]).last<br />    when 1 then (@rows &lt;&lt; [1, 1]).last<br />    else<br />      ( @rows &lt;&lt;<br />        [1] + @rows.last.enum_for(:each_cons, 2).map { |l, r| l + r } + [1]<br />        ).last<br />    end<br />    ensure<br />      @row += 1<br />  end<br />  def row <br />    @row ||= 0<br />  end<br />end<br />=&gt; nil</p>
			<p>Notice how I just used the non-existent row() method in my definition of next().  I knew I would get a chance to fill it in when it was needed.  Building up a class this way lets you work from the high level down, coding as you go.  It's an interesting new way to think about programming.  I encourage everyone to play with it a little and decide what you think.</p>
			<p>The code for this is not hard to implement.  Here's a trivial solution by Erik Veenstra:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> QAPrototype<br />      <span class="keyword">def</span> method_missing(method_name)<br />        puts <span class="string">"#{method_name} is undefined"</span><br />        puts <span class="string">"Please define what I should do (end with a newline):"</span><br /><br />        (code ||= <span class="string">""</span>) &lt;&lt; (line = <span class="global">$stdin</span>.gets) <span class="keyword">until</span> line <span class="keyword">and</span> line.chomp.empty?<br /><br />        <span class="keyword">self</span>.<span class="keyword">class</span>.module_eval <span class="keyword">do</span><br />          define_method(method_name){eval code}<br />        <span class="keyword">end</span><br /><br />        at_exit <span class="keyword">do</span><br />          puts <span class="string">""</span><br />          puts <span class="string">"class #{self.class}"</span><br />          puts <span class="string">"  def #{method_name}"</span><br />          code.gsub(<span class="string">/[\r\n]+$/</span>, <span class="string">""</span>).split(<span class="string">/\r*\n/</span>).each{|s| puts <span class="string">" "</span>*4+s}<br />          puts <span class="string">"  end"</span><br />          puts <span class="string">"end"</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This code defines a QAPrototype module you can mix into any class you wish to interactively add methods to.  The only method in it currently is method_missing(), which Ruby calls whenever an unknown method is called.  This method prompts you for a method body, gathers some code, defines a new method on the current class that uses the given code, and finally arranges to have the method printed when IRb exits.  That literally covers everything asked for in the quiz, including my editor's note.</p>
			<p>A limitation of the above code is that it doesn't deal with method arguments.  That means you can only use it to create and call unparameterized methods.  Another element that made many of the solutions interesting is the extra methods they defined to further evolve the interaction process.</p>
			<p>Let's look at another solution that handles arguments and adds some nice extras.  Here's the beginning of the code used in the opening example of this summary, by Matt Todd:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> QAPrototype<br /><br />      attr :_methods_added<br /><br />      <span class="keyword">def</span> method_missing name, *args, &amp;block<br />        puts <span class="string">"\n#{name} is undefined.\n"</span><br />        puts <span class="string">"Please define what I should do, starting with arguments"</span><br />        puts <span class="string">"this method should accept (skip and end with newline):\n\n"</span><br /><br />        <span class="comment"># get arguments</span><br />        print <span class="string">"def #{name} "</span>; <span class="global">$stdout</span>.flush; arguments = <span class="global">$stdin</span>.gets<br /><br />        <span class="comment"># get method body</span><br />        method = <span class="string">""</span><br />        <span class="keyword">while</span> (print <span class="string">'  '</span>; <span class="global">$stdout</span>.flush; line = <span class="global">$stdin</span>.gets) != <span class="string">"\n"</span><br />          method &lt;&lt; <span class="string">"    "</span> &lt;&lt; line<br />        <span class="keyword">end</span><br />        puts <span class="string">"end\n"</span><br /><br />        <span class="keyword">if</span> method == <span class="string">""</span><br />          puts <span class="string">"\nOops: you left the method empty so we didn't add it.\n\n"</span><br />          <span class="keyword">return</span><br />        <span class="keyword">end</span><br /><br />        puts <span class="string">"\nOkay, I got it.\n\n"</span><br /><br />        <span class="comment"># now define a new method</span><br />        <span class="keyword">self</span>.<span class="keyword">class</span>.class_eval <span class="string">&lt;&lt;-"end;"<br />          def #{name} #{arguments}<br />            #{method}<br />          end</span><br />        <span class="keyword">end</span>;<br /><br />        <span class="comment"># and store the results to the stack for undoes and dumps</span><br />        <span class="variable">@_methods_added</span> ||= []<br />        <span class="variable">@_methods_added</span> &lt;&lt; { :name      =&gt; name,<br />                             :arguments =&gt; arguments.chomp,<br />                             :body      =&gt; method.chomp }<br /><br />        puts <span class="string">"\nCalling the method now!\n\n"</span><br /><br />        <span class="keyword">return</span> <span class="keyword">self</span>.method(name).call(*args, &amp;block)<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method is not too different from the one we examined earlier. Again the user is prompted to enter code, but this time the code prompts for an argument list first.  This allows you to specify fixed or variable argument lists, with or without default values.  Once it has the arguments, the method reads the body of code until you feed it a blank line.  If you leave the body blank, the code skips adding it.  Otherwise a quick call to class_eval() installs the method.  Note the clever use of end; to close the heredoc in this code.  A Hash of method details is also added to the @_methods_added Array, so the code can look up information in later operations.  Before this method exits, it triggers the call you wanted to make in the first place.</p>
			<p>Here's a new feature provided by this module:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> undo<br />        the_method = <span class="variable">@_methods_added</span>.pop<br /><br />        <span class="keyword">if</span> the_method.nil?<br />          puts <span class="string">"\nYou have not interactively defined any methods!\n"</span><br />          <span class="keyword">return</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">self</span>.<span class="keyword">class</span>.class_eval { remove_method the_method[:name] }<br /><br />        puts <span class="string">"\n#{the_method[:name]} is now gone from this class.\n\n"</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>When called, undo() pulls the last method added back out of its internal list and removes it from the class.  Future calls to the same method will again be funneled through method_missing() so you can redefine the code.</p>
			<p>Here are a few more methods you can use to get information back out of the object:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="keyword">def</span> dump filename = <span class="keyword">nil</span><br />        body = <span class="string">""</span><br />        <span class="variable">@_methods_added</span>.each <span class="keyword">do</span> |method|<br />          body &lt;&lt; <span class="string">&lt;&lt;-"end;"<br />      def #{method[:name]} #{method[:arguments]}<br />    #{method[:body]}<br />      end</span><br />    <span class="keyword">end</span>;<br />        <span class="keyword">end</span><br /><br />        klass = <span class="string">&lt;&lt;-"end;"<br />    class #{self.class}<br />    #{body.chomp}<br />    end</span><br />    <span class="keyword">end</span>;<br /><br />        <span class="keyword">if</span> !filename.nil?<br />          File.open(filename, File::CREAT|File::TRUNC|File::RDWR, 0644) <span class="keyword">do</span> |file|<br />            <span class="keyword">if</span> file.write klass<br />              puts <span class="string">"\nClass was written to #{filename} successfully!\n\n"</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">else</span><br />          puts klass<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> added_methods<br />        <span class="variable">@_methods_added</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">alias</span> :methods_added :added_methods<br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The main point of interest here is the dump() method.  When called, is builds up method definitions for all interactively defined methods and wraps those in a class definition.  If you provided a filename with the call, the entire definition is dumped to the indicated file.  Otherwise the code is printed to STDOUT.</p>
			<p>This code has one final interesting feature, a sort of jump-start mode for IRb:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Foo; include QAPrototype; <span class="keyword">end</span><br /><br />    puts <span class="string">"\nCall #start if you want to get a head start on QAPrototype...\n\n"</span><br /><br />    <span class="keyword">def</span> start<br />      puts <span class="string">"\nirb(prep):001:0&gt; @f = Foo.new"</span><br />      puts <span class="string">"irb(prep):002:0&gt; @f.bar\n\n"</span><br /><br />      puts <span class="string">"For your convenience in testing, I've created a class called"</span><br />      puts <span class="string">"Foo and have already mixed in QAPrototype! Aren't you glad?"</span><br />      puts <span class="string">"And while I was at it, I went ahead and created an instance"</span><br />      puts <span class="string">"of Foo and put it into @f. Now we can all shout for joy!"</span><br />      puts <span class="string">"Heck, we even started up the conversation with method_missing!"</span><br /><br />      <span class="variable">@f</span> = Foo.new<br />      <span class="variable">@f</span>.bar<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This code just loads the module into a class and provides a globally available method to create one of these objects and start the method definition process with a call to a non-existent method.  This is just a nice shortcut for getting started right away when you are playing with this module.</p>
			<p>My thanks to all for their creative development of an exciting new way to incrementally and interactively develop code.  I think we may be on to something here, for a least some use cases.</p>
			<p>Tomorrow I will launch the last queued quiz submission.  We've had a sensational run of submissions, so don't let it end now!  Keep the ideas rolling on in...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209483">darren kirby</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209491">Sander Land</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209496">Mario Steele</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209511">Tim Hollingsworth</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209524">Rick DeNatale</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209528">Brent Fitzgerald</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209565">Scott Bauer</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209567">Rick DeNatale (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209577">darren kirby (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209587">Matt Todd</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209828">Stephen Lock</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209957">Erik Veenstra</a></li>
			</ol>
			<p><a href="quiz91_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
