<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Word Search (#107)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Word Search (#107)</span>
			<p>by Daniel Finnie</p>
			<p>Today's quiz would've been most useful in elementary school, where over half of the homework assignments were word search puzzles. The concept of these puzzles is simple enough that an elementary school student could understand it:  given a box of letters, find a line containing the letters of a specified word in order.</p>
			<p>For example, find the words ruby, dan, rocks, and matz in the following text:</p>
			<p class="example">U E W R T R B H C D<br />C X G Z U W R Y E R<br />R O C K S B A U C U<br />S F K F M T Y S G E<br />Y S O O U N M Z I M<br />T C G P R T I D A N<br />H Z G H Q G W T U V<br />H Q M N D X Z B S T<br />N T C L A T N B C E<br />Y B U R P Z U X M S</p>
			<p>The correct answer in the correct output format:</p>
			<p class="example">+ + + R + + + + + +<br />+ + + + U + + + + +<br />R O C K S B + + + +<br />+ + + + + + Y + + +<br />+ + + + + + + + + M<br />+ + + + + + + D A N<br />+ + + + + + + T + +<br />+ + + + + + Z + + +<br />+ + + + + + + + + +<br />Y B U R + + + + + +</p>
			<p>Notice that the words can go backwards and diagonally, and can intersect one another. Searching is case insensitive.</p>
			<p>The word search solver should accept input entered by the user after running the program, i.e., not exclusively through STDIN or a file, by entering the puzzle line by line, pressing return after each line. A blank line indicates the end of the puzzle and the start of the comma separated words to find. The following example shows how a user would enter the above puzzle, with descriptive text from the program removed.</p>
			<p class="example">$ ./wordsearch.rb<br />UEWRTRBHCD<br />CXGZUWRYER<br />ROCKSBAUCU<br />SFKFMTYSGE<br />YSOOUNMZIM<br />TCGPRTIDAN<br />HZGHQGWTUV<br />HQMNDXZBST<br />NTCLATNBCE<br />YBURPZUXMS<br /><br />Ruby, rocks, DAN, matZ</p>
			<p>Now, by itself, this quiz is fairly simple, so I offer an additional challenge. Write a beautiful, extensible, and easily-modifiable program without looking at the extra credit before starting. When you're done, try implementing extra credit options using less than 5 or 6 (reasonable) lines of code.</p>
			<p class="example">* An output format superior to the one given. The output format given<br />  should remain the default unless both formats don't differ on a<br />  textual basis. That should sound cryptic until pondered, I can't<br />  give too much away!<br />* Allow for "snaking" of answers, in other words, the letters<br />  composing a word don't have to be in a straight line.<br />* An option to give a hint, i.e., "The word ruby traverses the bottom<br />  left and bottom right quadrants."<br />* Decide what to do with accented letters.<br />* Allow for wildcard letters.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I had a few moments this weekend and sat down to work this problem.  I was quite surprised to find it tougher than I had expected.  I fiddled around for about an hour trying to find a solution I felt was elegant, but never really got there.  Luckily, we have many submitters smarter than me.</p>
			<p>Almost all of the solutions this week took different approaches and they are all quite interesting.  This doesn't seem to be one of those problems we have a standard approach for.  Some solutions did a boring search using X and Y coordinates; others started by building a map of points in the puzzle to letters or even letters to points; one even works by performing board transformations.  I'm going to show the basic X and Y search in this summary, but the other method were equally interesting and well worth a look.</p>
			<p>Let's talk about the solution from Bob Showalter, which begins like this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> WordSearch<br /><br />     <span class="keyword">class</span> Board &lt; Array<br /><br />       <span class="keyword">def</span> to_s<br />         collect {|s| s.split(<span class="string">//</span>).join(<span class="string">' '</span>)}.join(<span class="string">"\n"</span>)<br />       <span class="keyword">end</span><br /><br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we see an Array subclass with a trivial modification.  Board objects are just two-dimensional Arrays that know how to draw themselves in the quiz output format.</p>
			<p>Let's move on to the setup code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     attr_reader :board, :solution<br /><br />     <span class="comment"># creates a new, empty solver</span><br />     <span class="keyword">def</span> initialize<br />       <span class="variable">@board</span> = Board.new<br />       <span class="variable">@solution</span> = Board.new<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># resets the solution</span><br />     <span class="keyword">def</span> reset<br />       <span class="variable">@solution</span>.clear<br />       <span class="variable">@board</span>.each {|row| <span class="variable">@solution</span> &lt;&lt; row.gsub(<span class="string">/./</span>, <span class="string">'+'</span>)}<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we have the initialization for two Board objects.  One will hold the actual board, or puzzle object, and the other the solution-in-progress.  reset() gives us hints at the solution object structure, which is cleared to a board full of plus characters.</p>
			<p>The board is loaded with the following code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="comment"># checks that the board contains only letters and that it has a uniform</span><br />     <span class="comment"># rectangular shape</span><br />     <span class="keyword">def</span> validate<br />       <span class="variable">@board</span>.size &gt; 0 <span class="keyword">or</span> raise <span class="string">"Board has no rows"</span><br />       <span class="variable">@board</span>.grep(<span class="string">/[^A-Z]/</span>).empty? <span class="keyword">or</span> raise <span class="string">"Board contains non-letters"</span><br />       w = <span class="variable">@board</span>.collect {|row| row.size}.uniq<br />       w.size == 1 <span class="keyword">or</span> raise <span class="string">"Board rows are not all the same length"</span><br />       w.first &gt; 0 <span class="keyword">or</span> raise <span class="string">"Board has no columns"</span><br />     <span class="keyword">end</span><br /><br />     <span class="comment"># parses the board by reading lines from io until a blank line (or EOF)</span><br />     <span class="comment"># is read.</span><br />     <span class="keyword">def</span> parse(io = ARGV)<br />       <span class="variable">@board</span>.clear<br />       <span class="keyword">while</span> line = io.gets<br />         line = line.strip.upcase<br />         <span class="keyword">break</span> <span class="keyword">if</span> line == <span class="string">''</span><br />         <span class="variable">@board</span> &lt;&lt; line<br />       <span class="keyword">end</span><br />       validate<br />       reset<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>validate() is just a reality check for the board.  It verifies that we have some rows, those rows contain letters, there are columns in each row, and in fact the same number of columns.  That check is run towards the end of parse(), which just reads line by line filling the board object.  Note that reset() is also called to prepare the solution object.</p>
			<p>The real work comes in the methods that search for words:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="comment"># search for word. returns number of times found.  solution is updated</span><br />     <span class="comment"># with all occurences.</span><br />     <span class="keyword">def</span> search(word)<br />       found = 0<br />       0.upto(board.size-1) <span class="keyword">do</span> |y|<br />         0.upto(board[y].size-1) <span class="keyword">do</span> |x|<br />           [-1, 0, 1].each <span class="keyword">do</span> |dy|<br />             [-1, 0, 1].each <span class="keyword">do</span> |dx|<br />               <span class="keyword">next</span> <span class="keyword">if</span> dx == 0 <span class="keyword">and</span> dy == 0<br />               found += 1 <span class="keyword">if</span> search_for(word.strip.upcase, x, y, dx, dy)<br />             <span class="keyword">end</span><br />           <span class="keyword">end</span><br />         <span class="keyword">end</span><br />       <span class="keyword">end</span><br />       found<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># search for word in board starting at position (x,y) and moving in</span><br />     <span class="comment"># direction (dx,dy). returns true if found, false if not found.</span><br />     <span class="keyword">def</span> search_for(word, x, y, dx, dy)<br />       <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> x &lt; 0                 <span class="keyword">or</span><br />                       x &gt;= board.first.size <span class="keyword">or</span><br />                       y &lt; 0                 <span class="keyword">or</span><br />                       y &gt;= board.size<br />       <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> board[y][x] != word[0]<br />       prev = solution[y][x]<br />       solution[y][x] = board[y][x]<br />       <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> word.length &lt;= 1<br />       found = search_for(word[1,word.length-1], x + dx, y + dy, dx, dy)<br />       solution[y][x] = prev <span class="keyword">unless</span> found<br />       found<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>The search() method manages the hunt for a single term.  It's a trivial brute-force find from every starting square in all eight directions.  The method maintains and returns a count, for all occurrences found during the search.  The actual letter match is handed off to search_for() though.</p>
			<p>In search_for() a recursive search is used to find letter by letter.  The tricky part here is that the solution object is modified as we search, assuming we will find the word.  This means that an extra walk isn't needed to update the solution later, but it also means the code must revert the changes to the solution object if the word isn't found.  Those are the gymnastics you see in the second half of the method.</p>
			<p>The next two methods wrap an interface around these calls:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="comment"># creates a new puzzle by parsing the board from io. see</span><br />     <span class="comment"># WordSearch#parse</span><br />     <span class="keyword">def</span> <span class="keyword">self</span>.parse(io = ARGF)<br />       obj = new<br />       obj.parse(io)<br />       obj<br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> to_s<br />       solution.to_s<br />     <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The class method parse() constructs an object and parses the board from the passed IO object.  The instance method to_s() can then be used to show final results, after one or more calls to search().</p>
			<p>The solution ends with code to kick-off the process:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># parse the board first</span><br />    p = WordSearch.parse<br /><br />    <span class="comment"># parse the words until a blank line is read</span><br />    words = []<br />    <span class="keyword">while</span> line = ARGF.gets<br />     line = line.strip.upcase<br />     <span class="keyword">break</span> <span class="keyword">if</span> line == <span class="string">''</span><br />     words += line.gsub(<span class="string">','</span>, <span class="string">' '</span>).split<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># submit each word and show how many times it was found</span><br />    <span class="keyword">for</span> word <span class="keyword">in</span> words.sort.uniq<br />     n = p.search(word)<br />     puts word + <span class="string">' was '</span> + (n == 0 ? <span class="string">'not found'</span>  :<br />                            n == 1 ? <span class="string">'found once'</span> :<br />                                     <span class="string">"found #{n} times"</span>)<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># show the solution</span><br />    puts p<br /><br /></div></div>
			<p>Here we see the WordSearch object constructed and the board parsed out of the input.  The remainder of the input is divided into words and search() is called for each one.  A found count is printed for each word as the search is made, then the final solution is displayed.</p>
			<p class="example">+ + + M + + + + + +<br />+ + + + Y + + + + +<br />T H A N K S + + + +<br />O + + + + + + + + +<br />+ L L A + T H E + +<br />+ + + + C + + + + +<br />+ + S O L V E R S +<br />+ + + + e + + + + +<br />+ + + + V + + + + +<br />+ + + + E + + + + +<br />+ + + + R + + + + +</p>
			<p>Tomorrow we have a new word game, so stay tuned...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232010">Mariano Kamp</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232022">Martin Boese</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232043">John Watson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232049">Alex Watt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232054">Ben Ford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232070">Glen F. Pankow</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232117">Bob Showalter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232238">Alex Watt (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232243">Chunyun Zhao</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232435">William James</a></li>
			</ol>
			<p><a href="quiz107_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
