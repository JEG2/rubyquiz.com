<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Regexp.build() (#4)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Regexp.build() (#4)</span>
			<p>There's been some discussion on Ruby Talk lately about Range.member? which tests if a given element (often a number) is a member of the set the Range object iterates over.  Obviously, this kind of test is useful in many aspects of programming, but let's approach this problem from a different angle.</p>
			<p>This week's quiz is to build a library that adds a class method called build() to Regexp.  build() should accept a variable number of arguments which can include integers and ranges of integers.  Have build() return a Regexp object that will match only integers in the set of passed arguments.</p>
			<p>Here are some examples of possible usage:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    lucky = Regexp.build( 3, 7 )<br />    <span class="string">"7"</span>    =~ lucky    <span class="comment"># =&gt; true</span><br />    <span class="string">"13"</span>   =~ lucky    <span class="comment"># =&gt; false</span><br />    <span class="string">"3"</span>    =~ lucky    <span class="comment"># =&gt; true</span><br /><br />    month = Regexp.build( 1..12 )<br />    <span class="string">"0"</span>    =~ month    <span class="comment"># =&gt; false</span><br />    <span class="string">"1"</span>    =~ month    <span class="comment"># =&gt; true</span><br />    <span class="string">"12"</span>   =~ month    <span class="comment"># =&gt; true</span><br />    day = Regexp.build( 1..31 )<br />    <span class="string">"6"</span>    =~ day      <span class="comment"># =&gt; true</span><br />    <span class="string">"16"</span>   =~ day      <span class="comment"># =&gt; true</span><br />    <span class="string">"Tues"</span> =~ day      <span class="comment"># =&gt; false</span><br />    year = Regexp.build( 98, 99, 2000..2005 )<br />    <span class="string">"04"</span>   =~ year     <span class="comment"># =&gt; false</span><br />    <span class="string">"2004"</span> =~ year     <span class="comment"># =&gt; true</span><br />    <span class="string">"99"</span>   =~ year     <span class="comment"># =&gt; true</span><br /><br />    num = Regexp.build( 0..1_000_000 )<br />    <span class="string">"-1"</span>   =~ num      <span class="comment"># =&gt; false</span><br /><br /></div></div>
			<p>Some issues you may want to consider while building you're library:</p>
			<p>* How should leading zeros be handled?</p>
			<p class="example">Match the hour from a clock formatted in military time (0 to 23).  Hours 0<br />through 9 may or may not have a single leading zero.</p>
			<p>* Should anything be captured by the returned Regexp?</p>
			<p>* How should anchoring work?</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="string">"2004"</span> =~ Regexp.build( 4 )    <span class="comment"># =&gt; ???</span><br /></div></div>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>The first thing to consider in this quiz is what does a Regexp to match a number look like?  Here's the most basic answer to match 1..12:</p>
			<p class="example">1|2|3|4|5|6|7|8|9|10|11|12</p>
			<p>Note:  You might want to reverse the order of that, unless you can count on your anchoring to match the right thing.</p>
			<p>Obviously, the above works and is dirt simple to implement.  Here's a submitted solution by Tanaka Akira that does pretty much that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> Regexp.build(*args)<br />        args = args.map {|arg| Array(arg) }.flatten.uniq.sort<br />        neg, pos = args.partition {|arg| arg &lt; 0 }<br />        <span class="string">/ \A (?: -0*#{Regexp.union(*neg.map {|arg| (-arg).to_s })} |<br />                 0*#{Regexp.union(*pos.map {|arg| arg.to_s })} ) \z /x</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The first line of that method is pretty clever, calling Array() on all the passed arguments.  That turns Range objects into the Array equivalent and wraps simple Integers in an Array of their own.  Following that up with flatten() yields a single Array of all the elements we're trying to match.</p>
			<p>The second line just separates the arguments into positive and negative groups.</p>
			<p>Finally the third line builds a Regexp object from the created groups using the nifty Regexp.union() that I wasn't even aware of when I made this quiz.</p>
			<p>(This solution handles negative numbers and allows for arbitrary leading zeros.)</p>
			<p>Is this quiz really this easy to solve?  Obviously it can be, for simple data sets.  However, Tanaka's solution has limits.  On my box, it only takes:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    Regexp.build(1..10_000)<br /><br /></div></div>
			<p>to get a "...regular expression too big..." error.  Clearly, if your data set is big you'll need to dig a little deeper.</p>
			<p>That get's us back to our original question, but now with a qualification:  What is a short way to match a number with a Regexp?  The most obvious optimization to apply to our patterns is the use of character classes.  Going back to our 1..12 example that might give us something like:</p>
			<p class="example">\d|1[0-2]</p>
			<p>That's getting a lot more reasonable.  Going to a serious example, even 1..1_000_000 is only:</p>
			<p class="example">[1-9]|[1-9]\d|[1-9]\d\d|[1-9]\d\d\d|[1-9]\d\d\d\d|[1-9]\d\d\d\d\d|1000000</p>
			<p>Technically, we could keep going and get to something like:</p>
			<p class="example">[1-9]\d{0,5}|1000000</p>
			<p>But that's a little trickier to build algorithmically and none of the submitted solutions went quite that far.</p>
			<p>The character class approach, on the other hand, was very popular.</p>
			<p>The main trick to building character classes is to break down the passed Range objects.  You could also lump in the individual Integer arguments, but these are pretty insignificant.  Several solutions solved this by adding a method to the Range class to convert them into Regexps.</p>
			<p>Adding a Regexp.build() over that is trivial.  Here's a nice example from Mark Hubbart's second submission:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> Regexp.build(*args)<br />      ranges, numbers = args.partition{|item| Range === item}<br />      re = ranges.map{|r| r.to_re } + numbers.map{|n| <span class="string">/0*#{n}/</span> }<br />      <span class="string">/^#{Regexp.union(*re)}$/</span><br />    <span class="keyword">end</span><br /><br /><br />    <span class="keyword">class</span> Range<br />      <span class="keyword">def</span> to_re<br />        <span class="comment"># normalize the range format; we want end inclusive,</span><br />        <span class="comment"># integer ranges this part passes the load off to a</span><br />        <span class="comment"># newly built range if needed.</span><br />        <span class="keyword">if</span> exclude_end?<br />          <span class="keyword">return</span>( (first.to_i..last.to_i - 1).to_re )<br />        <span class="keyword">elsif</span> ! (first + last).kind_of?(Integer)<br />          <span class="keyword">return</span>( (first.to_i .. last.to_i).to_re )<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Deal with ranges that are wholly or partially negative.</span><br />        <span class="comment"># If range is only partially negative, split in half and</span><br />        <span class="comment"># get two regexen. join them together for the finish.</span><br />        <span class="comment"># If the range is wholly negative, make it positive, then</span><br />        <span class="comment"># add a negative sign to the regexp</span><br />        <span class="keyword">if</span> first &lt; 0 <span class="keyword">and</span> last &lt; 0<br />          <span class="comment"># return a negatized version of the regexp</span><br />          <span class="keyword">return</span> <span class="string">/-#{(-last..-first).to_re}/</span><br />        <span class="keyword">elsif</span> first &lt; 0<br />          neg = (first..-1).to_re<br />          pos = (0..last).to_re<br />          <span class="keyword">return</span> <span class="string">/(?:#{neg}|#{pos})/</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment">### First, create an array of new ranges that are more</span><br />        <span class="comment">### suited to regex conversion.</span><br /><br />        <span class="comment"># a and z will be the remainders of the endpoints</span><br />        <span class="comment"># of the range as we slice it</span><br />        a, z = first, last<br /><br />        <span class="comment"># build the first part of the list of new ranges.</span><br />        list1 = []<br />        num = first<br />        <span class="keyword">until</span> num &gt; z<br />          a = num <span class="comment"># recycle the value</span><br />          <span class="comment"># get the first power of ten that leaves a remainder</span><br />          v = 10<br />          v *= 10 <span class="keyword">while</span> num % v == 0 <span class="keyword">and</span> num != 0<br />          <span class="comment"># compute the next value up</span><br />          num += v - num % v<br />          <span class="comment"># store the value unless it's too high</span><br />          list1 &lt;&lt; (a..num-1) <span class="keyword">unless</span> num &gt; z<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># build the second part of the list; counting down.</span><br />        list2 = []<br />        num = last + 1<br />        <span class="keyword">until</span> num &lt; a<br />          z = num - 1 <span class="comment"># recycle the value</span><br />          <span class="comment"># slice to the nearest power of ten</span><br />          v = 10<br />          v *= 10 <span class="keyword">while</span> num % v == 0 <span class="keyword">and</span> num != 0<br />          <span class="comment"># compute the next value down</span><br />          num -= num % v<br />          <span class="comment"># store the value if it fits</span><br />          list2 &lt;&lt; (num..z) <span class="keyword">unless</span> num &lt; a<br />        <span class="keyword">end</span><br />        <span class="comment"># get the chewey center part, if needed</span><br />        center = a &lt; z ? [a..z] : []<br />        <span class="comment"># our new list</span><br />        list = list1 + center + list2.reverse<br /><br />        <span class="comment">### Next, convert each range to a regexp.</span><br />        list.map! <span class="keyword">do</span> |rng|<br />          a, z = rng.first.to_s, rng.last.to_s<br />          a.split(<span class="string">//</span>).zip(z.split(<span class="string">//</span>)).map <span class="keyword">do</span> |(f,l)|<br />            <span class="keyword">case</span><br />              <span class="keyword">when</span> f == l <span class="keyword">then</span> f<br />              <span class="keyword">when</span> f.to_i + 1 == l.to_i <span class="keyword">then</span> <span class="string">"[%s%s]"</span> % [f,l]<br />              <span class="keyword">when</span> f+l == <span class="string">"09"</span> <span class="keyword">then</span> <span class="string">"\\d"</span><br />              <span class="keyword">else</span><br />                <span class="string">"[%s-%s]"</span> % [f,l]<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span>.join <span class="comment"># returns the regexp for *that* range</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment">### Last, return the final regexp</span><br />        <span class="string">/0*#{ list.join("|") }/</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The first third of the to_re() method just deals with normalizing Ranges and is very well commented.</p>
			<p>The middle third divides the Range into Regexp friendly chunks which are groups that share the same number of digits.  For example, here is what to_re() builds into the local "list" variable for 1..1_000:</p>
			<p class="example">1..9<br />10..99<br />100..999<br />1000..1000</p>
			<p>The final third of to_re() builds character classes from these grouped Ranges.  The code inside "list.map! do ... end" is pretty clever and I recommend working through it until you can follow how it works.</p>
			<p>A big part of using these solutions is a question of how long you'll have to wait for a Regexp object to be built and how quickly the result can find a match.  Here are some benchmarks, first for build times:</p>
			<p class="example">                               user     system      total        real<br />James Edward Gray II       63.490000   0.020000  63.510000 ( 63.512904)<br />James Edward Gray II (2)   20.270000   0.000000  20.270000 ( 20.307565)<br />Jamis Buck                 0.490000   0.000000   0.490000 (  0.488664)<br />Mark Hubbart               0.290000   0.010000   0.300000 (  0.297225)<br />Mark Hubbart (2)           0.030000   0.000000   0.030000 (  0.028206)<br />Tanaka Akira               0.440000   0.000000   0.440000 (  0.442430)<br />Thomas Leitner             0.020000   0.000000   0.020000 (  0.013544)<br />Warren Brown               0.020000   0.000000   0.020000 (  0.015618)</p>
			<p>Or focusing in on the faster solutions over a bigger test:</p>
			<p class="example">                       user     system      total        real<br />Mark Hubbart (2)   3.390000   0.000000   3.390000 (  3.415515)<br />Thomas Leitner     2.120000   0.000000   2.120000 (  2.138968)<br />Warren Brown       2.290000   0.000000   2.290000 (  2.280555)</p>
			<p>As you can see, Thomas Leitner and Warren Brown's solutions are also worth a look, if you haven't checked them out already.  Warren's even has a clever feature to tell you which parameter of build() caused a match.</p>
			<p>And here are some matching benchmarks (build times excluded from results):</p>
			<p class="example">                               user     system      total        real<br />James Edward Gray II       0.070000   0.000000   0.070000 (  0.079497)<br />James Edward Gray II (2)   0.100000   0.000000   0.100000 (  0.115083)<br />Jamis Buck                 5.480000   0.000000   5.480000 (  5.502583)<br />Mark Hubbart               4.590000   0.000000   4.590000 (  4.617739)<br />Mark Hubbart (2)           0.100000   0.010000   0.110000 (  0.124735)<br />Tanaka Akira               4.570000   0.010000   4.580000 (  4.741717)<br />Thomas Leitner             0.100000   0.000000   0.100000 (  0.121431)<br />Warren Brown               0.130000   0.000000   0.130000 (  0.123779)</p>
			<p>As usual, my thanks go out to all who participated as well as to those who just silently followed the discussion.</p>
			<p>I've been unexpectedly called out of town this weekend, so we'll take a break from Ruby Quiz.  Sink all the effort you intended to give next week's quiz into filling my inbox with quiz suggestions.  ;)</p>
			<p>I'll send out a new quiz on the 29th that's all fun and games...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/116906">Jamis Buck</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/116919">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/116923">Tanaka Akira</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/116928">Mark Hubbart</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/116940">Mark Hubbart (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/116967">Warren Brown</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/116978">James Edward Gray II (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/117079">Thomas Leitner</a></li>
			</ol>
			<p><a href="quiz4_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
