<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Magic Fingers (#120)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Magic Fingers (#120)</span>
			<p>We have a foreign exchange student from Korea staying with us.  The best part of that is the intended exchange of cultures.  For example, to kill time on a recent plane trip, the student taught us a common finger game children play in Korea.</p>
			<p>The rules are very easy:</p>
			<p class="example">1.  Both players start by holding up one finger on each hand.<br />2.  On each turn a player must do one of the following:<br />  a.  Touch one of their hands to an opponent's hand, adding the finger<br />      count on their hand to the touched hand.  The player keeps the same<br />      number of fingers, but the opponent must add the player's finger<br />      count in addition to the fingers already on that hand.<br />  b.  Clap their hands together to "transfer" one or more fingers from<br />      one hand to the other.  You cannot transfer all the fingers off of<br />      a hand.<br />3.  A hand with five or more fingers is eliminated, which is shown by<br />    making a fist.  An opponent can not add fingers to an eliminated<br />    hand and an it cannot be used in touches, but players may transfer<br />    fingers to it, "reviving" it.  The first player with two eliminated<br />    hands loses the game.</p>
			<p>For example, here is how a quick game might play out:</p>
			<p class="example">1:  ----|  |----  Starting fingers.<br />2:  ----|  |----<br /><br />1:  ----|  |----  Player 1's left hand touches player 2's right hand.<br />2:  ----|  ||---<br /><br />1:  ----|  |||--  2's right touches 1's right hand.<br />2:  ----|  ||---<br /><br />1:  ----|  |||--  1's right touches 2's right hand.<br />2:  ----|  -----<br /><br />1:  ----|  ||||-  2's left touches 1's right hand.<br />2:  ----|  -----<br /><br />1:  ----|  |||--  1's right touches 2's left hand.<br />2:  -----  -----</p>
			<p>Of course, as a programmer, I immediately tried to solve this game.  I suck the fun right out of everything, but at least it gave us another quiz topic.</p>
			<p>This week's Ruby Quiz is to programmatically solve Magic Fingers.  Is it a win for the first or second player with perfect play, or can you always force a draw with repeating counts?  Have your program print some output that would convince anyone beyond the shadow of a doubt what the game's outcome will be.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Eric I. said it best when he said the real trick of this quiz is figuring out a way to convince someone of the outcome beyond the shadow of a doubt.  Eric's own code convinced me, after we clarified my mistakes in the rules.</p>
			<p>Eric's code outputs a table of your moves compared with the opponent's moves.  At each step, it tells you the move to make based on the following priorities:</p>
			<p class="example">1. It suggests a forced win if it can find one<br />2. It aims for draw if there is no forced win<br />3. As a last resort, it will stall a loss as long as possible to increase<br />   the chances of your opponent making an error</p>
			<p>The first one is really the point of interest for this quiz.  There's just not that many different hand positions in this game and a sufficiently deep search can find the wins.  Here's the chart Eric's code shows for the game:</p>
			<p class="example">       01   02   03   04   11   12   13   14   22   23   24   33   34   44<br />     ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----<br />01:  -1T1 -1T2 -1T3 +1T4 -1T1 -1T2 -1T1 +1T4 -1T2 -1T2 -1T4 -1T3 -1T4 -1T4<br />02:  +C11 -C11 +2T3 +2T4 +C11 -C11 +2T3 +2T4 -C11 +2T3 +2T4 -C11 -C11 -C11<br />03:  +C21 +3T2 +3T3 +3T4 -C21 +3T2 +3T3 +3T4 -C21 -C21 -C21 -C21 -C21 -C21<br />04:  +4T1 +4T2 +4T3 +4T4 +C31 +C22  C22 +C22  C22 +C22  C22 -C22 -C22 -C22<br />11:  +C02 +1T2 -1T3 +1T4 -1T1 +C02 -1T3 +1T4  C02 -1T2 -1T4 -1T3 +1T4 -1T4<br />12:  +C03 -2T2 +2T3 +2T4 +C03 +2T2 +2T3 +2T4 -1T2 +2T3 +2T4 -1T3 -2T3 -1T4<br />13:  +C22 +3T2 +3T3 +3T4 +3T1 +C22 +3T3 +1T4  C22 +C22  C22 -C22  3T3  1T4<br />14:  +4T1 +4T2 +4T3 +4T4 +C32 -C32 -C32 +C32 -C32 -4T3 -4T2 -1T3 -4T3 -1T4<br />22:  +C13  2T2 +2T3 +2T4 +C13 +2T2 +2T3 +2T4  2T2 +2T3 +2T4 +2T3 +2T4  2T4<br />23:  +2T1 +3T2 +3T3 +3T4 +3T1 +3T2 +3T3 +3T4 -3T2 +3T2 -3T2 +3T3 +3T4 -2T4<br />24:  +4T1 +4T2 +2T3 +2T4 +4T1 +4T2 +2T3 +2T4  2T2 +4T2  4T2 +4T3 +4T4  2T4<br />33:  +C24 +3T2 +3T3 +3T4 +3T1 +3T2 +3T3 +3T4 +3T2 +3T2 +3T4 +3T3 +3T4 +3T4<br />34:  +4T1 +4T2 +4T3 +4T4 +4T1 +4T2 +4T3 +4T4 +4T2 +4T3 +4T4 +4T3 +4T4 +4T4<br />44:  +4T1 +4T2 +4T3 +4T4 +4T1 +4T2 +4T3 +4T4 +4T2 +4T3 +4T4 +4T3 +4T4 +4T4</p>
			<p>Columns and rows are labeled in normalized hand positions, meaning that a left hand of one finger and a right hand of two fingers is the same as a left of two with a right of one.</p>
			<p>You find the row for your hands and cross reference it with the column of the opponent's hands.  The cell where the two meet lists your best move, be it a touch or a clap.  Don't worry too much about the format of those moves, but know this:  a plus indicates that you have a forced win and a minus indicates that you face a forced loss.</p>
			<p>Using that knowledge you can look up the starting position at row 11, column 11.  You will find a minus there telling you that your best move still leads to a forced loss.  That's correct.  The second player can always win a game of Magic Fingers.</p>
			<p>Now let's examine how the code reaches this conclusion.  First, let's look at the class used to represent the current game state:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> GameState<br />      attr_reader :hands<br /><br />      <span class="keyword">def</span> initialize(hands = [[1, 1], [1, 1]])<br />        <span class="variable">@hands</span> = hands<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> do_turn(move)<br />        new_hands, description1, description2 =<br />          *move.call(<span class="variable">@hands</span>[0].dup, <span class="variable">@hands</span>[1].dup)<br />        [GameState.new([new_hands[1], new_hands[0]]),<br />          description1,<br />          description2]<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_s<br />        result = <span class="string">""</span><br />        <span class="variable">@hands</span>.each_index <span class="keyword">do</span> |i|<br />          result &lt;&lt; <span class="string">"#{i+1}: "</span><br />          result &lt;&lt; <span class="string">'-'</span> * (5 - <span class="variable">@hands</span>[i][0])<br />          result &lt;&lt; <span class="string">'|'</span> * <span class="variable">@hands</span>[i][0]<br />          result &lt;&lt; <span class="string">' '</span><br />          result &lt;&lt; <span class="string">'|'</span> * <span class="variable">@hands</span>[i][1]<br />          result &lt;&lt; <span class="string">'-'</span> * (5 - <span class="variable">@hands</span>[i][1])<br />          result &lt;&lt; <span class="string">"\n"</span><br />        <span class="keyword">end</span><br />        result<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> game_over?<br />        <span class="variable">@hands</span>[0][0] == 0 &amp;&amp; <span class="variable">@hands</span>[0][1] == 0 ||<br />          <span class="variable">@hands</span>[1][0] == 0 &amp;&amp; <span class="variable">@hands</span>[1][1] == 0<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> score<br />        <span class="keyword">if</span> <span class="variable">@hands</span>[0][0] == 0 &amp;&amp; <span class="variable">@hands</span>[0][1] == 0 : -1<br />        <span class="keyword">elsif</span> <span class="variable">@hands</span>[1][0] == 0 &amp;&amp; <span class="variable">@hands</span>[1][1] == 0 : 1<br />        <span class="keyword">else</span> 0<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> eql?(other)<br />        <span class="variable">@hands</span> == other.hands<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> hash<br />        <span class="variable">@hands</span>[0][0] + 5 * <span class="variable">@hands</span>[0][1] + 25 * <span class="variable">@hands</span>[1][0] +<br />          125 * <span class="variable">@hands</span>[1][1]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Most of this class is very straightforward.  A GameState is created by providing the current values of the two hands.  You can then query the resulting object for a win, loss, or yet unknown score(), whether or not it is game_over?(), or a String representation of the hands.  The class also defines eql?() and hash() in terms of the hand counts so these objects can be used as keys in a Hash.</p>
			<p>The only semi-involved method is do_turn(), which takes a Proc that will perform a move and uses that to create the resulting GameState object.  You will see how this method is used when we get a little farther.</p>
			<p>Next we will look into generating possible moves:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    HandNames        = [<span class="string">"left hand"</span>, <span class="string">"right hand"</span>]<br />    AllowClapsToZero = <span class="keyword">false</span><br /><br />    <span class="keyword">def</span> generate_touches<br />      result = []<br />      (0..1).each <span class="keyword">do</span> |from_hand|<br />        (0..1).each <span class="keyword">do</span> |to_hand|<br />          result &lt;&lt; Proc.new <span class="keyword">do</span> |player_hands, opponent_hands|<br />            raise <span class="string">"cannot touch from empty hand"</span> <span class="keyword">if</span><br />              player_hands[from_hand] == 0<br />            raise <span class="string">"cannot touch to empty hand"</span> <span class="keyword">if</span><br />              opponent_hands[to_hand] == 0<br />            description1 =<br />              <span class="string">"touches #{HandNames[from_hand]} to opponent's "</span> +<br />              <span class="string">"#{HandNames[to_hand]}"</span><br />            description2 = <span class="string">"#{player_hands[from_hand]}T"</span> +<br />                           <span class="string">"#{opponent_hands[to_hand]}"</span><br />            opponent_hands[to_hand] += player_hands[from_hand]<br />            opponent_hands[to_hand] = 0 <span class="keyword">if</span> opponent_hands[to_hand] &gt;= 5<br />            [[player_hands, opponent_hands], description1, description2]<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      result<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> generate_claps<br />      result = []<br />      (0..1).each <span class="keyword">do</span> |from_hand|<br />        to_hand = 1 - from_hand<br />        (1..4).each <span class="keyword">do</span> |fingers|<br />          result &lt;&lt; Proc.new <span class="keyword">do</span> |player_hands, opponent_hands|<br />            raise <span class="string">"do not have enough fingers on "</span> +<br />                  <span class="string">"#{HandNames[from_hand]}"</span> <span class="keyword">unless</span><br />              player_hands[from_hand] &gt;= fingers<br />            raise <span class="string">"#{HandNames[to_hand]} would end up with five or more "</span> +<br />                  <span class="string">"fingers"</span> <span class="keyword">if</span><br />              !AllowClapsToZero &amp;&amp; player_hands[to_hand] + fingers &gt;= 5<br />            raise <span class="string">"cannot end up with same number combination after clap"</span> <span class="keyword">if</span><br />              player_hands[from_hand] - fingers == player_hands[to_hand]<br />            description1 = <span class="string">"claps to transfer #{fingers} fingers from "</span> +<br />              <span class="string">"#{HandNames[from_hand]} to #{HandNames[to_hand]}"</span><br />            player_hands[from_hand] -= fingers<br />            player_hands[to_hand] += fingers<br />            player_hands[to_hand] = 0 <span class="keyword">if</span> player_hands[to_hand] &gt;= 5<br />            description2 = <span class="string">"C#{player_hands[from_hand]}"</span>+<br />                           <span class="string">"#{player_hands[to_hand]}"</span><br />            [[player_hands, opponent_hands], description1, description2]<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      result<br />    <span class="keyword">end</span><br /><br />    Moves = generate_claps + generate_touches<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The main work here is in the two almost identical methods.  They work by filling an Array with Proc objects that generate touch and clap moves when passed a pair of hands.  These Procs return the new hands and descriptions of the move that are used in the chart we saw earlier.  They also include a good deal of error handling to prevent illegal moves, as you can see.  Finally the Moves constant is populated with the results of a call to each.</p>
			<p>This next method is the work horse of this solution.  This is a recursive depth first search of the available moves.  It limits the recursion, to keep things like draws from creating infinite loops, and memoizes GameState objects to keep from redoing work.  Let's take it in slices:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    Levels = 25<br />    Memo   = Hash.new<br /><br />    <span class="keyword">def</span> pick_move(state, levels = Levels)<br />      <span class="keyword">return</span> [state.score, <span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="keyword">nil</span>] <span class="keyword">if</span> levels &lt;= 0 || state.game_over?<br /><br />      memoed_move = Memo[state]<br />      <span class="keyword">if</span> memoed_move &amp;&amp; memoed_move[0] &gt;= levels<br />        <span class="comment"># use memoed values if levels used meets or exceeds my levels</span><br />        best_move = memoed_move[1]<br />        best_score = memoed_move[2]<br />      <span class="keyword">else</span><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>Right off the bat, we see the code that controls when recursion stops.  As soon as the recursion limit is reached or a game is over, the code tosses a final score back up the stack.</p>
			<p>When that's not the case, the method moves into search mode.  The first step is to check for a memoized answer that would short circuit the need to search at all.  When we don't have that for the current position though, it's time to recurse:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># otherwise, calculate values recursively</span><br />        best_score = <span class="keyword">nil</span><br />        best_move = <span class="keyword">nil</span><br /><br />        <span class="comment"># try each of the possible moves on this state and generate an</span><br />        <span class="comment"># array of the results of those choices</span><br />        move_choices = Moves.map <span class="keyword">do</span> |move|<br />          <span class="keyword">begin</span><br />            <span class="comment"># determine the new state if the chosen move is applied</span><br />            new_state, description1, description2 = *state.do_turn(move)<br /><br />            <span class="comment"># recursively determine the score for this move (i.e., this</span><br />            <span class="comment"># state); negate the score returned since it's in terms of</span><br />            <span class="comment"># opponent (i.e., a win for them is a loss for us)</span><br />            score = -pick_move(new_state, levels - 1)[0]<br /><br />            <span class="comment"># increment score (by shifting away from zero) in order to be</span><br />            <span class="comment"># able to treat is as a count of the number of moves to a win</span><br />            <span class="comment"># or a loss</span><br />            score += score / score.abs <span class="keyword">unless</span> score.zero?<br /><br />            [score, move, description1, description2]<br />          <span class="keyword">rescue</span> Exception =&gt; e<br />            <span class="keyword">nil</span>  <span class="comment"># the move was ilegal</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we see the Array of Proc move generators and the do_turn() method of GameState come together.  Each Proc is passed in one-at-a-time to generate the resulting GameState.  Remember that those Procs toss Exceptions whenever an illegal move is found and this code uses a rescue clause to skip over such moves.  The new state is then recursed into by pick_move() to fetch a resulting score.  That score will be from the opponent's point of view, so it has to be negated to count for our point of view.</p>
			<p>When we have the moves, it's time to hunt for winners:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># remove nils that were generated by illegal moves</span><br />        move_choices = move_choices.select { |option| option }<br /><br />        <span class="comment"># select and sort only those with positive (i.e., winning scores)</span><br />        winning_choices = move_choices.<br />          select { |option| option[0] &gt; 0 }.<br />          sort_by { |option| option[0] }<br /><br />        <span class="keyword">unless</span> winning_choices.empty?<br />          <span class="comment"># if there's a winning option, choose the one that leads to a</span><br />          <span class="comment"># with the least number of moves</span><br />          selected = winning_choices.first<br />        <span class="keyword">else</span><br />          <span class="comment"># otherwise, choose a move that leads to a tie (preferable) or a</span><br />          <span class="comment"># loss but in the greatest number of moves (to increase</span><br />          <span class="comment"># opponent's opportunities to make a mistake)</span><br />          move_choices = move_choices.sort_by { |option| option[0] }<br />          <span class="keyword">if</span> move_choices.last[0] == 0<br />            selected = move_choices.last<br />          <span class="keyword">else</span><br />            selected = move_choices.first<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        best_score = selected[0]<br />        best_move = selected[1..3]<br /><br />        <span class="comment"># store the best move determined for future use</span><br />        Memo[state] = [levels, best_move, best_score]<br />      <span class="keyword">end</span><br /><br />      [best_score] + best_move<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The first line is just a long-hand way to write move_choices.compact! and the second line filters the legal moves down to winning moves.  If we have winning moves, the quickest kill is selected.  Otherwise, the code checks draws and losses as I described earlier.  At this point we finally know a best move and score.  Those are memoized for future calls and passed back up the stack to the calling code.</p>
			<p>The next step is to put this method to work by handing it all possible hand combinations:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># Returns a string indicating win or loss depending on score.</span><br />    <span class="keyword">def</span> score_symbol(score)<br />      <span class="keyword">if</span> score &gt; 0 : <span class="string">'+'</span><br />      <span class="keyword">elsif</span> score &lt; 0 : <span class="string">'-'</span><br />      <span class="keyword">else</span> <span class="string">' '</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /><br />    <span class="comment"># Calculate the best move given every finger combination, and store in</span><br />    <span class="comment"># the results hash.</span><br />    results = Hash.new<br />    1.upto(4) <span class="keyword">do</span> |left1|<br />      0.upto(left1) <span class="keyword">do</span> |right1|<br />        key1 = <span class="string">"#{right1}#{left1}"</span><br />        results[key1] = Hash.new<br />        1.upto(4) <span class="keyword">do</span> |left2|<br />          0.upto(left2) <span class="keyword">do</span> |right2|<br />            state = GameState.new([[left1, right1], [left2, right2]])<br />            score, move, description1, description2 = *pick_move(state, 40)<br />            key2 = <span class="string">"#{right2}#{left2}"</span><br />            results[key1][key2] = score_symbol(score) + description2<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is just a brute force generation of positions, their scores, and the best moves to make in them.  Everything shown in Eric's output is built here using the tools we have been examining.</p>
			<p>Speaking of that chart, drawing that is our last bit of code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># display instructions</span><br />    puts &lt;&lt;EOS<br />    INSTRUCTIONS<br /><br />    If it<span class="string">'s your turn, select the row that describes your two hands.  Then<br />    select the column that describes your opponent'</span>s two hands.  The cell<br />    at the intersection will tell you how to move <span class="keyword">and</span> what to expect.<br /><br />    A leading <span class="string">"+"</span> indicates there is a guaranteed way to win.  A leading<br />    <span class="string">"-"</span> tells you that <span class="keyword">if</span> the opponent plays perfectly, you will lose.  If<br />    neither of those symbols is present, <span class="keyword">then</span> <span class="keyword">if</span> you <span class="keyword">and</span> your opponent<br />    play well, neither of you will ever win.<br /><br />    The rest of the cell tells you what type of move to make.  A <span class="string">"T"</span><br />    represents a touching move, telling you which finger of yours first to<br />    user first, <span class="keyword">and</span> which finger of the opponent to touch.  A <span class="string">"C"</span><br />    represents a clapping move, <span class="keyword">and</span> it tells you the finger counts should<br />    <span class="keyword">end</span> up with after the clap.<br /><br />    EOS<br /><br /><br />    <span class="comment"># display move strategy table</span><br />    line1 = <span class="string">"    "</span> + results.keys.sort.map { |key1| <span class="string">"   #{key1}"</span> }.join<br />    puts line1<br />    puts line1.gsub(<span class="string">/\ \ \d\d/</span>, <span class="string">'----'</span>)<br />    results.keys.sort.each <span class="keyword">do</span> |key1|<br />      print <span class="string">"#{key1}: "</span>,<br />        results[key1].keys.sort.<br />                           map { |key2| <span class="string">" #{results[key1] [key2]}"</span> }.join,<br />        <span class="string">"\n"</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This code is just boring print calls to display the chart.  There shouldn't be anything surprising here.</p>
			<p>My thanks to the few brave souls that toughed out my surprisingly challenging problem.  I didn't realize it would be so much work, but you guys made it look easy enough, as usual.</p>
			<p>Tomorrow we have a super easy code breaking problem so I want to see all you beginners playing!</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/248005">Eric I.</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/248037">Jesse Merriman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/248047">Eric I. (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/248139">Matt Hulse</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/248253">Wolfgang Seeberg</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/248385">Jesse Merriman (2)</a></li>
			</ol>
			<p><a href="quiz120_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
