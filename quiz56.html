<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Pinewood Derby Chart (#56)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Pinewood Derby Chart (#56)</span>
			<p>by Bob Showalter</p>
			<p>I was a Cub Scout leader for five years and one of our favorite activities was the annual Pinewood Derby. For you non-Scouts, this is a competition between small gravity-powered cars made by the boys using standard kits containing a wood block, plastic wheels, and nails for axles. The cars compete against each other down a sloping, multi-lane track (2-6 lanes is typical) about 30 feet long.</p>
			<p>Some Cub Scout packs use a "ladder" elimination system for their derby, but this isn't much fun for the boys that are eliminated early. Much more enjoyable is a "round-robin" approach that lets each boy's car run in the same number of heats, racing against different opponents each time.</p>
			<p>You can find links to more Pinewood Derby information at:</p>
			<p><a href="http://members.aol.com/StanDCmr/pwportal.html">Pope's Pinewood Pages Portal</a></p>
			<p>This week's task is to create a Ruby program to generate a chart for a Pinewood derby. In order to make the event fair, each car should be scheduled into each lane of the track the same number of times (to compensate for any lane differences due to track imperfections.) We'll use the term "round" to refer to each car running once in each lane. The input to your program will be:</p>
			<p class="example">Number of cars<br />Number of lanes<br />Number of rounds</p>
			<p>For example, let's assume we have 25 cars and a 4-lane track. If we want each car to run twice in each lane (2 "rounds"), that means:</p>
			<p class="example">Number of rounds: 2<br />Number of runs per car: 2 rounds x 4 lanes = 8<br />Total number of runs: 8 runs/car x 25 cars = 200<br />Total number of heats: 200 / 4 lanes = 50 heats</p>
			<p>So we have to come up with a chart that assigns the cars to lanes and heats. If we number the lanes from 1 to 4 and the cars from 1-25, our chart might look something like this:</p>
			<p class="example">Heat   Lane 1   Lane 2   Lane 3   Lane 4<br />----   ------   ------   ------   ------<br />  1:      9        2       13       10<br />  2:     12        8        5       21<br />  3:     16       19        6        4<br />  ...and so on</p>
			<p>The trick is to create a chart that is as fair as possible. A "perfect" chart would be one in which:</p>
			<p class="example">1) Each car runs in the same number of heats<br />2) Each car runs in each lane an equal number of times<br />3) Each car runs against every other opponent an equal number of times<br />4) The heats a car is assigned to are evenly spread throughout the event. (In<br />   other words, a boy shouldn't run in the first 8 heats and then have to sit<br />   out for the rest of the event.)</p>
			<p>In practice, you cannot create a perfect chart for all combinations of inputs. For instance, if we ran just one round with our 25 cars, each car would run in 4 heats and face 12 opponents (3 opponents per heat). Since there are 24 opponents, it isn't possible to face all the opponents equally. But you would want to try to maximize the number of opponents faced, rather than having two cars face each other several times.</p>
			<p>You may want to create a function to evaluate your chart against the criteria above, so you can rank charts as to their "quality".</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>by Bob Showalter</p>
			<p>[Ediitor's Note:  I hope everyone noticed that Bob just ran, solved, and summarized a Ruby Quiz solo.  Take it from me, a guy with a little experience doing that very, not-so-fun thing, we all owe Bob a HUGE thank you!  --JEG2]</p>
			<p>This week's quiz failed to attract any submissions other than the rather weak ChaoticChart generator that I posted. (This code was actually adapted from a Perl version I created a couple of years ago.)</p>
			<p>The problem with scheduling a derby is balancing fun with fairness. The factors to consider are:</p>
			<p class="example">* All the boys should be participating throughout the event (fun)<br />* Each boy should race the same number of times (fair)<br />* All lanes of the track should be used evenly (fair)<br />* Cars should race against the other cars as evenly as possible (fair)</p>
			<p>Our challenge was to construct a chart given a track with a fixed number of lanes and a number of cars to participate. The event would consist of a number of "heats" in which a car was assigned to each lane. The total number of heats would be determined from the number of times each car would run in each lane.</p>
			<p>My solution starts with a simple Chart class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Pinewood Derby chart</span><br />    <span class="keyword">class</span> Chart<br /><br />      attr_reader :lanes, :cars, :rounds, :chart<br /><br />      <span class="comment"># create a new empty chart with given lanes, cars, and rounds.</span><br />      <span class="keyword">def</span> initialize(lanes, cars, rounds)<br />        raise <span class="string">"Need at least #{lanes} cars"</span> <span class="keyword">unless</span> cars &gt;= lanes<br />        raise <span class="string">"Need at least 1 round"</span> <span class="keyword">unless</span> rounds &gt;= 1<br />        <span class="variable">@lanes</span> = lanes<br />        <span class="variable">@cars</span> = cars<br />        <span class="variable">@rounds</span> = rounds<br />        <span class="variable">@chart</span> = []<br />      <span class="keyword">end</span><br /><br /></div></div>
			<p>Here we just take the three factors that control the chart's size (lanes, cars, and rounds) and put them into member variables (after doing some rudimentary sanity checking). A read-only accessor is created for each member.</p>
			<p>The @chart member variable is initialized to an empty array. This will eventually receive the heats as they are assigned.</p>
			<p>We need a way to print out a chart:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># prints the chart</span><br />    <span class="keyword">def</span> print_chart(io = <span class="global">$stdout</span>)<br />      io.puts <span class="string">"Chart:"</span><br />      h = 0<br />      chart.each <span class="keyword">do</span> |heat|<br />        io.printf <span class="string">"%4d: "</span>, h<br />        heat.each <span class="keyword">do</span> |car|<br />          io.printf <span class="string">"%4d"</span>, car<br />        <span class="keyword">end</span><br />        io.puts<br />        h += 1<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This method just loops through the heats in the @chart member and prints them onto the supplied object (which defaults to standard output, but could be a File object or a StringIO object, or any object that acts like an IO object).</p>
			<p>One simple way to assign cars to heats is through a "round robin" approach. Let's create a class that can generate such a chart. We'll do that by subclassing the Chart class and adding a generate method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> RoundRobinChart &lt; Chart<br /><br />      <span class="comment"># generate chart via simple round-robin assignment</span><br />      <span class="keyword">def</span> generate<br />        chart.clear<br />        car = 0<br />        (cars * rounds).times <span class="keyword">do</span> |heat|<br />          h = []<br />          lanes.times <span class="keyword">do</span><br />            h &lt;&lt; car<br />            car = (car + 1) % cars<br />          <span class="keyword">end</span><br />          chart &lt;&lt; h<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The algorithm here is extremely simple. The first four cars are assigned to the first heat. The second heat is assigned starting with the fifth, sixth, etc. cars, and so on. When we run out of cars, we start reassigning with the first car again.</p>
			<p>Here's the output from generating a round robin chart for 1 round of 5 cars on 4 lanes (heats and cars are numbered from zero):</p>
			<p class="example">Chart:<br />   0:    0   1   2   3<br />   1:    4   0   1   2<br />   2:    3   4   0   1<br />   3:    2   3   4   0<br />   4:    1   2   3   4</p>
			<p>This is actually a perfect chart. Each car runs in four heats, and runs in each lane exactly once. Each car faces all the other cars exactly three times. Also, the assignments are evenly distributed through the event; there is never more than a single heat gap between any two runs of a given car.</p>
			<p>However, the round robin algorithm breaks down when you begin to consider different combinations of inputs. For example, here's the output for 6 cars on 4 lanes for 1 round:</p>
			<p class="example">Chart:<br />   0:    0   1   2   3<br />   1:    4   5   0   1<br />   2:    2   3   4   5<br />   3:    0   1   2   3<br />   4:    4   5   0   1<br />   5:    2   3   4   5</p>
			<p>If you'll notice, car 0 runs twice in the first and third lanes, but not at all in the second and fourth lanes. Further more, cars 0 and 1 run against each other a total of four times, while most of the other cars only meet each other twice.</p>
			<p>If you checked any of the resources under "Pope's Pinewood Pages Portal", you may have come across the "Perfect-N" method. This is a variation on the naive round robin approach above that can achieve a "perfect" chart in terms of lane assignments and opponent matchups. Unfortunately, the Perfect-N method does not work for all combinations of inputs.</p>
			<p>Let's consider another way of generating a chart. I'll call this a "chaotic" method, because we're going to assign cars to heats at random, while trying to maximize our fairness and fun criteria as we go.</p>
			<p>Taking our 6 cars/4 lanes example from above, we could assign the first heat by just choosing four cars at random. For example:</p>
			<p class="example">   0:    3   1   5   0</p>
			<p>Now, let's start assigning cars to the second heat. Our objective is to run each car in each lane one time (one round), so car 3 is not a candidate for the first lane. Of the remaining cars, 1, 5, and 0 have run recently, while 2 and 4 have not, so we should prefer 2 or 4 over the others. Between 2 and 4, does it matter? No, so let's choose one at random:</p>
			<p class="example">   0:    3   1   5   0<br />   1:    2</p>
			<p>Now, for assigning to the second lane, car 2 is obviously out (since a car can't run in two lanes in the same heat). Of the five remaining cars, all have run recently except for 4, so let's choose him:</p>
			<p class="example">   0:    3   1   5   0<br />   1:    2   4</p>
			<p>The candidates for the third lane are 0, 1, and 3 (2 and 4 are already in this heat, and 5 has already run in this lane). Let's choose one at random:</p>
			<p class="example">   0:    3   1   5   0<br />   1:    2   4   0</p>
			<p>The last lane can take 1 or 3. Again, we can just choose at random:</p>
			<p class="example">   0:    3   1   5   0<br />   1:    2   4   0   3</p>
			<p>As we increase the number of cars, the matchups between cars will be an increasingly important factor. Given a number of cars to choose from for the last lane, we would want to favor those with fewer assignments against the opponents already slotted to the current heat.</p>
			<p>So the algorithm is:</p>
			<p class="example">* rule out any cars already scheduled in this heat<br />* rule out any cars that have already run the maximum number of times in<br />  this lane<br />* favor cars with fewer matchups against these opponents<br />* favor cars that have not been scheduled recently</p>
			<p>Here's a ChaoticChart class that implements this logic:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> ChaoticChart &lt; Chart<br /><br />      <span class="comment"># coefficients for weighting formula for lane assignment.</span><br />      <span class="comment"># these were derived by experimentation.</span><br />      FL = 3.0<br />      FP = 1.0<br />      FD = 3.0<br /><br />      <span class="comment"># generates the chart by assigning cars to heats</span><br />      <span class="keyword">def</span> generate<br /><br />        <span class="keyword">begin</span><br />          <span class="comment"># assigned heats by car, last heat by car</span><br />          ah = Array.new(cars) { 0 }<br />          lh = Array.new(cars)<br /><br />          <span class="comment"># assignments by car/lane</span><br />          al = Array.new(cars) { Array.new(lanes) { 0 } }<br /><br />          <span class="comment"># matchups by car pair</span><br />          op = Matchups.new<br /><br />          <span class="comment"># schedule by heat by lane</span><br />          chart.clear<br /><br />          <span class="comment"># generate each heat</span><br />          (cars * rounds).times <span class="keyword">do</span> |heat|<br /><br />            <span class="comment"># current car assignments by lane</span><br />            h = []<br /><br />            <span class="comment"># slot each lane</span><br />            lanes.times <span class="keyword">do</span> |lane|<br /><br />              <span class="comment"># computed weights for each car</span><br />              w = {}<br /><br />              <span class="comment"># assign weights to each car for this slot</span><br />              cars.times <span class="keyword">do</span> |car|<br /><br />                <span class="comment"># skip car if it's already been slotted to this heat</span><br />                <span class="keyword">next</span> <span class="keyword">if</span> h.include? car<br /><br />                <span class="comment"># skip car if it's already run max heats in this lane</span><br />                <span class="keyword">next</span> <span class="keyword">if</span> al[car][lane] &gt;= <span class="variable">@rounds</span><br /><br />                <span class="comment"># weight factor 1: no. of times slotted to this lane</span><br />                f1 = FL * al[car][lane]<br /><br />                <span class="comment"># weight factor 2: no. of times against these opponents</span><br />                f2 = FP * h.inject(0) <span class="keyword">do</span> |f, opp|<br />                  f + op[car, opp]<br />                <span class="keyword">end</span><br /><br />                <span class="comment"># weight factor 3: no. of heats since last scheduled</span><br />                <span class="comment"># (distribute cars through the heats)</span><br />                f3 = 0<br />                <span class="keyword">if</span> lh[car]<br />                  f3 = FD * (cars <span class="string">/ lanes) /</span> (heat - lh[car])<br />                <span class="keyword">end</span><br /><br />                <span class="comment"># total weight for this car</span><br />                w[car] = f1 + f2 + f3<br /><br />              <span class="keyword">end</span><br /><br />              raise NoCarsException <span class="keyword">if</span> w.empty?<br /><br />              <span class="comment"># sort by weight and get the lowest weight(s)</span><br />              w = w.sort_by { |k, v| v }<br />              w.pop <span class="keyword">while</span> w[-1][1] &gt; w[0][1]<br /><br />              <span class="comment"># randomly choose a car and slot it</span><br />              car = w[rand(w.size)][0]<br /><br />              <span class="comment"># accumulate statistics</span><br />              ah[car] += 1<br />              lh[car] = heat<br />              al[car][lane] += 1<br />              h.each <span class="keyword">do</span> |opp|<br />                op[car, opp] += 1<br />              <span class="keyword">end</span><br /><br />              <span class="comment"># slot car to current heat</span><br />              h &lt;&lt; car<br /><br />            <span class="keyword">end</span><br /><br />            <span class="comment"># add current heat to chart</span><br />            chart &lt;&lt; h<br /><br />          <span class="keyword">end</span><br /><br />        <span class="keyword">rescue</span> NoCarsException<br />          <span class="keyword">retry</span><br /><br />        <span class="keyword">end</span><br /><br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The generate method tracks several things as it works:</p>
			<p class="example">* The number of heats each car has been assigned to<br />* The last heat each car was assigned to<br />* The number of times each car has been assigned to each lane<br />* The number of times each car has been matched against every other car</p>
			<p>The algorithm steps through each heat and "slots" a car to each lane. For each slot, it first eliminates any cars that have run their maximum times in the current lane or that have already been scheduled to the current heat.</p>
			<p>For the remaining cars, a "weight" factor is computed that considers the factors mentioned above. The "weight" value for each car acts as a bias against selecting that car; i.e. the car(s) with the lowest weights will be considered for slotting. If multiple cars have the lowest weight, a random choice is made from among them.</p>
			<p>Daniel Sheppard provided some code to analyze a generated chart to see how fair it is. My second submission contains some analysis routines as well. Perhaps someone will take these starting points and come up with a technique for creating optimal charts for any combinations of inputs.</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/167863">Bob Showalter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168079">Daniel Sheppard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168096">Bob Showalter (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168169">Kenneth Collins</a></li>
			</ol>
			<p><a href="quiz56_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
