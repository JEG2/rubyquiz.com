<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - 1-800-THE-QUIZ (#20)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">1-800-THE-QUIZ (#20)</span>
			<p>Many companies like to list their phone numbers using the letters printed on most telephones.  This makes the number easier to remember for customers.  A famous example being 1-800-PICK-UPS.</p>
			<p>This week's quiz is to write a program that will show a user possible matches for a list of provided phone numbers.</p>
			<p>Your script should behave as a standard Unix filter, reading from files specified as command-line arguments or STDIN when no files are given.  Each line of these files will contain a single phone number.</p>
			<p>For each phone number read, your filter should output all possible word replacements from a dictionary.  Your script should try to replace every digit of the provided phone number with a letter from a dictionary word; however, if no match can be made, a single digit can be left as is at that point.  No two consecutive digits can remain unchanged and the program should skip over a number (producing no output) if a match cannot be made.</p>
			<p>Your script should allow the user to set a dictionary with the -d command-line option, but it's fine to use a reasonable default for your system.  The dictionary is expected to have one word per line.</p>
			<p>All punctuation and whitespace should be ignored in both phone numbers and the dictionary file.  The program should not be case sensative, letting "a" == "A".  Output should be capital letters and digits separated at word boundaries with a single dash (-), one possible word encoding per line.  For example, if your program is fed the number:</p>
			<p class="example">873.7829</p>
			<p>One possible line of output is</p>
			<p class="example">USE-RUBY</p>
			<p>According to my dictionary.</p>
			<p>The number encoding on my phone is:</p>
			<p class="example">2 = A B C<br />3 = D E F<br />4 = G H I<br />5 = J K L<br />6 = M N O<br />7 = P Q R S<br />8 = T U V<br />9 = W X Y Z</p>
			<p>Feel free to use that, or the encoding on your own phone.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Here's an interesting quote from Brian Schroeder's solution page:</p>
			<p class="example">To make it more difficult JEGII introduced the possibility to skip letters,<br />but in my opinion this leads to bad results (Though it made me think, so it<br />was a good idea).</p>
			<p>I'm not sure exactly what qualifies as "bad results," but here's a thought I had while reading this:</p>
			<p class="example">CAR-4-YOU</p>
			<p>That's not the reason I added it though.  As usual, the real truth is far less interesting.  It was pointed out to me, by Tobias Peters, that this problem originated as a means to compare various programming languages.  I examined the original description of the problem, forwarded to me by Tobias, and tried to stay close to the original challenge.  Allowing single numbers comes from there.</p>
			<p>One last interesting quote from Brian's page:</p>
			<p class="example">-e, --encoding ENCODING<br />How the alphabet is encoded to phonenumbers. james or logic are supported.</p>
			<p>Does this suggest that "james" and "logic" are opposites?  Food for thought...</p>
			<p>On to the solutions.</p>
			<p>I'll show Brian's solution below, because I ran into some minor issues with the other two.  However, do take a look at Jannis Harder's WEBrick servlet.  It's very little work to offer this service to the whole world through a Web interface and that program shows it off nicely.  Lee Marlow's solution was also short and very straight forward, though the running time was a little high.</p>
			<p>Let's inspect Brian's code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Nodes in the Dictionary.</span><br />    <span class="keyword">class</span> DictionaryNode &lt; Array<br />      <span class="comment"># Terminal info</span><br />      attr_reader :words<br /><br />      <span class="keyword">def</span> initialize<br />        <span class="keyword">super</span>(10)<br />        <span class="variable">@words</span> = []<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This first piece of the puzzle is a node to be used by a tree class we'll meet shortly.  DictionaryNode is an Array that contains exactly 10 members.  Why 10?  Because that's how many digits our encoding has.  DictionaryNode also contains an Array of words, that will be filled from the dictionary file.</p>
			<p>Here's the start of Brian's tree class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># A tree-indexed version of the dictionary that allows</span><br />    <span class="comment"># efficent searching by number 2 alphabet mapping.</span><br />    <span class="keyword">class</span> Dictionary<br />      <span class="keyword">def</span> initialize(encoding)<br />        <span class="keyword">super</span>()<br />        <span class="variable">@encoding</span> = {}<br />        <span class="variable">@inverse_encoding</span> = {}<br /><br />        encoding.each <span class="keyword">do</span> | k, v |<br />          <span class="variable">@encoding</span>[k] = v.split(<span class="string">/\s+/</span>).map{|c| c[0]}<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Create map from characters to numbers</span><br />        <span class="variable">@inverse_encoding</span> = <span class="variable">@encoding</span>.inject({}) { | r, (k, v) |<br />          v.each <span class="keyword">do</span> | l | r[l] = k <span class="keyword">end</span><br />          r<br />        }<br />        <span class="variable">@root</span> = DictionaryNode.new<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>That's pretty easy to follow.  This setup work creates maps for the encoding of this Dictionary object.  The maps go both ways, numbers to letters and the inverse letters to numbers.  Finally, the root of the tree is created from a new DictionaryNode.</p>
			<p>The following methods add words to the tree from a dictionary file:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># Helper method for rekursive adding of words to the dictionary</span><br />      private<br />      <span class="keyword">def</span> add_recursive(node, word, position)<br />        <span class="keyword">if</span> word.length == position<br />          node.words &lt;&lt; word<br />          <span class="keyword">return</span> node<br />        <span class="keyword">end</span><br />        add_recursive(<br />          node[<span class="variable">@inverse_encoding</span>[word[position]]] ||= DictionaryNode.new,<br />          word,<br />          position + 1 )<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Add words to the dictionary</span><br />      public<br />      <span class="keyword">def</span> add(word)<br />        add_recursive(<span class="variable">@root</span>, word, 0)<br />        <span class="keyword">self</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Load a wordlist from a file, which contains one word per line.</span><br />      <span class="comment"># Ignores punctuation and whitespace.</span><br />      <span class="keyword">def</span> load_wordlist(file, options)<br />        <span class="global">$stderr</span>.print <span class="string">"Loading dictionary... "</span> <span class="keyword">if</span> options.verbose<br />        start = Time.new<br />        file.read.gsub(<span class="string">/[^A-Za-z\n]/</span>, <span class="string">''</span>).upcase!.split(<span class="global">$/</span>).uniq!.each <span class="keyword">do</span> |w|<br />          w.chomp!<br />          <span class="keyword">next</span> <span class="keyword">if</span> w.empty? <span class="keyword">or</span> w.length &lt;= options.min_length<br />          <span class="keyword">self</span>.add(w)<br />        <span class="keyword">end</span><br />        <span class="keyword">if</span> options.verbose<br />          <span class="global">$stderr</span>.puts <span class="string">"built dictionary in %f seconds"</span> %<br />            (Time.new-start).to_f<br />        <span class="keyword">end</span><br />        <span class="keyword">self</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The dictionary reading process starts in the last method, load_wordlist().  This method slurps the file, discards illegal characters, normalizes case, breaks up the list on line boundaries, and eliminates repetition all on the third line.  Each member of the list of words that creates is then sent on to the add() method.  Note the nice use of options.verbose to show a build time.</p>
			<p>Before I move on to add(), let me point out that the above method does have a few minor issues.  When I was playing with this code to figure out how it works, I fed it a five word dictionary and was surprised when it crashed.  The cause?  No duplicates.  That causes uniq!() to return nil (a hot topic on Ruby Talk lately) and since nil doesn't support an each() call, the code blew up.  upcase!() has similar problems.</p>
			<p>One more minor issue.  Here's a tip:  When you normalize case, it's generally better to go down than up.  The reason is international support.  Some languages distinguish between things like uppercase and titlecase.  That means that a bunch of uppercase conversions might not be consistent, based on certain local settings.  The best way to avoid such problems is to lowercase content instead.  This isn't much of a problem, but it's a good habit to build.</p>
			<p>Back to the code.  add(), as you can see, is just a shell over add_recursive().  It passes the word on with the root node and a starting position of 0.</p>
			<p>add_recursive() is pretty clever.  It digs down into the tree until finding the right spot to place the word in the Dictionary.  This digging happens at the end of the method with recursive calls.  The current letter in the word is examined and a branch of the tree is created to handle that encoded letter, if it didn't already exist.  The algorithm then moves to that node, examining the next letter in line.  When all the letters have been branched off, we're at the right place to insert the word.  The if at the beginning of the method handles that end condition.</p>
			<p>The last thing a Dictionary object requires is a way to hunt for words.  Here are those methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      private<br />      <span class="comment"># Search words and return (in the block) words and the unmatched rest</span><br />      <span class="comment"># of the number</span><br />      <span class="keyword">def</span> sub_find(node, number, &amp;block)<br />        <span class="comment"># Return words found so far</span><br />        block[node.words.map{|w|w.dup}, number] <span class="keyword">unless</span> node.words.empty?<br />        <span class="comment"># No more digits, so stop searching here</span><br />        <span class="keyword">return</span> node <span class="keyword">if</span> number.empty?<br />        <span class="comment"># Search for longer words</span><br />        sub_find(node[number[0]], number[1..-1], &amp;block) <span class="keyword">if</span> node[number[0]]<br />      <span class="keyword">end</span><br /><br />      private<br />      <span class="comment"># Calculate all allowed skip patterns for a number of a given length</span><br />      <span class="keyword">def</span> skips(s, length)<br />        <span class="keyword">return</span> [s] <span class="keyword">if</span> length == 0<br />        result = skips(s + [<span class="keyword">false</span>], length-1)<br />        result.concat(skips(s + [<span class="keyword">true</span>], length-1)) <span class="keyword">unless</span> s[-1]<br />        result<br />      <span class="keyword">end</span><br /><br />      public<br /><br />      <span class="keyword">def</span> find_noskip(number)<br />        result = []<br />        sub_find(<span class="variable">@root</span>, number) <span class="keyword">do</span> | words, rest_number |<br />          <span class="keyword">if</span> rest_number.empty?<br />            result.concat(words)<br />          <span class="keyword">else</span><br />            find_noskip(rest_number).each <span class="keyword">do</span> | sentence |<br />              words.each <span class="keyword">do</span> | w |<br />                result &lt;&lt; w + <span class="string">'-'</span> + sentence<br />              <span class="keyword">end</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        result<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Skipping makes this a bit ugly</span><br />      <span class="keyword">def</span> find(number)<br />        result = []<br />        skips([], number.length).each <span class="keyword">do</span> | skipped |<br /><br />          <span class="comment"># Create the injector that can inject the skipped numbers</span><br />          <span class="comment"># back into the word</span><br />          injector = []<br />          skipped.zip(number).each_with_index <span class="keyword">do</span> |(s,n), i|<br />            injector &lt;&lt; [n.to_s, i] <span class="keyword">if</span> s<br />          <span class="keyword">end</span><br /><br />          <span class="comment"># We search for words built from the unskipped digits</span><br />          unskipped_digits =<br />            number.zip(skipped).select{|(d, s)| !s}.map{|(d,s)|d}<br />          sentences = find_noskip(unskipped_digits)<br />          <span class="comment"># Inject the skipped digits back into the found sentences</span><br />          sentences.each <span class="keyword">do</span> | s |<br />            injector.each <span class="keyword">do</span> | (n, i) | s.insert(i, n) <span class="keyword">end</span><br />          <span class="keyword">end</span><br /><br />          result.concat(sentences)<br />        <span class="keyword">end</span><br />        result<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Start with the sub_find() method.  It's the key to the search and easy enough to digest.  sub_find() takes a node to search, the number to use in that search, and a block to pass results to.  The first line passes all matching words from this node to the block, if there are any.  The root node, where the algorithm begins, won't have any since most dictionaries don't include 0 length words.  The second line finishes the process, if we've examined all the numbers.  The third line recurses, moving to the node for the next digit at the head of the number variable.  That's half of the picture.</p>
			<p>The find_noskip() method is the public face for that.  It calls sub_find(), passing a block of code that fills the local results Array as matches are found.  When a word matches in the number, find_noskip() recurses looking other words to finish off the number.  Of course, as the name implies, this version of the process does not skip digits.</p>
			<p>For skipping, you need the find() method.  find() first calls skip() to calculate all possible skip patterns for this number.  Then, one skip at a time, find() removes the skipped digits and calls find_noskip() on the remainder.  After results are generated, the skips are reinserted back into their original locations.  That's pretty tricky.</p>
			<p>To be clear, this does not function as I intended the quiz to work (and I now understand why Brian thinks I allowed "bad results").  Numbers were only to be allowed at word boundaries, while Brian's algorithm will reinsert them into the middle of words.  Looking back, I did not make this very clear in the quiz and it's certainly my error.  Brian's code is still a very nice implementation of his interpretation of the rules.</p>
			<p>Finally, there's an interface that puts all that code to use.  Let's look at that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    encodings = {<br />      :james =&gt; {<br />        2 =&gt; <span class="string">'A B C'</span>,<br />        3 =&gt; <span class="string">'D E F'</span>,<br />        4 =&gt; <span class="string">'G H I'</span>,<br />        5 =&gt; <span class="string">'J K L'</span>,<br />        6 =&gt; <span class="string">'M N O'</span>,<br />        7 =&gt; <span class="string">'P Q R S'</span>,<br />        8 =&gt; <span class="string">'T U V'</span>,<br />        9 =&gt; <span class="string">'W X Y Z'</span>},<br /><br />      :logic =&gt; {<br />        0 =&gt; <span class="string">'A B'</span>,<br />        1 =&gt; <span class="string">'C D'</span>,<br />        2 =&gt; <span class="string">'E F'</span>,<br />        3 =&gt; <span class="string">'G H'</span>,<br />        4 =&gt; <span class="string">'I J K'</span>,<br />        5 =&gt; <span class="string">'L M N'</span>,<br />        6 =&gt; <span class="string">'O P Q'</span>,<br />        7 =&gt; <span class="string">'R S T'</span>,<br />        8 =&gt; <span class="string">'U V W'</span>,<br />        9 =&gt; <span class="string">'X Y Z'</span><br />      }<br />    }<br /><br />    require <span class="string">'optparse'</span><br /><br />    <span class="keyword">class</span> PhonewordOptions &lt; OptionParser<br />      attr_reader :dictionary, :encoding, :format, :allow_skips, :help,<br />                  :encoding_help, :verbose, :min_length<br />      <span class="keyword">def</span> initialize<br />        <span class="keyword">super</span>()<br />        <span class="variable">@dictionary</span> = <span class="string">'/usr/share/dict/words'</span><br />        <span class="variable">@encoding</span> = :james<br />        <span class="variable">@format</span> = :plain<br />        <span class="variable">@allow_skips</span> = <span class="keyword">true</span><br />        <span class="variable">@help</span> = <span class="keyword">false</span><br />        <span class="variable">@encoding_help</span> = <span class="keyword">false</span><br />        <span class="variable">@verbose</span> = <span class="keyword">false</span><br />        <span class="variable">@ignore_non_alpha</span> = <span class="keyword">false</span><br />        <span class="variable">@min_length</span> = 1<br />        <span class="keyword">self</span>.on(<span class="string">"-d"</span>, <span class="string">"--dictionary DICTIONARY"</span>, String) { | v |<br />          <span class="variable">@dictionary</span> = v<br />        }<br />        <span class="keyword">self</span>.on(<span class="string">"-e"</span>, <span class="string">"--encoding ENCODING"</span>, String,<br />                <span class="string">"How the alphabet is encoded to phonenumbers. "</span> +<br />                <span class="string">"james or logic are supported."</span>) { | v |<br />          <span class="variable">@encoding</span>   = v.downcase.to_sym<br />        }<br />        <span class="keyword">self</span>.on(<span class="string">"-p"</span>, <span class="string">"--plain"</span>,<br />                <span class="string">'One result per found number, '</span> +<br />                <span class="string">'no other information. (Default)'</span>) { <span class="variable">@format</span> = :plain }<br />        <span class="keyword">self</span>.on(<span class="string">"-f"</span>, <span class="string">"--full"</span>, <span class="string">'Prefix the result with the number'</span>) {<br />          <span class="variable">@format</span> = :full<br />        }<br />        <span class="keyword">self</span>.on(<span class="string">"-v"</span>, <span class="string">"--verbose"</span>, <span class="string">'Make more noise'</span>) { <span class="variable">@verbose</span> = <span class="keyword">true</span> }<br />        <span class="keyword">self</span>.on(<span class="string">"-s"</span>, <span class="string">"--skips"</span>, <span class="string">"--allow_skips"</span>, <span class="string">"--allow-skips"</span>,<br />                <span class="string">'Allow to skip one adjacent number while matching. (Default)'</span>,<br />                <span class="string">'Gives lots of ugly results, but james asked for it.'</span>)   {<br />           <span class="variable">@allow_skips</span>  = <span class="keyword">true</span><br />        }<br />        <span class="keyword">self</span>.on(<span class="string">"-c"</span>, <span class="string">"--no-skips"</span>,<br />                <span class="string">"Don't leave numbers in the detected words"</span>) {<br />          <span class="variable">@allow_skips</span>  = <span class="keyword">false</span><br />        }<br />        <span class="keyword">self</span>.on(<span class="string">"-m"</span> <span class="string">"--min-length"</span>, <span class="string">"Minimum length of accepted words."</span>,<br />                  <span class="string">"Use this to ignore one-letter words that make "</span> +<br />                  <span class="string">"the output quite uninteresting."</span>, Integer) { | v |<br />          <span class="variable">@min_length</span>  = v<br />        }<br />        <span class="keyword">self</span>.on(<span class="string">"-?"</span>, <span class="string">"--help"</span>) { <span class="variable">@help</span> = <span class="keyword">true</span> }<br />        <span class="keyword">self</span>.on(<span class="string">"--supported-encodings"</span>, <span class="string">"--encoding-help"</span>,<br />                <span class="string">"List the supported encodings"</span>) { <span class="variable">@encoding_help</span> = <span class="keyword">true</span> }<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    options = PhonewordOptions.new<br />    options.parse!(ARGV)<br /><br />    <span class="keyword">if</span> options.help<br />      puts options<br />      exit<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">if</span> options.encoding_help <span class="keyword">or</span> !encodings[options.encoding]<br />      puts <span class="string">"Possible encodings:"</span><br />      puts encodings.to_a.sort_by{|(k,v)|k.to_s}.map{|(k,v)|<br />        <span class="string">"#{k}:\n"</span>+v.map{|(n,e)|<span class="string">"  #{n}: #{e}"</span>}.sort.join(<span class="string">"\n"</span>)<br />      }<br />      exit<br />    <span class="keyword">end</span><br /><br />    dictionary = Dictionary.new(encodings[options.encoding]).load_wordlist(<br />      File.open(options.dictionary), options<br />    )<br /><br />    output = {<br />      :plain   =&gt; lambda <span class="keyword">do</span> | number, sentence | sentence <span class="keyword">end</span>,<br />      :full =&gt; lambda <span class="keyword">do</span> | number, sentence |<br />        <span class="string">"#{number.ljust(15)}: #{sentence}"</span><br />      <span class="keyword">end</span><br />    }<br /><br />    method = {<span class="keyword">true</span> =&gt; :find, <span class="keyword">false</span> =&gt; :find_noskip }<br /><br />    ARGF.each <span class="keyword">do</span> | number |<br />      number.strip!<br />      number = number.gsub(<span class="string">/[^0-9]/</span>, <span class="string">''</span>).unpack(<span class="string">'C*'</span>).map{|n|n - ?0}<br />      <span class="global">$stderr</span>.puts <span class="string">"Searching for #{number}"</span> <span class="keyword">if</span> options.verbose<br />      dictionary.send(<br />        method[options.allow_skips], number<br />      ).each <span class="keyword">do</span> | sentence |<br />        puts output[options.format][number, sentence]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Most of that code is option handling.  Brian creates his own PhonewordOptions object, which inherits from OptionParser.  In the setup for that object, defaults are established and option parsing in defined with several calls to on().  From there, reader methods are provided for all the defined options.  This makes for a pretty self-contained bundle of option parsing and reading.  You can see the options object put to good use, after the class.</p>
			<p>That final block is what actually kicks off the program.  Each number is read from ARGF, cleaned up, and passed to the find methods of the dictionary object.  Results from that find are printed, creating a complete solution.</p>
			<p>My thanks go out to all three quiz workers.  It was nice to have a few people playing along again.</p>
			<p>Tomorrows quiz will stay with the topic of phones and how we use them...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/131877">Brian Schr&ouml;der</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/132032">Jannis Harder</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/132035">Brian Schr&ouml;der (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/132097">Lee Marlow</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/132180">Lee Marlow (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/132239">Brian Schr&ouml;der (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/132306">Dave Burt</a></li>
			</ol>
			<p><a href="quiz20_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
