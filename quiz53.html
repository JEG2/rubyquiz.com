<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - TumbleDRYer (#53)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">TumbleDRYer (#53)</span>
			<p>by Hugh Sasse</p>
			<p>The Pragmatic Programmers (and others) recommend that you remove repetition from code.  They call this principle DRY: Don't Repeat Yourself.  Benefits include not having to track down multiple places to make a change affecting the whole system, prevention of inconsistency, as well as reduced debugging time.  Sometimes code ends up being repetitive.  Take this MySQL example from:</p>
			<p><a href="http://manuals.rubyonrails.com/read/chapter/48">Rails Cookbook</a></p>
			<p class="example">CREATE TABLE `authors` (<br />  `id` int(11) NOT NULL auto_increment,<br />  `firstname` varchar(50) NOT NULL default '',<br />  `name` varchar(50) NOT NULL default '',<br />  `nickname` varchar(50) NOT NULL default '',<br />  `contact` varchar(50) NOT NULL default '',<br />  `password` varchar(50) NOT NULL default '',<br />  `description` text NOT NULL,<br />  PRIMARY KEY  (`id`)<br />) TYPE=MyISAM AUTO_INCREMENT=3 ;
  <br />CREATE TABLE `categories` (<br />  `id` int(11) NOT NULL auto_increment,<br />  `name` varchar(20) NOT NULL default '',<br />  `description` varchar(70) NOT NULL default '',<br />  PRIMARY KEY  (`id`)<br />) TYPE=MyISAM AUTO_INCREMENT=3 ;
  <br />CREATE TABLE `categories_documents` (<br />  `category_id` int(11) NOT NULL default '0',<br />  `document_id` int(11) NOT NULL default '0',<br />) TYPE=MyISAM ;
  <br />CREATE TABLE `documents` (<br />  `id` int(11) NOT NULL auto_increment,<br />  `title` varchar(50) NOT NULL default '',<br />  `description` text NOT NULL,<br />  `author_id` int(11) NOT NULL default '0',<br />  `date` date NOT NULL default '0000-00-00',<br />  `filename` varchar(50) NOT NULL default '',<br />  PRIMARY KEY  (`id`),<br />  KEY `document` (`title`)<br />) TYPE=MyISAM AUTO_INCREMENT=14 ;</p>
			<p>clearly there's a lot of repetition in there.  It would be nice if it were possible to eliminate it.  This quiz is about writing a program which we'll call TumbleDRYer, which, given repetitive input, will create ruby code to generate that input, such that the generating program has much less repetition in it.  One way might be to generate a program like this:</p>
			<p class="example"><br /># Undoes the work of TumbleDRYer :-)<br />class WashingMachine<br />  def initialize<br />    @create = 'CREATE TABLE'<br />    @type = 'TYPE=MyISAM'<br />    @varchar_50 = "varchar(50) NOT NULL default '',"<br />    @varchar_20 = "varchar(20) NOT NULL default '',"<br />    @int_11 = "int(11) NOT NULL auto_increment,"<br />    @int_11_0 = "int(11) NOT NULL default '0',"<br />    @pk = "PRIMARY KEY  (`id`)"<br />    @auto = "AUTO_INCREMENT="<br />  end<br /> <br />  def output<br />    print &lt;&lt;EOF<br />   #{@create} `authors` (<br />     `id` #{@int_11}<br />     `firstname` #{@varchar_50}<br />     `name` #{@varchar_50}<br />     `nickname` #{@varchar_50}<br />     `contact` #{@varchar_50}<br />     `password` #{@varchar_50}<br />     `description` text NOT NULL,<br />     #{@pk}<br />   ) #{@type} #{@auto}3 ;
 <br />   #{@create} `categories` (<br />     `id` #{@int_11}<br />     `name` #{@varchar_20}<br />     `description` varchar(70) NOT NULL default '',<br />     #{@pk}<br />   ) #{@type} #{@auto}3 ;
 <br />   #{@create} `categories_documents` (<br />     `category_id` #{@int_11_0}<br />     `document_id` #{@int_11_0}<br />   ) #{@type} ;
 <br />   #{@create} `documents` (<br />     `id` #{@int_11}<br />     `title` #{@varchar_50}<br />     `description` text NOT NULL,<br />     `author_id` #{@int_11_0}<br />     `date` date NOT NULL default '0000-00-00',<br />     `filename` #{@varchar_50}<br />     #{@pk},<br />     KEY `document` (`title`)<br />   ) #{@type} #{@auto}14 ;
 EOF<br />  end<br />end<br /> <br />WashingMachine.new.output</p>
			<p>or something of the kind.   Or it might be worth using ERB.</p>
			<p>Obviously the more human readable to the resulting program is the better: the point is to produce something that simplifies maintenance, rather than data compression.  Techniques from data compression would seem to be useful, however.  Building up a dictionary of character groups and their frequencies might be
useful, and various strategies are possible for how to fragment the string into repeated chunks, such as: the longest repeated substring; splitting on some kind of boundary; or techniques from Ziv-Lempel coding to create the groups.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Great quiz Hugh!  This is one of those unique ideas that was a lot of fun to play with.  There's always some neat things to be accomplished with code that writes code.</p>
			<p>I want to take a look at Bob Showalter's solution below.  It's really just one linear procedure, so I'll show all the code and then break it down:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'strscan'</span><br />    require <span class="string">'abbrev'</span><br /><br />    <span class="keyword">class</span> TumbleDRYer<br /><br />      <span class="comment"># minimum length of a phrase to consider</span><br />      MIN_PHRASE = 10<br /><br />      <span class="comment"># minimum times a phrase must occur to consider</span><br />      MIN_OCCUR = 3<br /><br />      <span class="comment"># minimum length for abbreviation</span><br />      MIN_ABBR = 2<br /><br />      <span class="keyword">def</span> initialize(string)<br />        <span class="variable">@input</span> = string<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> dry<br /><br />        <span class="comment"># this will accumulate a list of repeated phrases to condense</span><br />        phrases = Array.new<br /><br />        <span class="comment"># this will receive the abbreviation for each phrase</span><br />        abbr = Hash.new<br /><br />        lines = <span class="variable">@input</span>.to_a<br />        loop <span class="keyword">do</span><br /><br />          <span class="comment"># process the input data by lines. we find "phrases" by</span><br />          <span class="comment"># first finding the start and end of each "word" in the line,</span><br />          <span class="comment"># and then combining those words into longer phrases. for</span><br />          <span class="comment"># each phrase, we count the number of times it occurs in the</span><br />          <span class="comment"># total input.</span><br />          phr = Hash.new<br />          lines.each <span class="keyword">do</span> |line|<br />            s = StringScanner.new(line)<br />            words = Array.new<br />            loop <span class="keyword">do</span><br />              s.scan_until(<span class="string">/(?=\S)/</span>) <span class="keyword">or</span> <span class="keyword">break</span><br />              beg = s.pos<br />              s.scan(<span class="string">/\S+/</span>)<br />              words &lt;&lt; [ beg, s.pos ]<br />            <span class="keyword">end</span><br /><br />            <span class="comment"># combine words to make 'phrases'</span><br />            combos(words)<br /><br />            <span class="comment"># accumulate phrases, counting their occurences.</span><br />            <span class="comment"># skip phrases that are too short.</span><br />            words.each <span class="keyword">do</span> |from, to|<br />              p = line[from, to - from]<br />              <span class="keyword">next</span> <span class="keyword">unless</span> p.length &gt;= MIN_PHRASE<br />              phr[p] ||= 0<br />              phr[p] += 1<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br /><br />          <span class="comment"># get the longest phrase that occurs the most times</span><br />          longest = phr.sort_by { |k,v| -(k.length * 1000 + v)<br />            }.find { |k,v| v &gt;= MIN_OCCUR } <span class="keyword">or</span> <span class="keyword">break</span><br />          phrase, occurs = longest<br /><br />          <span class="comment"># save the phrase, and then blank it out of the input data</span><br />          <span class="comment"># so we can search for more phrases</span><br />          phrases &lt;&lt; phrase<br />          lines.each { |line| line.gsub!(phrase, <span class="string">' '</span> * phrase.length) }<br /><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># now we have all the phrases we want to replace.</span><br />        <span class="comment"># find unique abbreviations for each phrase.</span><br />        temp = Hash.new<br />        phrases.each <span class="keyword">do</span> |phrase|<br />          key = phrase.scan(<span class="string">/\w+/</span>).flatten.to_s.downcase<br />          key = <span class="string">'_'</span> + key <span class="keyword">unless</span> key =~ <span class="string">/^[_a-zA-Z]/</span><br />          key += <span class="string">'_'</span> <span class="keyword">while</span> temp.has_key? key<br />          temp[key] = phrase<br />        <span class="keyword">end</span><br />        temp.keys.abbrev.sort.each <span class="keyword">do</span> |s, key|<br />          phrase = temp[key]<br />          abbr[phrase] = s <span class="keyword">if</span> abbr[phrase].nil? ||<br />            abbr[phrase].length &lt; MIN_ABBR<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># generate the output class</span><br />        puts <span class="string">"class WashingMachine"</span><br />        puts <span class="string">"  def initialize"</span><br />        phrases.each <span class="keyword">do</span> |phrase|<br />          puts <span class="string">'    @'</span> + abbr[phrase] + <span class="string">" = '"</span> +<br />            phrase.gsub(<span class="string">"'"</span>, <span class="string">"\\\\'"</span>) + <span class="string">"'"</span><br />          <span class="variable">@input</span>.gsub!(phrase, <span class="string">'#{@'</span> + abbr[phrase] + <span class="string">'}'</span>)<br />        <span class="keyword">end</span><br />        puts <span class="string">"  end\n"</span><br />        puts <span class="string">"  def output\nprint &lt;&lt;EOF"</span><br />        puts <span class="variable">@input</span><br />        puts <span class="string">"EOF\n  end\n"</span><br />        puts <span class="string">"end"</span><br /><br />      <span class="keyword">end</span><br /><br />      private<br /><br />      <span class="keyword">def</span> combos(arr, max = arr.size - 1, i = 0)<br />        (i+1..max).each <span class="keyword">do</span> |j|<br />          arr &lt;&lt; [ arr[i][0], arr[j][1] ]<br />        <span class="keyword">end</span><br />        combos(arr, max, i + 1) <span class="keyword">if</span> i &lt; max - 1<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    TumbleDRYer.new(ARGF.read).dry<br /><br /></div></div>
			<p>That's the code, save one unused line I removed.</p>
			<p>The first thing I do when reading code is to try and understand the process.  To get the lay of the land, we need to know what's called where.  The path of execution is trivial to find here.  The last line is the only code, besides a couple of require statements, outside of a class definition.  We know that's what Ruby will run.</p>
			<p>That line tells us that we need to be examining two methods TumbleDRYer#initialize and TumbleDRYer#dry.  Don't be shy with that scrollbar now.  Zip around until you find them.  TumbleDRYer#initialize is easy enough, all it does is record the passed input.  TumbleDRYer#dry is a monster, so let's come back to it.</p>
			<p>Anything else in this file?  Well, we can see that two standard libraries are used, strscan and abbrev.  We can also see three constants at the top of the class that start to give us ideas about how the code will break down the sections it is meant to simplify.</p>
			<p>Beyond that, there's only one other method, which we can assume is a helper to TumbleDRYer#dry.  It's smaller, so let's see if we can figure it out first.  Uh oh, recursion!  My brain just melted and leaked out of my ear.  Okay, let's see if we can cheat and just call it.  Copy and paste and irb to the rescue:</p>
			<p class="example">&gt;&gt; def combos(arr, max = arr.size - 1, i = 0)<br />&gt;&gt;   (i+1..max).each do |j|<br />?&gt;     arr &lt;&lt; [ arr[i][0], arr[j][1] ]<br />&gt;&gt;   end<br />&gt;&gt;   combos(arr, max, i + 1) if i &lt; max - 1<br />&gt;&gt; end<br />=&gt; nil<br />&gt;&gt; combos( (1..10).to_a )<br />=&gt; nil</p>
			<p>Or not.  I was hoping for a more informative return value obviously.</p>
			<p>Okay, it looks like I actually need to read a little.  I see that `arr` is a parameter of the method.  That's how I decided on a sample data set.  A little farther in I can see `arr &lt;&lt; ...`.  Bingo.  It modifies the array.  Now I know how to check it:</p>
			<p class="example">&gt;&gt; test_data = (1..10).to_a<br />=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br />&gt;&gt; combos test_data<br />=&gt; nil<br />&gt;&gt; test_data<br />=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, [1, 1], [1, 1], [1, 0], [1, 0], [1, 1],<br />[1, 1], [1, 0], [1, 0], [1, 1], [0, 1], [0, 0], [0, 0], [0, 1], [0, 1],<br />[0, 0], [0, 0], [0, 1], [1, 0], [1, 0], [1, 1], [1, 1], [1, 0], [1, 0],<br />[1, 1], [0, 0], [0, 1], [0, 1], [0, 0], [0, 0], [0, 1], [1, 1], [1, 1],<br />[1, 0], [1, 0], [1, 1], [0, 1], [0, 0], [0, 0], [0, 1], [1, 0], [1, 0],<br />[1, 1], [0, 0], [0, 1], [1, 1]]</p>
			<p>Yuck.  In the dictionary under "unhelpful", you will find the above listing.  More reading is required.</p>
			<p>Well, if I finish the line I stopped at last time, I find this little nugget:  `[ arr[i][0], arr[j][1] ]`.  That makes me think `arr` is expected to be an Array of Arrays.  It looks like the subarrays only need two items, since the indexes are 0 and 1.  Third try is a charm:</p>
			<p class="example">&gt;&gt; test_data = [1, 3, 5, 7, 9].map { |n| [n, n + 1] }<br />=&gt; [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]<br />&gt;&gt; combos test_data<br />=&gt; nil<br />&gt;&gt; test_data<br />=&gt; [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [1, 4], [1, 6], [1, 8], [1, 10],<br />[3, 6], [3, 8], [3, 10], [5, 8], [5, 10], [7, 10]]</p>
			<p>That looks promising.  Now what are we seeing?  Obviously it added some groupings to the end of the Array.  1 was already seen with 2, but it also paired it with 4, 6, 8, and 10.  That's all of the other second elements.  Then 3 is paired with 6, 8, and 10 and it was already paired with 4, which leaves only 2 missing.  Now I see the pattern.  Each first element is paired with all of the second elements that come after it, in the original Array.</p>
			<p>Even knowing how that works, I'm not sure I understand what that is actually for yet.  I'll file it away in the back of my mind and see if I'm ready to tackle TumbleDRYer#dry.</p>
			<p>Here's the first chunk of that method, to save you some scrolling:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> dry<br /><br />      <span class="comment"># this will accumulate a list of repeated phrases to condense</span><br />      phrases = Array.new<br /><br />      <span class="comment"># this will receive the abbreviation for each phrase</span><br />      abbr = Hash.new<br /><br />      lines = <span class="variable">@input</span>.to_a<br />      loop <span class="keyword">do</span><br /><br />        <span class="comment"># process the input data by lines. we find "phrases" by</span><br />        <span class="comment"># first finding the start and end of each "word" in the line,</span><br />        <span class="comment"># and then combining those words into longer phrases. for</span><br />        <span class="comment"># each phrase, we count the number of times it occurs in the</span><br />        <span class="comment"># total input.</span><br />        phr = Hash.new<br />        lines.each <span class="keyword">do</span> |line|<br />          s = StringScanner.new(line)<br />          words = Array.new<br />          loop <span class="keyword">do</span><br />            s.scan_until(<span class="string">/(?=\S)/</span>) <span class="keyword">or</span> <span class="keyword">break</span><br />            beg = s.pos<br />            s.scan(<span class="string">/\S+/</span>)<br />            words &lt;&lt; [ beg, s.pos ]<br />          <span class="keyword">end</span><br /><br />          <span class="comment"># combine words to make 'phrases'</span><br />          combos(words)<br /><br />          <span class="comment"># accumulate phrases, counting their occurrences.</span><br />          <span class="comment"># skip phrases that are too short.</span><br />          words.each <span class="keyword">do</span> |from, to|<br />            p = line[from, to - from]<br />            <span class="keyword">next</span> <span class="keyword">unless</span> p.length &gt;= MIN_PHRASE<br />            phr[p] ||= 0<br />            phr[p] += 1<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># get the longest phrase that occurs the most times</span><br />        longest = phr.sort_by { |k,v| -(k.length * 1000 + v)<br />          }.find { |k,v| v &gt;= MIN_OCCUR } <span class="keyword">or</span> <span class="keyword">break</span><br />        phrase, occurs = longest<br /><br />        <span class="comment"># save the phrase, and then blank it out of the input data</span><br />        <span class="comment"># so we can search for more phrases</span><br />        phrases &lt;&lt; phrase<br />        lines.each { |line| line.gsub!(phrase, <span class="string">' '</span> * phrase.length) }<br /><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Luckily, that's well commented code.  The comments easily explain what the variables are for, and then we get an introduction to the process in `loop do ... end`.  As soon as I read that, TumbleDRYer#combos clicks into place.</p>
			<p>The Array of Arrays passed to TumbleDRYer#combos holds a start and end position for each word.  The start positions are combined with all of the end positions after that word to give the possible phrases.</p>
			<p>Before the call to TumbleDRYer#combos, we can see the Array of Arrays being created, with a little StringScanner work.  Words are found by scanning non-whitespace characters, because replacing at any other boundaries pretty much kills the human readable goal of the output.</p>
			<p>Just beneath that call to TumbleDRYer#combos the phrases are assembled, checked for the minimum length, and tallied in the phrase count.  The chunk of code right after that selects the longest phrase that occurs the most times for substitution.  Note the clever use of negation in #sort_by here, to reverse the order.  The last couple of lines save the phrase and replace it with whitespace, so it won't match in future iterations.</p>
			<p>Remember, this is all inside of a big `loop do ... end`, so by the time we break out of here, all the replacement phrases will have been selected.</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># now we have all the phrases we want to replace.</span><br />      <span class="comment"># find unique abbreviations for each phrase.</span><br />      temp = Hash.new<br />      phrases.each <span class="keyword">do</span> |phrase|<br />        key = phrase.scan(<span class="string">/\w+/</span>).flatten.to_s.downcase<br />        key = <span class="string">'_'</span> + key <span class="keyword">unless</span> key =~ <span class="string">/^[_a-zA-Z]/</span><br />        key += <span class="string">'_'</span> <span class="keyword">while</span> temp.has_key? key<br />        temp[key] = phrase<br />      <span class="keyword">end</span><br />      temp.keys.abbrev.sort.each <span class="keyword">do</span> |s, key|<br />        phrase = temp[key]<br />        abbr[phrase] = s <span class="keyword">if</span> abbr[phrase].nil? ||<br />          abbr[phrase].length &lt; MIN_ABBR<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This section of the method just finds names for each of the replaced phrases.  It generally choses the first few letters or numbers of the phrase, unless it needs to insert a _ character or two to maintain Ruby syntax or break ambiguities.  A lot of the work here is done by the abbrev library.  If you're not familiar with how that works, ask irb:</p>
			<p class="example">&gt;&gt; require "abbrev"<br />=&gt; true<br />&gt;&gt; names = %w{James Edward Gray II}<br />=&gt; ["James", "Edward", "Gray", "II"]<br />&gt;&gt; names.respond_to? :abbrev<br />=&gt; true<br />&gt;&gt; names.abbrev<br />=&gt; {"II"=&gt;"II", "Gr"=&gt;"Gray", "Gra"=&gt;"Gray", "Jam"=&gt;"James", "Ja"=&gt;"James",<br />"Edw"=&gt;"Edward", "Edwa"=&gt;"Edward", "Edwar"=&gt;"Edward", "Gray"=&gt;"Gray",<br />"James"=&gt;"James", "Edward"=&gt;"Edward", "E"=&gt;"Edward", "G"=&gt;"Gray",<br />"Jame"=&gt;"James", "I"=&gt;"II", "Ed"=&gt;"Edward", "J"=&gt;"James"}</p>
			<p>It turns an Array into a Hash of all the unique abbreviations that can be used to form the words in the original Array.</p>
			<p>Last little bit of code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># generate the output class</span><br />      puts <span class="string">"class WashingMachine"</span><br />      puts <span class="string">"  def initialize"</span><br />      phrases.each <span class="keyword">do</span> |phrase|<br />        puts <span class="string">'    @'</span> + abbr[phrase] + <span class="string">" = '"</span> +<br />          phrase.gsub(<span class="string">"'"</span>, <span class="string">"\\\\'"</span>) + <span class="string">"'"</span><br />        <span class="variable">@input</span>.gsub!(phrase, <span class="string">'#{@'</span> + abbr[phrase] + <span class="string">'}'</span>)<br />      <span class="keyword">end</span><br />      puts <span class="string">"  end\n"</span><br />      puts <span class="string">"  def output\nprint &lt;&lt;EOF"</span><br />      puts <span class="variable">@input</span><br />      puts <span class="string">"EOF\n  end\n"</span><br />      puts <span class="string">"end"</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That just outputs the DRYed code to STDOUT.  This output uses a Ruby heredoc with String interpolation.  Unfortunately, I think that means that Ruby code, with its own String interpolation, will confuse it.  Have a look at Dominik Bathon's code for custom interpolation or Daniel Sheppard's code for ERb templates that even make use of arguments in replacement.</p>
			<p>As always my thanks to all the creative souls that gave this quiz a try.  All of the solutions are educational.</p>
			<p>Ruby Quiz will take a week off now so I can run up to Denver and wish my sister, Nicole Blake Thanner, a happy sweet sixteenth birthday!</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163517">Dale Martenson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163522">Hugh Sasse</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163554">Dale Martenson (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163635">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163654">Bob Showalter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163666">Brian Schr&ouml;der</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163687">Daniel Sheppard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/163909">Scott Bauer</a></li>
			</ol>
			<p><a href="quiz53_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
