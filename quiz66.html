<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - FasterGenerator (#66)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">FasterGenerator (#66)</span>
			<p>Ruby includes a useful Generator library for switching internal iterators to external iterators.  It is used like this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'generator'</span><br /><br />    <span class="comment"># Generator from an Enumerable object</span><br />    g = Generator.new([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'Z'</span>])<br /><br />    <span class="keyword">while</span> g.next?<br />      puts g.<span class="keyword">next</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I've heard complaints in the past that this library is slow.  One reason is that it was implemented with continuations, which have performance issues in the current version of Ruby.  "Was" is the keyword there though, because I've just learned that Generator was recently re-implemented.  I learned some good tricks reading the new version, so let's try fixing Generator ourselves.  (No peeking at the new version!)</p>
			<p>This week's Ruby Quiz is to write FasterGenerator, your own re-implementation of Generator with an eye towards working faster.  (This is a small library.  My version is 54 lines.)  It is possible to go even faster than the new implementation, with certain trade-offs:</p>
			<p class="example">### Construction ###<br /><br />Rehearsal -----------------------------------------------------------<br />Current Generator         0.280000   0.320000   0.600000 (  0.598148)<br />Old callcc Generator      0.630000   1.070000   1.700000 (  1.701587)<br />James's FasterGenerator   0.000000   0.000000   0.000000 (  0.003935)<br />-------------------------------------------------- total: 2.300000sec<br /><br />                              user     system      total        real<br />Current Generator         0.710000   0.640000   1.350000 (  1.356412)<br />Old callcc Generator      0.220000   1.540000   1.760000 (  1.762054)<br />James's FasterGenerator   0.000000   0.000000   0.000000 (  0.003240)<br /><br />### next() ###<br /><br />Rehearsal -----------------------------------------------------------<br />Current Generator        15.960000   0.110000  16.070000 ( 16.116409)<br />Old callcc Generator      5.840000  34.560000  40.400000 ( 40.452677)<br />James's FasterGenerator   0.040000   0.000000   0.040000 (  0.038548)<br />------------------------------------------------- total: 56.510000sec<br /><br />                              user     system      total        real<br />Current Generator        15.910000   0.100000  16.010000 ( 16.063431)<br />Old callcc Generator      5.810000  34.430000  40.240000 ( 40.300504)<br />James's FasterGenerator   0.030000   0.000000   0.030000 (  0.036539)</p>
			<p>It you want to see the class documentation, you can find it here:</p>
			<p><a href="http://www.ruby-doc.org/stdlib/libdoc/generator/rdoc/classes/Generator.html">Generator Documentation</a></p>
			<p>If you want to make sure your implementation is correct, you can use these tests straight out of the current implementation:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'test/unit'</span><br /><br />    <span class="keyword">class</span> TC_Generator &lt; Test::Unit::TestCase<br />      <span class="keyword">def</span> test_block1<br />        g = Generator.new { |g|<br />          <span class="comment"># no yield's</span><br />        }<br /><br />        assert_equal(0, g.pos)<br />        assert_raises(EOFError) { g.current }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> test_block2<br />        g = Generator.new { |g|<br />          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'C'</span><br />            g.<span class="keyword">yield</span> i<br />          <span class="keyword">end</span><br /><br />          g.<span class="keyword">yield</span> <span class="string">'Z'</span><br />        }<br /><br />        assert_equal(0, g.pos)<br />        assert_equal(<span class="string">'A'</span>, g.current)<br /><br />        assert_equal(<span class="keyword">true</span>, g.next?)<br />        assert_equal(0, g.pos)<br />        assert_equal(<span class="string">'A'</span>, g.current)<br />        assert_equal(0, g.pos)<br />        assert_equal(<span class="string">'A'</span>, g.<span class="keyword">next</span>)<br /><br />        assert_equal(1, g.pos)<br />        assert_equal(<span class="keyword">true</span>, g.next?)<br />        assert_equal(1, g.pos)<br />        assert_equal(<span class="string">'B'</span>, g.current)<br />        assert_equal(1, g.pos)<br />        assert_equal(<span class="string">'B'</span>, g.<span class="keyword">next</span>)<br /><br />        assert_equal(g, g.rewind)<br /><br />        assert_equal(0, g.pos)<br />        assert_equal(<span class="string">'A'</span>, g.current)<br /><br />        assert_equal(<span class="keyword">true</span>, g.next?)<br />        assert_equal(0, g.pos)<br />        assert_equal(<span class="string">'A'</span>, g.current)<br />        assert_equal(0, g.pos)<br />        assert_equal(<span class="string">'A'</span>, g.<span class="keyword">next</span>)<br /><br />        assert_equal(1, g.pos)<br />        assert_equal(<span class="keyword">true</span>, g.next?)<br />        assert_equal(1, g.pos)<br />        assert_equal(<span class="string">'B'</span>, g.current)<br />        assert_equal(1, g.pos)<br />        assert_equal(<span class="string">'B'</span>, g.<span class="keyword">next</span>)<br /><br />        assert_equal(2, g.pos)<br />        assert_equal(<span class="keyword">true</span>, g.next?)<br />        assert_equal(2, g.pos)<br />        assert_equal(<span class="string">'C'</span>, g.current)<br />        assert_equal(2, g.pos)<br />        assert_equal(<span class="string">'C'</span>, g.<span class="keyword">next</span>)<br /><br />        assert_equal(3, g.pos)<br />        assert_equal(<span class="keyword">true</span>, g.next?)<br />        assert_equal(3, g.pos)<br />        assert_equal(<span class="string">'Z'</span>, g.current)<br />        assert_equal(3, g.pos)<br />        assert_equal(<span class="string">'Z'</span>, g.<span class="keyword">next</span>)<br /><br />        assert_equal(4, g.pos)<br />        assert_equal(<span class="keyword">false</span>, g.next?)<br />        assert_raises(EOFError) { g.<span class="keyword">next</span> }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> test_each<br />        a = [5, 6, 7, 8, 9]<br /><br />        g = Generator.new(a)<br /><br />        i = 0<br /><br />        g.each { |x|<br />          assert_equal(a[i], x)<br /><br />          i += 1<br /><br />          <span class="keyword">break</span> <span class="keyword">if</span> i == 3<br />        }<br /><br />        assert_equal(3, i)<br /><br />        i = 0<br /><br />        g.each { |x|<br />          assert_equal(a[i], x)<br /><br />          i += 1<br />        }<br /><br />        assert_equal(5, i)<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The Generator library also includes a SyncEnumerator class, but it is written to use Generator and will work fine with a new version, as long as it is API-compatible.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>There were two kinds of solutions to this problem.  The first were Array-based solutions.  The logic here is that we can do the iteration, shove all the results in an Array, and then hand them out one-at-a-time.  Here is Christoffer Lerno's solution, doing exactly that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> MyGenerator<br />        attr_reader :index<br />        <span class="keyword">def</span> initialize(enum = <span class="keyword">nil</span>)<br />            <span class="keyword">if</span> enum <span class="keyword">then</span><br />                <span class="variable">@array</span> = enum.to_a<br />            <span class="keyword">else</span><br />                <span class="variable">@array</span> = Array.new<br />                <span class="keyword">yield</span> <span class="keyword">self</span><br />            <span class="keyword">end</span><br />            <span class="variable">@index</span> = 0<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> current<br />            raise EOFError <span class="keyword">unless</span> next?<br />            <span class="variable">@array</span>[<span class="variable">@index</span>]<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> <span class="keyword">next</span><br />            value = current<br />            <span class="variable">@index</span> += 1<br />            <span class="keyword">return</span> value<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> next?<br />            <span class="keyword">return</span> <span class="variable">@index</span> &lt; <span class="variable">@array</span>.length<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> rewind<br />            <span class="variable">@index</span> = 0<br />            <span class="keyword">self</span><br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> each(&amp;block)<br />            <span class="variable">@array</span>.each(&amp;block)<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> <span class="keyword">yield</span>(value)<br />            <span class="variable">@array</span> &lt;&lt; value<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> pos<br />            <span class="keyword">return</span> <span class="variable">@index</span><br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> end?<br />            <span class="keyword">return</span> !next?<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Even though Generator supposedly works off of the each() method, it claims to accept an Enumerable argument.  If we go on that assumption, there should be a to_a() method which will return all the objects each() iteration would.  (If you are uncomfortable with this logic, you could iterate and add them to an Array by hand.)  You can see Christoffer putting this shortcut to work in initialize(), filling @array with a simple call to to_a().</p>
			<p>The rest of the methods are trivial.  An @index is saved pointing into the @array, which can be incremented or reset to walk the objects.</p>
			<p>The good news:  this is wicked fast in comparison to the old or even the new Generator library.  The bad news:  it doesn't work for all cases.  First, an iterator does not have to be finite, and trying to shove something like a lazily evaluated infinite stream in an Array is going to go poorly.  Furthermore, iteration may be sensitive to external factors like when it is executed.  In those cases, running the full iteration up front may produce different results.</p>
			<p>For these reasons the standard Generator library requires a more general solution.  However, I would still tuck the Array-and-index trick away in the back of your mind, as it may just come in handy some day.  If you can be sure you aren't dealing with any of the edge cases mentioned above and sure you can spare the memory, using an Array and an index is simple and fast.</p>
			<p>For all other times, you have the standard Generator library.</p>
			<p>We know that the library use to work with continuations, but now it has a new implementation.  The new technique was the other one used by the solutions.  It goes like this:  launch a Thread to iterate over the elements, stop the Thread just before each iteration, and wake it up each time you need a new item.</p>
			<p>Let's see how Jacob Fugal implemented that (with a small patch from Ross Bamford).  Here's the setup:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'thread'</span><br /><br />    <span class="keyword">class</span> FasterGenerator<br />      <span class="keyword">def</span> initialize( enum=<span class="keyword">nil</span>, &amp;block )<br />        <span class="variable">@position</span> = 0<br />        <span class="variable">@values</span> = []<br />        <span class="variable">@done</span> = <span class="keyword">false</span><br />        <span class="variable">@mutex</span> = Mutex.new<br />        <span class="variable">@block</span> = block<br /><br />        <span class="keyword">if</span> enum<br />          <span class="variable">@block</span> = proc{ |g|<br />            enum.each{ |x| g.<span class="keyword">yield</span> x }<br />          }<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This almost looks like the Array-and-index trick again, when you see @position and @values, but this version isn't going to slurp the values all at once.  @done is just a flag to tell us when we have exhausted the values and @mutex is a locking tool from the thread library.</p>
			<p>Now @block is a little more interesting.  Generator can be called in two ways, either with an Enumerable object, or with a block that yield()s values to the Generator.  The code above merges the two cases, by providing a block that yield()s through each() when the Enumerable object is given.</p>
			<p>That means the next piece of the puzzle is the yield() method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> <span class="keyword">yield</span>( x )<br />        <span class="variable">@mutex</span>.synchronize{ <span class="variable">@values</span> &lt;&lt; x }<br />        Thread.stop<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>We're starting to see threading work here.  This method grabs the lock, adds the object to @values, drops the lock, and halts the Thread that fetched the object.  The lock is to ensure that multiple Threads don't stomp on the internal @values queue at the same time and the halting is the pause before each iteration I mentioned earlier.</p>
			<p>So, let's see see what current() and next() look like:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> current<br />        collect_value<br />        raise EOFError <span class="keyword">if</span> eof?<br />        <span class="variable">@values</span>[<span class="variable">@position</span>]<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> <span class="keyword">next</span><br />        x = current<br />        <span class="variable">@position</span> += 1<br />        x<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Seems like all the magic here is hidden in the collect_value() method and everything else is just indexing.  Here's the magic method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      private<br />      <span class="keyword">def</span> collect_value<br />        <span class="variable">@thread</span> ||= Thread.new {<br />          Thread.stop<br />          <span class="variable">@block</span>[<span class="keyword">self</span>]<br />          <span class="variable">@mutex</span>.synchronize{ <span class="variable">@done</span> = <span class="keyword">true</span> }<br />        }<br />        Thread.pass <span class="keyword">until</span> <span class="variable">@thread</span>.stop?<br />        <span class="variable">@thread</span>.run <span class="keyword">if</span> <span class="variable">@thread</span>.status <span class="keyword">and</span> need_value?<br />        Thread.pass <span class="keyword">while</span> need_value?<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> need_value?<br />        <span class="variable">@mutex</span>.synchronize{ <span class="keyword">not</span> <span class="variable">@position</span> &lt; <span class="variable">@values</span>.size <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable">@done</span> }<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>collect_value() makes sure we have a Thread running, or creates it if needed.  The Thread is trivial:  halt (to pause before the first iteration), run the block, grab the lock, toggle the @done flag, and release the lock.  Once we are sure there is a Thread, we can pass() the calling Thread until the generator Thread gets a chance to run() and reaches its stop()ing point.</p>
			<p>need_value?() is just a check to make sure we don't have one queued, and we're not finished with iteration.</p>
			<p>The only challenge left is knowing when we are at the end?() of iteration:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> next?<br />        <span class="keyword">return</span> (<span class="keyword">not</span> end?)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> end?<br />        collect_value<br />        <span class="keyword">return</span> eof?<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br />      private<br /><br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> eof?<br />        <span class="variable">@mutex</span>.synchronize{ <span class="keyword">not</span> <span class="variable">@position</span> &lt; <span class="variable">@values</span>.size <span class="keyword">and</span> <span class="variable">@done</span> }<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The secret to end?() is that we must make sure we have a value queued, if possible.  That's because we pause just after each item is added.  We might be in the very last pause before iteration would end.  Calling collect_value() will find the next item or cause the @done flag to be set.  Either way, we then have enough information to properly answer the question.</p>
			<p>Here are the rest of the methods for Jacob's solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> pos<br />        <span class="variable">@position</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> rewind<br />        <span class="variable">@position</span> = 0<br />        <span class="keyword">self</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> each<br />        <span class="keyword">self</span>.rewind<br />        <span class="keyword">while</span> <span class="keyword">self</span>.next?<br />          <span class="keyword">yield</span> <span class="keyword">self</span>.<span class="keyword">next</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> index<br />        pos<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>There shouldn't be any surprises left in there.</p>
			<p>Some other solutions that used this same technique were faster, or even slower.  This seems primarily related to which tools were used to control Thread synchronization.  Mutex, for example, is fairly slow while `Thread.critical = true` is quick and probably all you need in this instance.</p>
			<p>Let me send out a big thank you to all who tried this quiz and an even bigger thank you to Ross Bamford for helping me out with the timings.</p>
			<p>Tomorrow we have a deep meditation on metaprogramming...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179510">Jacob Fugal</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179518">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179525">Christoffer Lern&ouml;</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179534">Ross Bamford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179556">Caleb Clausen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179645">Dave Lee</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179656">Jay Anderson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179674">Jesse Yoon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179893">Dave Lee (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/180022">Dave Lee (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/180136">Ross Bamford (2)</a></li>
			</ol>
			<p><a href="quiz66_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
