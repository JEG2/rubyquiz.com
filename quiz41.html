<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Stock Portfolios (#41)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Stock Portfolios (#41)</span>
			<p>I'm a member of a local stock club.  For those of you not familiar with such clubs, they're just a group of people who pool resources (primarily knowledge, research time, and finances) to purchase stocks.</p>
			<p>My particular club makes use of a lot of technology for information and communication.  A recent request was a tool to practice investing.  This is especially helpful to inexperienced members.  The idea is that they can pretend to purchase a few stocks (preferably after studying their choices!) and then see how they do over time.</p>
			<p>This week's Ruby Quiz is to build this simple tool.</p>
			<p>Here's a sample run to get the ideas flowing:</p>
			<p class="example">$ ./portfolio <br />Buy (symbol shares/dollars):  PIXR $1000<br />You purchased 23 shares of PIXR for $991.53.<br />Buy (symbol shares/dollars):  GOOG 3<br />You purchased 3 shares of GOOG for $887.55.<br />Buy (symbol shares/dollars):  <br />+--------+--------+-----------+----------------+---------------+-----------+<br />| Symbol | Shares | Buy Price |       Buy Date | Current Price | Gain/Loss |<br />+--------+--------+-----------+----------------+---------------+-----------+<br />| GOOG   |      3 | $  295.85 | 07/25/05 19:53 | $      295.85 | $    0.00 |<br />+--------+--------+-----------+----------------+---------------+-----------+<br />| PIXR   |     23 | $   43.11 | 07/25/05 19:53 | $       43.11 | $    0.00 |<br />+--------+--------+-----------+----------------+---------------+-----------+</p>
			<p>Later, I can see how my shares are doing:</p>
			<p class="example">$ ./portfolio <br />+--------+--------+-----------+----------------+---------------+-----------+<br />| Symbol | Shares | Buy Price |       Buy Date | Current Price | Gain/Loss |<br />+--------+--------+-----------+----------------+---------------+-----------+<br />| GOOG   |      3 | $  295.85 | 07/25/05 19:53 | $      293.29 | $   -7.68 |<br />+--------+--------+-----------+----------------+---------------+-----------+<br />| PIXR   |     23 | $   43.11 | 07/25/05 19:53 | $       43.44 | $    7.59 |<br />+--------+--------+-----------+----------------+---------------+-----------+</p>
			<p>Don't feel tied to this exact display or interface.  Some interesting ideas might be to show historical data before asking a user to confirm their choice, or plot changes over regular intervals instead of just showing the initial and current prices.  If you think of something else, go for it.</p>
			<p>I think this is a great quiz for beginners wanting to learn more about Ruby's standard library.  If that describes you, I encourage you to give it a try.  (Hint:  Many web sites offer stock data, all you need do is figure out how to get it...)</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>The first thing this quiz requires is a source of stock data.  The only essential piece of data for the program shown in the quiz is a current share price.  Jeffrey Moss shows what is probably the easiest way to get exactly that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'soap/rpc/driver'</span><br /><br />    driver = SOAP::RPC::Driver.new( <span class="string">'http://services.xmethods.com/soap'</span>,<br />                                    <span class="string">'urn:xmethods-delayed-quotes'</span> )<br />    driver.add_method( <span class="string">'getQuote'</span>, <span class="string">'a_string'</span> )<br />    driver.getQuote(<span class="string">'GOOG'</span>)<br /><br /></div></div>
			<p>That code fetches a current quote for Google (symbol "GOOG"), though it doesn't do anything with it.  It uses the standard SOAP library to retrieve the quote from a web service provider.</p>
			<p>There are, of course, other ways to fetch stock data.  You could always scrape it from any of the numerous provider sites across the web.  Peter Verhage gave us another interesting option with a link posted to Ruby Talk:</p>
			<p><a href="http://www.gummy-stuff.org/Yahoo-data.htm">Yahoo data download</a></p>
			<p>The page describes how to feed Yahoo! custom URL's to which it will respond with and impressive array of stock data in Comma Separated Value (CSV) format.  A couple of solutions put this to use.</p>
			<p>Let's examine Adam Sanderson's code below:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'open-uri'</span><br />    require <span class="string">'ostruct'</span><br />    require <span class="string">'csv'</span><br />    require <span class="string">'yaml'</span><br /><br />    <span class="comment"># I used the methods outlined at http://www.gummy-stuff.org/Yahoo-data.htm</span><br />    <span class="comment"># to fetch and manage data, it works quite well.</span><br />    <span class="comment">#</span><br />    <span class="comment"># StockData encapsulates Yahoo's service and generates OpenStructs </span><br />    <span class="comment"># which have the requested fields. A StockTransaction records the </span><br />    <span class="comment"># purchase or sale of stocks with a timestamp.  StockHistory aggregates</span><br />    <span class="comment"># StockTransactions. The StockPortfolio manages a user's stocks.  Finaly</span><br />    <span class="comment"># the StockApp provides a text UI.  StockApp isn't very polished, but it</span><br />    <span class="comment"># does the trick.</span><br />    <span class="comment">#</span><br />    <span class="comment"># Usage:</span><br />    <span class="comment"># ruby stocks.rb [filename]</span><br />    <span class="comment">#</span><br />    <span class="comment"># .adam sanderson</span><br />    <span class="comment"># netghost@gmail.com</span><br /><br />    <span class="comment"># To make things easier. overide the way Time is printed.</span><br />    <span class="keyword">class</span> Time<br />        <span class="keyword">def</span> to_s<br />            strftime(<span class="string">"%m/%d/%Y %I:%M%p"</span>)<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>You can see that the code starts by requesting four standard libraries be loaded.  The open-uri library makes it trivially easy to read from a URL, ostruct gives us an objectified Hash interface, csv can parse/write CSV data, and YAML is an easy and powerful data language for persistent storage.  Learning about the various libraries Ruby ships with can put a lot of powerful tools at your finger tips.</p>
			<p>The rest of the above snippet is mostly a comment that describes the code to follow.  The Time class is also altered to print date and time information as this code prefers.  (I'm not sure how much value the Time hack has, since the user code could just call strftime() instead.  You be the judge.)</p>
			<p>Here's the first class used in the solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># http://www.gummy-stuff.org/Yahoo-data.htm</span><br />    <span class="keyword">class</span> StockData<br />        include Enumerable<br /><br />        SOURCE_URL = <span class="string">"http://finance.yahoo.com/d/quotes.csv"</span><br /><br />        <span class="comment">#These are the symbols I understand, which are limited</span><br />        OPTIONS = {<br />            :symbol=&gt;<span class="string">"s"</span>,<br />            :name=&gt;<span class="string">"n"</span>,<br />            :last_trade=&gt;<span class="string">"l1"</span>,<br />            :last_trade_date=&gt;<span class="string">"d1"</span>,<br />            :last_trade_time=&gt;<span class="string">"t1"</span>,<br />            :open=&gt;<span class="string">"o"</span>,<br />            :high=&gt;<span class="string">"h"</span>,<br />            :low=&gt;<span class="string">"g"</span>,<br />            :high_52_week=&gt;<span class="string">"k"</span>,<br />            :low_52_week=&gt;<span class="string">"j"</span><br />        }<br /><br />        <span class="keyword">def</span> initialize(symbols, options = [:symbol, :name,<br />                                           :last_trade, :last_trade_date,<br />                                           :last_trade_time])<br />            <span class="variable">@symbols</span> = symbols<br />            <span class="variable">@options</span> = options<br />            <span class="variable">@data</span> = <span class="keyword">nil</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> each<br />            data.each <span class="keyword">do</span> |row|<br />                struct = OpenStruct.new(Hash[*(<span class="variable">@options</span>.zip(row).flatten)])<br />                <span class="keyword">yield</span> struct<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> each_hash<br />            data.each <span class="keyword">do</span> |row|<br />                hash = Hash[*(<span class="variable">@options</span>.zip(row).flatten)]<br />                <span class="keyword">yield</span> hash<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> refresh<br />            symbol_fragment = <span class="variable">@symbols</span>.join <span class="string">"+"</span><br />            option_fragment = <span class="variable">@options</span>.map{|s| OPTIONS[s] }.join <span class="string">""</span><br />            url = SOURCE_URL + <span class="string">"?s=#{symbol_fragment}&amp;f=#{option_fragment}"</span><br />            <span class="variable">@data</span> = []<br />            CSV.parse open(url).read <span class="keyword">do</span> |row|<br />                <span class="variable">@data</span> &lt;&lt; row<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> data<br />            refresh <span class="keyword">unless</span> <span class="variable">@data</span><br />            <span class="variable">@data</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This StockData class is a wrapper for the Yahoo! service I described earlier.  It begins by initializing a few constants for the URL of the service and some of the options provided by the service.  The constructor takes an Array of stock ticker symbols you want to fetch data for and an Array of options indicating the data you wish to fetch.</p>
			<p>Skip down now to the refresh() method, which actually does the data fetching.  This methods just does what the previously mentioned link tells you to:  join() all the symbols with "+", string the options together, form a URL of all that, and read the CSV data from it.  Note that data is loaded into @data, row by row.</p>
			<p>The other three methods are how you get the data.  Let's start with data(), because the other two rely on it.  I like it when people remember that you don't have to write an accessor with the attr_... methods, and you can do clever tricks when you code them yourself.  For example, this method makes sure the data is refresh()ed, if the instance variable is still empty.  I think that's handy.</p>
			<p>The other two methods allow you to iterate over the rows of data.  You can use each_hash(), to receive each row as a Hash pairing the requested option name and the fetched value.  Note the smooth use of zip() and flatten() there to rapidly build the Hash.  The each() method works exactly the same, same that it yields OpenStruct objects instead of Hashes.  In other words, you can choose to access your data with row[:last_trade] or row.last_trade, as you prefer.  (OpenStruct seems to be the preferred choice here though since all the Enumerable methods use it.)</p>
			<p>On to the next class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> StockTransaction<br />        attr_reader :shares, :price, :date<br /><br />        <span class="keyword">def</span> initialize(shares, price)<br />            <span class="variable">@shares</span> = shares<br />            <span class="variable">@price</span> = price<br />            <span class="variable">@date</span> = Time.now<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> cost<br />            <span class="variable">@price</span> * <span class="variable">@shares</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> to_s<br />            ((<span class="variable">@shares</span> &gt; 0) ? <span class="string">"Bought"</span>:<span class="string">"Sold"</span>) +<br />            <span class="string">" #{shares.abs} on #{date} for #{cost.abs}, at #{price}"</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is a simple data class.  It takes a number of shares (maybe negative, for sale transactions) and a price.  It also records the creation time.  Given that, you can ask it for the total cost() or a pretty String describing the transaction.</p>
			<p>Next class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> StockHistory<br />        attr_reader :symbol, :name, :history<br /><br />        <span class="keyword">def</span> initialize(symbol, name)<br />            <span class="variable">@symbol</span> = symbol<br />            <span class="variable">@name</span> = name<br />            <span class="variable">@history</span> = []<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> net_shares<br />            history.inject(0){|shares, transaction|<br />                shares + transaction.shares<br />            }<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> net_balance<br />            history.inject(0){|balance, transaction|<br />                balance + transaction.cost<br />            }<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> started<br />            history.first.date <span class="keyword">unless</span> history.empty?<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> buy(shares, price)<br />            <span class="keyword">if</span>(shares &gt; 0 <span class="keyword">and</span> price &gt; 0)<br />                history &lt;&lt; StockTransaction.new(shares.abs, price)<br />            <span class="keyword">else</span><br />                puts <span class="string">"Could not buy #{shares} of #{name || symbol}, "</span> +<br />                     <span class="string">"you only have #{net_shares} shares."</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> sell(shares, price)<br />            <span class="keyword">if</span>(net_shares &gt;= shares <span class="keyword">and</span> shares &gt; 0 <span class="keyword">and</span> price &gt; 0)<br />                history &lt;&lt; StockTransaction.new(shares.abs*-1, price)<br />            <span class="keyword">else</span><br />                puts <span class="string">"Could not sell #{shares} of #{name || symbol}, "</span> +<br />                     <span class="string">"you only have #{net_shares} shares."</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> to_s<br />            lines = []<br />            lines &lt;&lt; <span class="string">"#{name}(#{symbol})"</span><br />            history.each <span class="keyword">do</span> |t|<br />                lines &lt;&lt; t.to_s<br />            <span class="keyword">end</span><br />            lines.join <span class="string">"\n"</span><br />        <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This class is just a collection of the StockTransactions we just examined.  You initialize() it with a symbol and name, then add transactions with buy() and sell().  Those methods construct StockTransaction objects and add them to the internal history Array.  Once you have a StockHistory started, you can query it for net_shares(), net_balance(), and a started() date.  Finally, to_s() will build a human readable summary using StockTransaction's to_s() to build each line.</p>
			<p>Last stock data class, coming up:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> StockPortfolio<br />        DEFAULT_INFO = [:symbol, :name, :last_trade]<br />        attr :stocks<br /><br />        <span class="keyword">def</span> initialize()<br />            <span class="variable">@stocks</span> = {}    <span class="comment">#stocks by symbol</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Takes a hash of symbols to shares, yields history, price, </span><br />        <span class="comment"># quantity requested</span><br />        <span class="keyword">def</span> transaction(purchases, &amp;block)<br />            data = StockData.new(purchases.keys, DEFAULT_INFO)<br />            data.each <span class="keyword">do</span> |stock|<br />                price = stock.last_trade.to_f<br />                <span class="keyword">if</span> <span class="keyword">not</span> price == 0<br />                    history = <span class="variable">@stocks</span>[ stock.symbol ] ||=<br />                              StockHistory.new(stock.symbol, stock.name)<br />                    <span class="keyword">yield</span> [history, purchases[stock.symbol],<br />                           stock.last_trade.to_f]<br />                <span class="keyword">else</span><br />                    puts <span class="string">"Couldn't find #{stock.symbol}."</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> buy(purchases)<br />            transaction(purchases){|history, shares, price|<br />                history.buy(shares, price)<br />            }<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> sell(purchases)<br />            transaction(purchases){|history, shares, price|<br />                history.sell(shares, price)<br />            }<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> history(symbol=<span class="keyword">nil</span>)<br />            <span class="keyword">if</span> (symbol)<br />                puts stocks[symbol]<br />            <span class="keyword">else</span><br />                stocks.keys.each{|s| history s <span class="keyword">unless</span> s.nil?}<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> report()<br />            data = StockData.new(stocks.keys, DEFAULT_INFO)<br /><br />            data.each <span class="keyword">do</span> |stock|<br />                history = stocks[stock.symbol]<br />                <span class="keyword">if</span> (history)<br />                    gain = (history.net_shares * stock.last_trade.to_f) -<br />                           history.net_balance<br />                    puts <span class="string">"#{stock.name}(#{stock.symbol}), "</span> +<br />                         <span class="string">"Started #{history.started}"</span><br />                    puts <span class="string">" Gain = Shares x Price - Balance:"</span><br />                    puts <span class="string">" $#{gain} = #{history.net_shares} x "</span> +<br />                         <span class="string">"$#{stock.last_trade.to_f} - $#{history.net_balance}"</span><br />                    puts <span class="string">""</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This class manages a portfolio, which is basically a collection of StockHistory objects.  The buy() and sell() methods are the primary interface here, but they both just delegate to transaction().</p>
			<p>That method, which might be better as a private instance method, takes a Hash of symbol keys and shares to buy or sell values.  It also requires a block, though it doesn't use its "block" parameter.  First, transaction() uses a StockData object (with the hardcoded DEFAULT_INFO selection of options) to lookup a current price for each of the symbols passed in.  From that, it constructs price data and a matching StockHistory object, either by looking it up or creating a new one.  The history, passed in share count, and price are then yielded to the block, which buy() and sell() use to add the transactions to the history.</p>
			<p>The other two methods report on the data.  The history() method will print a single transaction history for a requested symbol or all known histories by symbol.  To see how all the owned stocks are holding up, you can call report().  It fetches current prices, again using StockData, then outputs gain/loss information for each symbol in the portfolio.  Note that these methods print data directly to STDOUT and thus wouldn't play too nice with non-console interfaces.</p>
			<p>Finally, here's the application itself:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> StockApp<br />        QUIT    = <span class="string">/^exit|^quit/</span><br />        BUY     = <span class="string">/^buy\s+((\d+\s+\w+)(\,\s*\d+\s+\w+)*)\s*$/</span><br />        SELL    = <span class="string">/^sell\s+((\d+\s+\w+)(\,\s*\d+\s+\w+)*)\s*$/</span><br />        HISTORY = <span class="string">/^history\s*(\w+)?\s*$/</span><br />        REPORT  = <span class="string">/^report\s*$/</span><br />        VIEW    = <span class="string">/^view\s+((\w+)(\,\s*\w+)*)\s*$/</span><br />        HELP    = <span class="string">/^help|^\?/</span><br /><br />        <span class="keyword">def</span> initialize(path=<span class="string">"stock_data.yaml"</span>)<br />            <span class="keyword">if</span> File.exist? path<br />                puts <span class="string">"Loading Portfolio from #{path}"</span><br />                <span class="variable">@portfolio</span> = YAML.load( open(path).read )<br />                <span class="variable">@portfolio</span>.report<br />            <span class="keyword">else</span><br />                puts <span class="string">"Starting a new portfolio..."</span><br />                <span class="variable">@portfolio</span> = StockPortfolio.new()<br />            <span class="keyword">end</span><br />            <span class="variable">@path</span> = path<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> run<br />            command = <span class="keyword">nil</span><br /><br />            <span class="keyword">while</span>(STDOUT &lt;&lt; <span class="string">"&gt;"</span>; command = gets.chomp)<br /><br />                <span class="keyword">case</span> command<br />                    <span class="keyword">when</span> QUIT<br />                        puts <span class="string">"Saving data..."</span><br />                        open(<span class="variable">@path</span>,<span class="string">"w"</span>){|f| f &lt;&lt; <span class="variable">@portfolio</span>.to_yaml}<br />                        puts <span class="string">"Good bye"</span><br />                        <span class="keyword">break</span><br /><br />                    <span class="keyword">when</span> REPORT<br />                        <span class="variable">@portfolio</span>.report<br /><br />                    <span class="keyword">when</span> BUY<br />                        purchases = parse_purchases(<span class="global">$1</span>)<br />                        <span class="variable">@portfolio</span>.buy purchases<br />                        <span class="variable">@portfolio</span>.report<br /><br />                    <span class="keyword">when</span> SELL<br />                        purchases = parse_purchases(<span class="global">$1</span>)<br />                        <span class="variable">@portfolio</span>.sell purchases<br />                        <span class="variable">@portfolio</span>.report<br /><br />                    <span class="keyword">when</span> VIEW<br />                        symbols = (<span class="global">$1</span>).split<br />                        options = [:symbol, :name, :last_trade]<br />                        data = StockData.new(symbols, options)<br />                        data.each <span class="keyword">do</span> |stock|<br />                            puts <span class="string">"#{stock.name} (#{stock.symbol} "</span> +<br />                                 <span class="string">"$#{stock.last_trade})"</span><br />                        <span class="keyword">end</span><br /><br />                    <span class="keyword">when</span> HISTORY<br />                        symbol = <span class="global">$1</span> ? (<span class="global">$1</span>).upcase : <span class="keyword">nil</span><br />                        <span class="variable">@portfolio</span>.history(symbol)<br /><br />                    <span class="keyword">when</span> HELP<br />                       help()<br /><br />                    <span class="keyword">else</span><br />                        puts <span class="string">"Enter: 'help' for help, or 'exit' to quit."</span><br />                <span class="keyword">end</span><br /><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> parse_purchases(str)<br />            purchases = {}<br />            str.scan(<span class="string">/(\d+)\s+(\w+)/</span>){|pair| purchases[<span class="global">$2</span>.upcase] = <span class="global">$1</span>.to_i}<br />            purchases<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> help<br />            puts &lt;&lt;END_OF_HELP<br />    Commands:<br />    [buy]: Purchase Stocks<br />        buy Shares Symbol[, Shares Symbol...]<br />        example: buy 30 GOOG, 10 MSFT<br /><br />    [sell]: Sell Stocks<br />        sell Shares Symbol[, Shares Symbol...]<br />        example: sell 30 GOOG, 10 MSFT<br /><br />    [history]: View your transaction history<br />        history [Symbol]<br />        example: history GOOG<br /><br />    [report]: View a report of your current stocks<br />        report<br /><br />    [view]: View the current price of a stock<br />        view Symbol[, Symbol...]<br />        example: view GOOG, MSFT<br /><br />    [exit]: Quit the stock application (also quit)<br /><br />    END_OF_HELP<br /><br />        <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>While that looks like a lot of code, there's really not a lot of fancy stuff going on.</p>
			<p>The constructor just opens an existing portfolio file, using YAML, if one exists.  You can point it at a file, or it will default.  The path of this file is saved, so the file can be updated on exit.</p>
			<p>The two biggest methods are run() and help().  The run() method just read commands from STDIN, parses them using Regexps (you can see these at the top of the class) in a large case statement, and executes the proper methods on the classes we've been looking at in response.  If you need more details on how any of these work, glance at the other big method, help(), which is just a heredoc String.</p>
			<p>The parse_purchase() method is a helper for the BUY and SELL commands that extracts all the symbols and shares entered by the user.</p>
			<p>Here's the last little chunk of code that creates and runs the application:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />        app = <span class="keyword">if</span> ARGV.length &gt; 0<br />            StockApp.new(ARGV.pop)<br />        <span class="keyword">else</span><br />            StockApp.new()<br />        <span class="keyword">end</span><br />        app.run<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>My thanks to those who delved into the land of Wall Street and made some trades.  Hopefully you're now well on your way to a balanced portfolio.</p>
			<p>Tomorrow we will try a submitted problem from Hans Fugal that should be plenty of fun for all you algorithm junkies out there...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/151371">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/151372">James Edward Gray II (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/151391">Jeffrey Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/151413">Adam Sanderson</a></li>
				<li><a href="http://groups-beta.google.com/group/comp.lang.ruby/msg/752b5ffdf6ad82bd">Owen McCabe</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/280869">Eduardo Vaz de Lima</a></li>
			</ol>
			<p><a href="quiz41_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
