<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Sodoku Solver (#43)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Sodoku Solver (#43)</span>
			<p>Sodokus are simple number puzzles that often appear in various sources of print.  The puzzle you are given is a 9 x 9 grid of numbers and blanks, that might look something like this:</p>
			<p class="example">+-------+-------+-------+<br />| _ 6 _ | 1 _ 4 | _ 5 _ |<br />| _ _ 8 | 3 _ 5 | 6 _ _ |<br />| 2 _ _ | _ _ _ | _ _ 1 |<br />+-------+-------+-------+<br />| 8 _ _ | 4 _ 7 | _ _ 6 |<br />| _ _ 6 | _ _ _ | 3 _ _ |<br />| 7 _ _ | 9 _ 1 | _ _ 4 |<br />+-------+-------+-------+<br />| 5 _ _ | _ _ _ | _ _ 2 |<br />| _ _ 7 | 2 _ 6 | 9 _ _ |<br />| _ 4 _ | 5 _ 8 | _ 7 _ |<br />+-------+-------+-------+</p>
			<p>The task is to fill in the remaining digits (1 through 9 only) such that each row, column, and 3 x 3 box contains exactly one of each digit.  Here's the solution for the above puzzle:</p>
			<p class="example">+-------+-------+-------+<br />| 9 6 3 | 1 7 4 | 2 5 8 |<br />| 1 7 8 | 3 2 5 | 6 4 9 |<br />| 2 5 4 | 6 8 9 | 7 3 1 |<br />+-------+-------+-------+<br />| 8 2 1 | 4 3 7 | 5 9 6 |<br />| 4 9 6 | 8 5 2 | 3 1 7 |<br />| 7 3 5 | 9 6 1 | 8 2 4 |<br />+-------+-------+-------+<br />| 5 8 9 | 7 1 3 | 4 6 2 |<br />| 3 1 7 | 2 4 6 | 9 8 5 |<br />| 6 4 2 | 5 9 8 | 1 7 3 |<br />+-------+-------+-------+</p>
			<p>This week's Ruby Quiz is to write a solver that takes the puzzle on STDIN and prints the solution to STDOUT.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>What's the deal?  Is it Sodoku, Sudoku, Su Doku, or what?</p>
			<p>I wasn't aware of all the name variations when I wrote this quiz.  It looks like the actual number puzzle is usually called Sudoko, now that I've looked into it.  However, some seem to consider Sodoku a slightly different form of the game which can have multiple solutions, while "true" Sudoku should have exactly one.  This fact complicated solutions a little, so I thought it was worth bringing up before we dig into them.</p>
			<p>The solutions to this quiz are quite varied and interesting.  We have raw speed, clever algorithms, java ports, and even not-quite-correct approaches.  I learned a lot digging trough the code and I encourage others to do the same.</p>
			<p>I would say the overriding theme this time though was the sheer amount of code that came in.  Most of the solutions were over two hundred lines, a few even over three hundred.  This probably tells us that the problem was tricky, but I also found some plenty wordy expressions in there.  Let's look at some of those, since I believe that rethinking code can be very instructive.  Here's a method from the first submission of David Brady's solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Loads the @board array from a string matching the example above.</span><br />    <span class="keyword">def</span> load(str)<br />      line_num = 0<br />      str.each_line <span class="keyword">do</span> |line|<br />        line.gsub! <span class="string">'+'</span>, <span class="string">''</span><br />        line.gsub! <span class="string">'-'</span>, <span class="string">''</span><br />        line.gsub! <span class="string">'|'</span>, <span class="string">''</span><br />        line.gsub! <span class="string">'  '</span>, <span class="string">' '</span><br />        line.gsub! <span class="string">'_'</span>, <span class="string">'0'</span><br />        line.strip!<br />        <span class="keyword">if</span> line.length &gt; 0<br />          l = line.split<br />          fail <span class="string">"Line length was #{l.length}"</span> <span class="keyword">unless</span> l.length == 9<br />          <span class="variable">@board</span>[line_num] = l.collect {|x| x.to_i}<br />          line_num += 1<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      fail <span class="string">"Board is not valid."</span> <span class="keyword">unless</span> <span class="keyword">self</span>.valid?<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This code parses the puzzle input format and uses it to load the initial @board, which is just and Array (rows) of Arrays (columns).  It's currently doing this by cleaning up the lines and reading each integer.  Can we smooth that out a little?</p>
			<p>Often with Ruby, having to use an index is a sign that you're not attacking the problem in the easiest way.  Each index is being used to completely replace a line, so let's see if we can just append them directly:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Loads the @board array from a string matching the example above.</span><br />    <span class="keyword">def</span> load(str)<br />      <span class="variable">@board</span> = Array.new<br /><br />      str.each_line <span class="keyword">do</span> |line|<br />        line.gsub! <span class="string">'+'</span>, <span class="string">''</span><br />        line.gsub! <span class="string">'-'</span>, <span class="string">''</span><br />        line.gsub! <span class="string">'|'</span>, <span class="string">''</span><br />        line.gsub! <span class="string">'  '</span>, <span class="string">' '</span><br />        line.gsub! <span class="string">'_'</span>, <span class="string">'0'</span><br />        line.strip!<br />        <span class="keyword">if</span> line.length &gt; 0<br />          l = line.split<br />          fail <span class="string">"Line length was #{l.length}"</span> <span class="keyword">unless</span> l.length == 9<br />          <span class="variable">@board</span> &lt;&lt; l.collect {|x| x.to_i}<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      fail <span class="string">"Board is not valid."</span> <span class="keyword">unless</span> <span class="keyword">self</span>.valid?<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That only saved one line I guess, but conceptually it's getting easier for me to follow already.  That's always a win, I think.</p>
			<p>Let's tackle the text processing.  My first instinct was:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Loads the @board array from a string matching the example above.</span><br />    <span class="keyword">def</span> load(str)<br />      <span class="variable">@board</span> = Array.new<br /><br />      str.each_line <span class="keyword">do</span> |line|<br />        line.delete! <span class="string">'|+-'</span><br />        line.tr! <span class="string">'_'</span>, <span class="string">'0'</span><br />        line.squeeze!<br />        line.strip!<br />        <span class="keyword">if</span> line.length &gt; 0<br />          l = line.split<br />          fail <span class="string">"Line length was #{l.length}"</span> <span class="keyword">unless</span> l.length == 9<br />          <span class="variable">@board</span> &lt;&lt; l.collect {|x| x.to_i}<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      fail <span class="string">"Board is not valid."</span> <span class="keyword">unless</span> <span class="keyword">self</span>.valid?<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Again, only two lines trimmed, but I'm actually helping myself to understand what exactly this code is doing and that's far more important to me.</p>
			<p>I now see that we're stripping non-digit or underscore characters.  We're leaving the spaces however, so we can later split() on whitespace to get each cell.  That gets me thinking:  We don't have to split() on whitespace.  If I can get it down to just what I'm after, we can split() on characters:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Loads the @board array from a string matching the example above.</span><br />    <span class="keyword">def</span> load(str)<br />      <span class="variable">@board</span> = Array.new<br /><br />      str.each_line <span class="keyword">do</span> |line|<br />        line.delete! <span class="string">'^0-9_'</span><br />        <span class="keyword">if</span> line.length &gt; 0<br />          l = line.split(<span class="string">''</span>)<br />          fail <span class="string">"Line length was #{l.length}"</span> <span class="keyword">unless</span> l.length == 9<br />          <span class="variable">@board</span> &lt;&lt; l.collect {|n| Integer(n) <span class="keyword">rescue</span> 0 }<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      fail <span class="string">"Board is not valid."</span> <span class="keyword">unless</span> <span class="keyword">self</span>.valid?<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Note that I did change the collect() to be more obvious, since I removed translation of '_' to '0'.  This isn't strictly needed, as String.to_i() will return 0 if it can't form a number, but I'm trying not to damage the readability of this code with my changes.</p>
			<p>We're getting close, I can tell, but there's another trick or two left.  We have to check the line length to see if it's one of the lines that contains cells or just a border row.  If we skip border rows altogether, we could the switch our focus from deleting the unwanted data to grabbing wanted data.  (Gavin Kistner originally pointed this out on Ruby Talk.)  Let's see what that does for us:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Loads the @board array from a string matching the example above.</span><br />    <span class="keyword">def</span> load(str)<br />      <span class="variable">@board</span> = Array.new<br /><br />      str.each_line <span class="keyword">do</span> |line|<br />        <span class="keyword">next</span> <span class="keyword">unless</span> line =~ <span class="string">/\d|_/</span><br />        <span class="variable">@board</span> &lt;&lt; line.scan(<span class="string">/[\d_]/</span>).collect {|n| Integer(n) <span class="keyword">rescue</span> 0 }<br />        fail <span class="string">"Length was #{@board.last.length}"</span> <span class="keyword">unless</span> <span class="variable">@board</span>.last.length == 9<br />      <span class="keyword">end</span><br /><br />      fail <span class="string">"Board is not valid."</span> <span class="keyword">unless</span> <span class="keyword">self</span>.valid?<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Moving the line verification to after I load @board also allowed me to do away with the extra variable, as you can see.</p>
			<p>To me, that removes a lot of the wordiness of the original code, without sacrificing clarity or functionality.  It's probably a touch more efficient too, since we trimmed quite a few operations.</p>
			<p>I believe Adam Shelly's parse routine could benefit from similar simplifications if you want to try your own hand at a little refactoring.</p>
			<p>Here's another chunk of code (from Horndude77's solution) just crying out for some help:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> solve<br />        <span class="comment">#is there a better way to do this? it seems messy</span><br />        <span class="comment"># and redundant.</span><br />        changed = <span class="keyword">true</span><br />        <span class="keyword">while</span>(changed &amp;&amp; <span class="variable">@unknown</span>.length&gt;0)<br />            changed = <span class="keyword">false</span><br />            changed = eliminateall ? <span class="keyword">true</span> : changed<br />            changed = checkallrows ? <span class="keyword">true</span> : changed<br />            changed = eliminateall ? <span class="keyword">true</span> : changed<br />            changed = checkallcols ? <span class="keyword">true</span> : changed<br />            changed = eliminateall ? <span class="keyword">true</span> : changed<br />            changed = checkallboxes ? <span class="keyword">true</span> : changed<br />        <span class="keyword">end</span><br />        puts <span class="keyword">self</span><br />        <span class="keyword">if</span>(<span class="variable">@unknown</span>.length&gt;0)<br />            puts <span class="string">"I can't solve this one"</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I told myself that was too easy and had the following knee-jerk reaction:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> solve<br />        changed = <span class="keyword">true</span><br />        <span class="keyword">while</span>(changed &amp;&amp; <span class="variable">@unknown</span>.length&gt;0)<br />            changed = eliminateall || checkallrows || eliminateall ||<br />                      checkallcols || eliminateall || checkallboxes<br />        <span class="keyword">end</span><br />        puts <span class="keyword">self</span><br />        <span class="keyword">if</span>(<span class="variable">@unknown</span>.length&gt;0)<br />            puts <span class="string">"I can't solve this one"</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That's cute, and may even work if the underlying algorithms aren't sensitive to the call order, but it is not identical in function to the original code.  The original method calls all of those methods and just tracks to see if any one of them returned true.  The second version will short-circuit the call chain as soon as a method returns true.  We'll have to be a bit more clever to avoid that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> solve<br />        changed = <span class="keyword">true</span><br />        <span class="keyword">while</span>(changed &amp;&amp; <span class="variable">@unknown</span>.length&gt;0)<br />            changed = <span class="string">%w{ eliminateall checkallrows eliminateall<br />                          checkallcols eliminateall checkallboxes }</span>.map <span class="keyword">do</span> |m|<br />                send(m)<br />            <span class="keyword">end</span>.include?(<span class="keyword">true</span>)<br />        <span class="keyword">end</span><br />        puts <span class="keyword">self</span><br />        <span class="keyword">if</span>(<span class="variable">@unknown</span>.length&gt;0)<br />            puts <span class="string">"I can't solve this one"</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That should be equivalent to the original, I believe, minus some repetition.</p>
			<p>My point in showing the above examples wasn't to pick on anyone and I apologize if I gave any offense.  I just wanted to explore a little idiomatic Ruby through some examples.</p>
			<p>Back to Sudoku itself.  Let's look at a solution.  Here's the beginning of Dominik Bathon's solver class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> SudokuSolver<br /><br />        <span class="comment"># sudoku is an array of arrays, containing the rows, which contain the</span><br />        <span class="comment"># cells (all non valid entries are interpreted as open)</span><br />        <span class="keyword">def</span> initialize(sudoku)<br />            <span class="comment"># determine @n / @sqrt_n</span><br />            <span class="variable">@n</span> = sudoku.size<br />            <span class="variable">@sqrt_n</span> = Math.sqrt(<span class="variable">@n</span>).to_i<br />            raise <span class="string">"wrong sudoku size"</span> <span class="keyword">unless</span> <span class="variable">@sqrt_n</span> * <span class="variable">@sqrt_n</span> == <span class="variable">@n</span><br /><br />            <span class="comment"># populate internal representation</span><br />            <span class="variable">@arr</span> = sudoku.collect { |row|<br />                <span class="comment"># ensure correct width for all rows</span><br />                (0...<span class="variable">@n</span>).collect { |i|<br />                    <span class="comment"># fixed cell or all values possible for open cell</span><br />                    ((1..<span class="variable">@n</span>) === row[i]) ? [row[i]] : (1..<span class="variable">@n</span>).to_a<br />                }<br />            }<br /><br />            <span class="comment"># initialize fix arrays</span><br />            <span class="comment"># they will contain all fixed cells for all rows, cols and boxes</span><br />            <span class="variable">@rfix</span>=Array.new(<span class="variable">@n</span>) { [] }<br />            <span class="variable">@cfix</span>=Array.new(<span class="variable">@n</span>) { [] }<br />            <span class="variable">@bfix</span>=Array.new(<span class="variable">@n</span>) { [] }<br />            <span class="variable">@n</span>.times { |r| <span class="variable">@n</span>.times { |c| update_fix(r, c) } }<br /><br />            <span class="comment"># check for non-unique numbers</span><br />            [<span class="variable">@rfix</span>, <span class="variable">@cfix</span>, <span class="variable">@bfix</span>].each { |fix| fix.each { |x|<br />                <span class="keyword">unless</span> x.size == x.uniq.size<br />                    raise <span class="string">"non-unique numbers in row, col or box"</span><br />                <span class="keyword">end</span><br />            } }<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>This constructor takes an Array of Arrays, which is simply the board setup read from the input file.  After finding the board size, you can see the method builds its internal Array (rows) of Arrays (columns) of Arrays (possible numbers for that cell).  Known cells are set to a one element member with the known value, while other cells are set to an Array of all the possible numbers.</p>
			<p>Next, we see that the code also builds representations for rows, columns, and boxes and repeatedly calls update_fix(), we assume to populate them.</p>
			<p>The method ends with a puzzle validation check, ensuring that there are no duplicate numbers in rows, columns or boxes.</p>
			<p>Jumping a little out of order now, let's examine the private methods used by the constructor:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        private<br /><br />        <span class="comment"># returns the box index of row r and col c</span><br />        <span class="keyword">def</span> rc2box(r, c)<br />             (r - (r % <span class="variable">@sqrt_n</span>)) + (c / <span class="variable">@sqrt_n</span>)<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># if row r, col c contains a fixed cell, it is added to the fixed arrays</span><br />        <span class="keyword">def</span> update_fix(r, c)<br />            <span class="keyword">if</span> <span class="variable">@arr</span>[r][c].size == 1<br />                <span class="variable">@rfix</span>[r] &lt;&lt; <span class="variable">@arr</span>[r][c][0]<br />                <span class="variable">@cfix</span>[c] &lt;&lt; <span class="variable">@arr</span>[r][c][0]<br />                <span class="variable">@bfix</span>[rc2box(r, c)] &lt;&lt; <span class="variable">@arr</span>[r][c][0]<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>From here we can see that the rows, columns, and boxes tracking variables only receive a number that has been narrowed down to a single possibility.  Because of that simplification, these are just two dimensional Arrays.  Note that each new-found number is just appended to the Array.  These will not be in the same order as they really appear in the puzzle, but since they're just used to verify uniqueness it doesn't matter.</p>
			<p>The first method, rc2box() just uses math to locate which box we're in, given a row and column.</p>
			<p>Back to the public methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        public<br /><br />        <span class="comment"># returns the internal representation as array of arrays</span><br />        <span class="keyword">def</span> to_a<br />            <span class="variable">@arr</span>.collect { |row| row.collect { |x|<br />                (x.size == 1) ? x[0] : <span class="keyword">nil</span><br />            } }<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># returns a simple string representation</span><br />        <span class="keyword">def</span> to_s<br />            fw = <span class="variable">@n</span>.to_s.size<br />            to_a.collect { |row| row.collect { |x|<br />                (x ? x.to_s : <span class="string">"_"</span>).rjust(fw)<br />            }.join <span class="string">" "</span> }.join <span class="string">"\n"</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># returns whether the puzzle is solved</span><br />        <span class="keyword">def</span> finished?<br />            <span class="variable">@arr</span>.each { |row| row.each { |x| <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> x.size &gt; 1 } }<br />            <span class="keyword">true</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>The above methods allow you to query the solver for an Array representation, a String representation, or just to find out if it is finished being solved yet.  Starting with to_a(), you can see that it basically just flattens the third dimension of Arrays either into a known number choice, or nil for unknowns.  The next method, to_s(), calls to_a(), stringifies, and join()s the results.</p>
			<p>On to the actual solving code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># for each cell remove the possibilities, that are already used in the</span><br />        <span class="comment"># cell's row, col or box</span><br />        <span class="comment"># return if successful</span><br />        <span class="keyword">def</span> reduce<br />            success = <span class="keyword">false</span><br />            <span class="variable">@n</span>.times { |r| <span class="variable">@n</span>.times { |c|<br />                <span class="keyword">if</span> (sz = <span class="variable">@arr</span>[r][c].size) &gt; 1<br />                    <span class="variable">@arr</span>[r][c] = <span class="variable">@arr</span>[r][c] -<br />                        (<span class="variable">@rfix</span>[r] | <span class="variable">@cfix</span>[c] | <span class="variable">@bfix</span>[rc2box(r, c)])<br />                    raise <span class="string">"impossible to solve"</span> <span class="keyword">if</span> <span class="variable">@arr</span>[r][c].empty?<br />                    <span class="comment"># have we been successful</span><br />                    <span class="keyword">if</span> <span class="variable">@arr</span>[r][c].size &lt; sz<br />                        success = <span class="keyword">true</span><br />                        update_fix(r, c)<br />                    <span class="keyword">end</span><br />                <span class="keyword">end</span><br />            } }<br />            success<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method is a simple, but important, piece of the solving task.  It simply walks cell by cell reducing the possibilities by what we already know.  It uses the Array union operator (|) to combine all known numbers for the row, column and box of this cell.  All of those numbers are then removed from the possibilities using the Array difference operator (-).  When any cell shrinks in choices, update_fix() is called again to notify row, column, and box of the change.  As long as a single cell lost a single possibility this method returns true to report progress.</p>
			<p>Here's another solving method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># find open cells with unique elements in their row, col or box</span><br />        <span class="comment"># return if successful</span><br />        <span class="comment"># reduce must return false when this method is called (if the</span><br />        <span class="comment"># possibilities aren't reduced, bad things may happen...)</span><br />        <span class="keyword">def</span> deduce<br />            success = <span class="keyword">false</span><br />            [:col_each, :row_each, :box_each].each { |meth|<br />                <span class="variable">@n</span>.times { |i|<br />                    u = uniqs_in(meth, i)<br />                    <span class="keyword">unless</span> u.empty?<br />                        send(meth, i) { |x|<br />                            <span class="keyword">if</span> x.size &gt; 1 &amp;&amp; ((u2 = u &amp; x).size == 1)<br />                                success = <span class="keyword">true</span><br />                                u2<br />                            <span class="keyword">else</span><br />                                <span class="keyword">nil</span><br />                            <span class="keyword">end</span><br />                        }<br />                        <span class="comment"># change only one row/col/box at a time</span><br />                        <span class="keyword">return</span> success <span class="keyword">if</span> success<br />                    <span class="keyword">end</span><br />                }<br />            }<br />            success<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>Another way to be sure of a cell is to find a unique possibility in the row, column, or box.  In other words, if two is a possibility in the fifth cell of a row, but not a possibility in any other cell of the row, we know it belongs in the fifth cell and we can place it.</p>
			<p>This code hunts for that using iterators to get all the cells in a row, column, or box and the helper method uniqs_in(), which performs the search I just explained.  When a unique option is found, the code places it and returns true to indicate progress.</p>
			<p>Here are all four private helper methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        private<br /><br />        <span class="comment"># yields each cell of row r and assigns the result of the yield unless</span><br />        <span class="comment"># it is nil</span><br />        <span class="keyword">def</span> row_each(r)<br />            <span class="variable">@n</span>.times { |c|<br />                <span class="keyword">if</span> (res = <span class="keyword">yield</span>(<span class="variable">@arr</span>[r][c]))<br />                    <span class="variable">@arr</span>[r][c] = res<br />                    update_fix(r, c)<br />                <span class="keyword">end</span><br />            }<br />        <span class="keyword">end</span><br />        <span class="comment"># yields each cell of col c and assigns the result of the yield unless</span><br />        <span class="comment"># it is nil</span><br />        <span class="keyword">def</span> col_each(c)<br />            <span class="variable">@n</span>.times { |r|<br />                <span class="keyword">if</span> (res = <span class="keyword">yield</span>(<span class="variable">@arr</span>[r][c]))<br />                    <span class="variable">@arr</span>[r][c] = res<br />                    update_fix(r, c)<br />                <span class="keyword">end</span><br />            }<br />        <span class="keyword">end</span><br />        <span class="comment"># yields each cell of box b and assigns the result of the yield unless</span><br />        <span class="comment"># it is nil</span><br />        <span class="keyword">def</span> box_each(b)<br />            off_r, off_c = (b - (b % <span class="variable">@sqrt_n</span>)), (b % <span class="variable">@sqrt_n</span>) * <span class="variable">@sqrt_n</span><br />            <span class="variable">@n</span>.times { |i|<br />                r, c = off_r + (i / <span class="variable">@sqrt_n</span>), off_c + (i % <span class="variable">@sqrt_n</span>)<br />                <span class="keyword">if</span> (res = <span class="keyword">yield</span>(<span class="variable">@arr</span>[r][c]))<br />                    <span class="variable">@arr</span>[r][c] = res<br />                    update_fix(r, c)<br />                <span class="keyword">end</span><br />            }<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># find unique numbers in possibility lists of a row, col or box</span><br />        <span class="comment"># each_meth must be :row_each, :col_each or :box_each</span><br />        <span class="keyword">def</span> uniqs_in(each_meth, index)<br />            h = Hash.new(0)<br />            send(each_meth, index) { |x|<br />                x.each { |n| h[n] += 1 } <span class="keyword">if</span> x.size &gt; 1<br />                <span class="keyword">nil</span> <span class="comment"># we didn't change anything</span><br />            }<br />            h.select { |k, v| v == 1 }.collect { |k, v| k }<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>The iterators are pretty obvious.  The only gotcha to their use is that the block is expected to return true or false, indicating if the cell was updated.  This allows the iterator to call update_fix() and keep the internal representations in sync.</p>
			<p>The uniqs_in() method just uses those iterators to fill a Hash with seen counts and then returns all keys that were only seen once.</p>
			<p>Finally, we start to see it all come together with the next method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        public<br /><br />        <span class="comment"># tries to solve the sudoku with reduce and deduce</span><br />        <span class="comment"># returns one of :impossible, :solved, :unknown</span><br />        <span class="keyword">def</span> solve<br />            <span class="keyword">begin</span><br />                <span class="keyword">until</span> finished?<br />                    progress = <span class="keyword">false</span><br />                    <span class="keyword">while</span> reduce<br />                        progress = <span class="keyword">true</span><br />                    <span class="keyword">end</span><br />                    progress = <span class="keyword">true</span> <span class="keyword">if</span> deduce<br />                    <span class="keyword">return</span> :unknown <span class="keyword">unless</span> progress<br />                <span class="keyword">end</span><br />                :solved<br />            <span class="keyword">rescue</span><br />                :impossible<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method just combines calls to to the previously seen reduce() and deduce() to see if it can use process of elimination to solve the problem.  It loops as long as either method reports some progress.  It will eventually return :solved, if finished?() declares the puzzle done, or :unknown if it runs out of reductions and deductions.  :impossible is returned in the event of a problem.</p>
			<p>The above can solve some puzzles quickly and efficiently, but it's not a complete solution.  When it won't go any father, it's time for some guess work:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># solves the sudoku using solve and if that fails, it tries to guess</span><br />        <span class="comment"># returns one of :impossible, :solved, :multiple_solutions</span><br />        <span class="keyword">def</span> backtrack_solve<br />            <span class="keyword">if</span> (res = solve) == :unknown<br />                <span class="comment"># find first open cell</span><br />                r, c = 0, 0<br />                <span class="variable">@rfix</span>.each_with_index { |rf, r|<br />                    <span class="keyword">break</span> <span class="keyword">if</span> rf.size &lt; <span class="variable">@n</span><br />                }<br />                <span class="variable">@arr</span>[r].each_with_index { |x, c|<br />                    <span class="keyword">break</span> <span class="keyword">if</span> x.size &gt; 1<br />                }<br />                partial = to_a<br />                solutions = []<br />                <span class="comment"># try all possibilities for the open cell</span><br />                <span class="variable">@arr</span>[r][c].each { |guess|<br />                    partial[r][c] = guess<br />                    rsolver = SudokuSolver.new(partial)<br />                    <span class="keyword">case</span> rsolver.backtrack_solve<br />                    <span class="keyword">when</span> :multiple_solutions<br />                        initialize(rsolver.to_a)<br />                        <span class="keyword">return</span> :multiple_solutions<br />                    <span class="keyword">when</span> :solved<br />                        solutions &lt;&lt; rsolver<br />                    <span class="keyword">end</span><br />                }<br />                <span class="keyword">if</span> solutions.empty?<br />                    <span class="keyword">return</span> :impossible<br />                <span class="keyword">else</span><br />                    initialize(solutions[0].to_a)<br />                    <span class="keyword">return</span> solutions.size &gt; 1 ? :multiple_solutions : :solved<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />            res<br />        <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Note that this method begins by calling solve().  If it yields a complete solution, the rest of the work can be skipped.  Even if it doesn't though, it should have reduced the possibilities, making the coming job easier.</p>
			<p>The next bit of code locates a cell to start guessing with.  Rows are scanned to find one that hasn't been completely filled in, then columns are scanned to find a cell with more than one possibility.  Note how those two iterations purposefully clobber the local variables (r and c), so they will hold the final address of the cell when scanning is done.</p>
			<p>Finally, we're to the guess work.  An Array is prepared to hold solutions and the current known cells are retrieved with a call to to_a().  Then, each possibility for the selected cell is inserted and a new solver is built and run.  This amounts to recursion of the entire process.  The results of these guesses are examined by a case statement and added to the solutions Array when found.  The case statement ignores :impossible returns, since these are just wrong guesses.</p>
			<p>Finally the method checks to see if any solutions were found, and returns the proper Symbol for the results.</p>
			<p>The last little chunk of code handles input and output for the solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="global">$0</span> == <span class="keyword">__FILE__</span><br />        <span class="comment"># read a sudoku from stdin</span><br />        sudoku = []<br />        <span class="keyword">while</span> sudoku.size &lt; 9<br />            row = gets.scan(<span class="string">/\d|_/</span>).map { |s| s.to_i }<br />            sudoku &lt;&lt; row <span class="keyword">if</span> row.size == 9<br />        <span class="keyword">end</span><br />        <span class="comment"># solve</span><br />        <span class="keyword">begin</span><br />            solver = SudokuSolver.new(sudoku)<br />            puts <span class="string">"Input:"</span>, solver<br />            <span class="keyword">case</span> solver.backtrack_solve<br />            <span class="keyword">when</span> :solved<br />                puts <span class="string">"Solution:"</span><br />            <span class="keyword">when</span> :multiple_solutions<br />                puts <span class="string">"There are multiple solutions!"</span>, <span class="string">"One solution:"</span><br />            <span class="keyword">else</span><br />                puts <span class="string">"Impossible:"</span><br />            <span class="keyword">end</span><br />            puts solver<br />        <span class="keyword">rescue</span> =&gt; e<br />            puts <span class="string">"Error: #{e.message}"</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Look at that four line input read up there.  Its similar to what we reduced the other code to at the beginning of this summary.  The output is very straight forward.  It just makes good use of to_s() in the solver object to print the board before and after.</p>
			<p>My thanks to all who sent in their solutions, sometimes many, many times.  ;)</p>
			<p>Next week's Ruby Quiz is shamelessly stolen from another source of Ruby challenges.  Stay tuned to see the kind of problems Dave Thomas cooks up...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153140">Karl von Laudermann</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153142">Gavin Kistner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153162">Horndude77</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153166">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153169">Simon Kr&ouml;ger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153184">Vance A Heron</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153261">David Tran (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153292">Adam Shelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153314">Adam Shelly (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153349">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153356">Simon Kr&ouml;ger (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153363">David Tran (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153364">David Tran (4)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153366">Adam Shelly (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153369">Adam Shelly (4)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153378">David Brady</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153418">Mohit Muthanna</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153430">David Tran (5)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153484">David Tran (6)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153482">David Brady (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153547">Simon Kr&ouml;ger (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/153688">graeme</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/167212">Edward Faulkner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/173116">Christer Nilsson</a></li>
			</ol>
			<p><a href="quiz43_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
