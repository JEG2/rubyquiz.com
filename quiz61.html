<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Dice Roller (#61)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Dice Roller (#61)</span>
			<p>by Matthew D Moss</p>
			<p>Time to release your inner nerd.</p>
			<p>The task for this Ruby Quiz is to write a dice roller. You should write a program that takes two arguments: a dice expression followed by the number of times to roll it (being optional, with a default of 1). So to calculate those stats for your AD&amp;D character, you would do this:</p>
			<p class="example">&gt; roll.rb "3d6" 6<br />6  6  9  11  9  13</p>
			<p>Or, for something more complicated:</p>
			<p class="example">&gt; roll.rb "(5d5-4)d(16/d4)+3"<br />31</p>
			<p>[NOTE: You'll usually want quotes around the dice expression to hide parenthesis from the shell, but the quotes are not part of the expression.]</p>
			<p>The main code of roll.rb should look something like this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    d = Dice.new(ARGV[0])<br />    (ARGV[1] || 1).to_i.times { print <span class="string">"#{d.roll}  "</span> }<br /><br /></div></div>
			<p>The meat of this quiz is going to be parsing the dice expression (i.e., implementing Dice.new). Let's first go over the grammar, which I present in a simplified BNF notation with some notes:</p>
			<p class="example">&lt;expr&gt; := &lt;expr&gt; + &lt;expr&gt;<br />       |  &lt;expr&gt; - &lt;expr&gt;<br />       |  &lt;expr&gt; * &lt;expr&gt;<br />       |  &lt;expr&gt; / &lt;expr&gt;<br />       |  ( &lt;expr&gt; )<br />       |  [&lt;expr&gt;] d &lt;expr&gt;<br />       |  integer<br /><br />* Integers are positive; never zero, never negative.<br />* The "d" (dice) expression XdY rolls a Y-sided die (numbered<br />  from 1 to Y) X times, accumulating the results.  X is optional<br />  and defaults to 1.<br />* All binary operators are left-associative.<br />* Operator precedence:<br />          ( )      highest<br />          d<br />          * /<br />          + -      lowest</p>
			<p>[NOTE: The BNF above is simplified here for clarity and space. If requested, I will make available the full BNF description I've used in my own solution, which incorporates the association and precedence rules.]</p>
			<p>A few more things...  Feel free to either craft this by hand or an available lexing/parsing library.  Handling whitespace between integers and operators is nice.  Some game systems use d100 quite often, and may abbreviate it as "d%" (but note that '%' is only allowed immediately after a 'd').</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>by Matthew Moss</p>
			<p>My reason for choosing a dice roller is somewhat selfish: I was interested to see how people would solve a problem that required parsing a mini-language. I've written lexers and parsers before, years ago, but I wanted to see what methods the Ruby gurus would employ.</p>
			<p>I was not unsurprised. While there were some "traditional" solutions, there were also a few that made me remember something I realized in past Ruby Quizzes: it's all about pattern matching.  One of the solutions to past quiz #24 (Texas Hold'Em) showed how much power can be gained by a careful examination of the patterns in the problem; with a few carefully built regular expressions, some gsub calls and a bit of magic, you can turn what looks like a complex problem into something much similar.  I should have remembered that (or, at the least, realized that someone else would).</p>
			<p>Discussion on the list about the quiz was rather active, most of the time getting into the nitty-gritty details of what d10 and 5d6d7 meant, and occassionally joking about munchkins and their stats of all 18 (with a strength of 18/00, of course). As solutions came in, it was nice to see about four or five people making their first attempt. With them, this quiz gets the bronze medal for submission count, behind the LCD Numbers quiz (#14) and the Numeric Maze quiz (#60).</p>
			<p>I found unique bits in most every solution; even those that took almost identical approaches would often, at the least, have different regular expressions. If you are afraid of the mighty regexp, now would be a good time to study some samples, since the syntax for the dice expressions is reasonably simple, and many people documented their regular expressions.</p>
			<p>Most solutions fell into one of a few types. I'll cover each a bit and point out anything in particular that attracted my attention.</p>
			<p>The first class of solutions massaged the input expression a bit, then used Ruby's eval method to do the work. This simple solution eluded me, since I was so fixed on seeing parsing code. Apparently a bunch of you realized that (as Paul Novak so nicely put) "we don't need no steenking parsers." A few substitutions and a helper function or two was enough to do the trick, since aside from the 'd' operator, the expression were valid Ruby already.  Let's take a look at Christian Neukirchen's solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Integer<br />      <span class="keyword">def</span> d(n)<br />        (1..<span class="keyword">self</span>).inject(0) { |a, e| a + rand(n) + 1 }<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>First off we have the random number generation; most solutions had this or a very similar variant. So the call 3.d(6) will roll and accumulate three six-sided dice, and the expression 3.d(6) is almost a valid dice expression. It is in Christian's initialization method that dice expressions are turned into Ruby expressions:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> initialize(dice)<br />       <span class="variable">@src</span> = dice.gsub(<span class="string">/d(%|00)(\D|$)/</span>, <span class="string">'d100\2'</span>).<br />                   gsub(<span class="string">/d(\d+)/</span>, <span class="string">'d(\1)'</span>).<br />                   gsub(<span class="string">/(\d+|\))d/</span>, <span class="string">'\1.d'</span>).<br />                   gsub(<span class="string">/\d+/</span>) { <span class="global">$&</span>amp;.gsub(<span class="string">/^0+/</span>, <span class="string">''</span>) }<br /><br />       <span class="variable">@dice</span> = eval <span class="string">"lambda { #@src }"</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>(I've left out a bit of error checking; see the full solution to see everything.)  The first substitution fixes up percentage and double-zero values as 100. The second turns 'd' as a binary operator into 'd' as a method call. The third substitution provides the default dice count of 1 if it wasn't specified. And the last substitution removes leading zeroes of integers; this last substitution prevents the Ruby from interpreting values as octal.</p>
			<p>The morphed expression is saved away in a lambda, which allows Christian to reevaluate the expression repeatedly without performing those substitutions every time roll is called.</p>
			<p>There were several variations of the eval method solution, mostly in the regular expression substitutions. A couple variations rewrote existing operators (rather than adding new methods to Integer or Fixnum). Rather than change the 'd' operator into a method call, he made a slightly different twist and rolled the dice in method_missing. Perhaps Bill didn't know that classes could be extended, or maybe he was hacking around for fun. Dennis Ranke had a eval-looking solution with no eval to be found, because the gsub calls actually substituted the results during parsing.  And Stefan Walk wins for the shortest solution: three lines of hard to read Ruby code.</p>
			<p>The second class of solutions involved using a parsing library or parser generator tool. Three of these showed up: Pierre Barbier de Reuille used racc, Austin Ziegler used syntax.rb, and David Tran pulled out ANTLR to generate his parser. Each of these will let you describe your language in BNF format, or something quite similar to it, and it will generate a Ruby language parser for you. These can be quite powerful solutions, although readability of the language specification and the support code varies widely. But I do recommend looking into these tools if you have need to do something more powerful than dice expressions; generating a complex parser with one of these would save much time and effort over a handcoded solution.</p>
			<p>And now we're at the third class of solutions: the handcrafted parsers. About nine people handcrafted parsers, mostly recursive descent which is rather easy to code. Because these generally involve more code, I won't show much, but I suggest taking a look at some of them.</p>
			<p>Dominik Bathon's solution, while it prefers to use the eval method as it goes along rather than build a parse tree, is a easy to read solution and makes good use of StringScanner. Morus Walter's solution is decent to follow and understand and builds up an expression tree with his Expr class, which gets evaluated at the end with a single call to roll. My own solution is similar, but creates a tree of proc objects.  Andrew McGuinness and Christer Nilsson also have recursive descent parsers that can not only roll dice, but calculation frequency distributions and histograms, and cheat.</p>
			<p>I want to look now at a couple of standouts.  First, let's look at Dennis Ranke's second submission. It's a recursive descent parser, contained in his class RDParser which is included with the submission but a little too long to summarize here. However, what RDParser has done is allow Dennis to write this solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    parser = RDParser.new <span class="keyword">do</span><br />      token(<span class="string">/\s+/</span>)<br />      token(<span class="string">/\d+/</span>) {|m| m.to_i }<br />      token(<span class="string">/./</span>) {|m| m }<br /><br />      start :expr <span class="keyword">do</span><br />        match(:expr, <span class="string">'+'</span>, :term) {|a, _, b| a + b }<br />        match(:expr, <span class="string">'-'</span>, :term) {|a, _, b| a - b }<br />        match(:term)<br />      <span class="keyword">end</span><br /><br />      rule :term <span class="keyword">do</span><br />        match(:term, <span class="string">'*'</span>, :dice) {|a, _, b| a * b }<br />        match(:term, <span class="string">'/'</span>, :dice) {|a, _, b| a / b }<br />        match(:dice)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> roll(times, sides)<br />        (1..times).inject(0) {|a, b| a + rand(sides) + 1 }<br />      <span class="keyword">end</span><br /><br />      rule :dice <span class="keyword">do</span><br />        match(:atom, <span class="string">'d'</span>, :sides) {|a, _, b| roll(a, b) }<br />        match(<span class="string">'d'</span>, :sides) {|_, b| roll(1, b) }<br />        match(:atom)<br />      <span class="keyword">end</span><br /><br />      rule :sides <span class="keyword">do</span><br />        match(<span class="string">'%'</span>) { 100 }<br />        match(:atom)<br />      <span class="keyword">end</span><br /><br />      rule :atom <span class="keyword">do</span><br />        match(Integer)<br />        match(<span class="string">'('</span>, :expr, <span class="string">')'</span>) {|_, a, _| a }<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Do I need to say how beautiful that is? It's short, clean, easy to read and understand...  and all Ruby. Package that RDParser into a module and ship it! I think I've found my next parsing tool...</p>
			<p>Let's look at the guts of one more solution, by Pablo Hoch. Pablo's solution didn't exactly fit into the other classes of solution: it's somewhere between a parser and an eval-uator. He decided to take the infix dice expression and turn it into a RPN (Reverse Polish Notation, that is, postfix) expression:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> to_rpn(infix)<br />       stack, rpn, last = [], [], <span class="keyword">nil</span><br />       infix.scan(<span class="string">/\d+|[-+*\/()d%]/</span>) <span class="keyword">do</span> |token|<br />         <span class="keyword">case</span> token<br />           <span class="keyword">when</span> <span class="string">/\d+/</span><br />             rpn &lt;&lt; token<br />           <span class="keyword">when</span> <span class="string">'%'</span><br />             rpn &lt;&lt; <span class="string">"100"</span><br />           <span class="keyword">when</span> <span class="string">/[-+*\/d]/</span><br />             <span class="keyword">while</span> stack.any? &amp;&amp; stronger(stack.last, token)<br />               rpn &lt;&lt; stack.pop<br />             <span class="keyword">end</span><br />             rpn &lt;&lt; <span class="string">"1"</span> <span class="keyword">unless</span> last =~ <span class="string">/\d+|\)|%/</span><br />             stack &lt;&lt; token<br />           <span class="keyword">when</span> <span class="string">'('</span><br />             stack &lt;&lt; token<br />           <span class="keyword">when</span> <span class="string">')'</span><br />             <span class="keyword">while</span> (op = stack.pop) &amp;&amp; (op != <span class="string">'('</span>)<br />               rpn &lt;&lt; op<br />             <span class="keyword">end</span><br />         <span class="keyword">end</span><br />         last = token<br />       <span class="keyword">end</span><br />       <span class="keyword">while</span> op = stack.pop<br />         rpn &lt;&lt; op<br />       <span class="keyword">end</span><br />       rpn<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I love to see code that I can understand immediately, and also recognize how it could be useful for other applications. This is definitely one of those because postfix expressions (or prefix, to be complete) are a breeze for a computer to evaluate:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> roll<br />       stack = []<br />       <span class="variable">@expr</span>.each <span class="keyword">do</span> |token|<br />         <span class="keyword">case</span> token<br />           <span class="keyword">when</span> <span class="string">/\d+/</span><br />             stack &lt;&lt; token.to_i<br />           <span class="keyword">when</span> <span class="string">/[-+*\/d]/</span><br />             b = stack.pop<br />             a = stack.pop<br />             stack &lt;&lt; a.send(token.to_sym, b)<br />         <span class="keyword">end</span><br />       <span class="keyword">end</span><br />       stack.pop<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Thanks to everyone for the great submissions and lively discussion on the mailing list (and the correction to the quiz that I missed!).  I just hope when we all sit down to play that I don't see any of you with all characters stats of 18.</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174809">Paul Novak</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174810">Luke Blanshard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174811">Bill Kelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174812">Matthew Smillie</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174814">Andrew McGuinness</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174815">Ross Bamford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174820">Christer Nilsson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174821">Pierre Barbier de Reuille</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174824">Christian Neukirchen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174829">Austin Ziegler</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174837">Pablo Hoch</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174840">Dennis Ranke</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174842">Dennis Ranke (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174845">John Earles</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174859">Stefan Walk</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174877">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174889">Horndude77</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174912">Andrew McGuinness (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174945">Gustav Munkby</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/174968">Paul Novak (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/175005">Adam Shelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/175009">Gregory Seidman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/175204">Patrick Deuster</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/175078">Matthew Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/175116">Joby Bednar</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/175206">Morus Walter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/175173">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/254616">Lloyd Linklater</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/254617">Lloyd Linklater (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/254618">Lloyd Linklater (3)</a></li>
			</ol>
			<p><a href="quiz61_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
