<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Goedel (#147)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Goedel (#147)</span>
			<p>by Hugh Sasse</p>
			<p>In the book "Starburst" by Frederik Pohl ISBN 0-345-27537-3, page 56, without really spoiling the plot, some characters complain about the verbosity of communications and encode a message by Gödelizing it (detailed on page 58).</p>
			<p>The encoding works by taking each successive character of a message and raising each successive prime to some function of that character, and multiplying these powers of primes together. So for example we could use the ASCII code + 1 to allow for nulls to be encoded. Then "Ruby\n" would end up as:</p>
			<p class="example">(2 ** R) * (3 ** u) * (5 ** b)....<br /><br />10992805522291106558517740012022207329045811217010725353610920778<br />28664749233402453985379760678149866991742205982820039955872246774<br />86029159248495553882158351479922840433375701904296875000000000000<br />00000000000000000000000000000000000000000000000000000000000000000<br />000000</p>
			<p>The idea is partly to obscure the message by the amount of factorization needed. This quiz is to write a program to Gödelize a message, and a program to deGödelize it.</p>
			<p>The funtion used to map characters described in the book is "A" =&gt; 1, "B" =&gt; 2, etc and an example is given where spaces are 0. Nothing further is said about punctuation, or lower case. The message sent in the book is:</p>
			<p class="example">msg = (3.875 * (12 ** 26)) +<br />     (1973 ** 854) + (331 ** 852) +<br />     (17 ** 2008) + (3 ** 9707) + (2 ** 88) - 78</p>
			<p>which it turns out has lots of 0 powers in it, so I strictly don't need the ASCII + 1 I've used in my example, I could use just ASCII, and the nulls would not increase the size of the resulting number. This further means that if a list of characters is sent in decreasing frequency order with the message, the most frequent could be encoded as 0 and the number would be that much smaller. In English it is likely to be an "e" or " " which ends up coded as 0.</p>
			<p>Interesting things arising from this:</p>
			<p class="example">1 Finding the power once a prime is selected<br />2 Getting the list of primes in the first place<br />3 encoding of characters, as mentioned above<br />4 representing the number that results from encoding.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>This quiz is really just an optimization problem.  It's pretty trivial to do a conversion to and from a Goedel number.  See Eric Lavigne's under-30-lines solution for a great example of this.  The challenge arises when the message gets big enough that finding all of the factors takes significant time.</p>
			<p>Eric I. figured out how to cut quite a few corners on the decoding process, so I want to take a look at his code.</p>
			<p>Before we get into the actual encoding and decoding process though, let's talk a bit about primes.  Obviously, we need a source of prime numbers to do our work.  Ruby does ship with a standard mathn library that includes a Prime class.  Many solutions did put that library to good use.  There are two downsides to that approach though:  mathn is a pure Ruby library and the Prime class implementation in Ruby 1.8 is not very clever.  Both of these slow us down.</p>
			<p>To get around that, Eric built a drop-in replacement for the Prime class that cheats.  It simply reads the numbers from a huge list you can download, skipping any calculation effort.  This turns out to be faster for our needs.  Here's the code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Generates a stream of prime numbers as they're read from a sequence</span><br />    <span class="comment"># of files with names such as "primes1.txt", "primes2.txt", and so</span><br />    <span class="comment"># forth.  Such files can be downloaded from:</span><br />    <span class="comment">#   http://primes.utm.edu/lists/small/millions/</span><br /><br />    <span class="keyword">class</span> Prime<br />      <span class="keyword">def</span> initialize<br />        <span class="variable">@current_file</span> = 0<br />        <span class="variable">@io</span> = open_next_file<br />        <span class="variable">@current_primes</span> = []<br />        <span class="variable">@current_index</span> = 0<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> <span class="keyword">next</span><br />        load_next_primes <span class="keyword">until</span> value = <span class="variable">@current_primes</span>[<span class="variable">@current_index</span>]<br />        <span class="variable">@current_index</span> += 1<br />        value<br />      <span class="keyword">end</span><br /><br />      private<br /><br />      <span class="keyword">def</span> load_next_primes<br />        <span class="keyword">while</span> <span class="keyword">true</span><br />          <span class="keyword">while</span> line = <span class="variable">@io</span>.gets<br />            <span class="keyword">if</span> line =~ <span class="string">/^\s*\d+(\s+\d+)*\s*$/</span><br />              <span class="variable">@current_primes</span> = line.split.map { |e| e.to_i }<br />              <span class="variable">@current_index</span> = 0<br />              <span class="keyword">return</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />          <span class="variable">@io</span>.close<br />          open_next_file<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> open_next_file<br />        <span class="variable">@current_file</span> += 1<br />        filename = <span class="string">"primes%d.txt"</span> % <span class="variable">@current_file</span><br />        <span class="keyword">begin</span><br />          <span class="variable">@io</span> = open(filename)<br />        <span class="keyword">rescue</span><br />          raise <span class="string">"ran out of primes because couldn't open file \"%s\""</span> %<br />            filename<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>As you can see, this is simple stuff.  The class just opens a file called primes1.txt when initialize()d (see open_next_file()).  As needed, lines are read from this file, split() and converted into Integers, and tucked away inside an Array (see load_next_primes()).  Primes are then just handed out from this Array (see next()) and when the supply is exhausted new lines are read.  When we run out of lines, the code will move on to a primes2.txt file.</p>
			<p>The site linked to in the comment has the first 15 million primes available in files like this.  That more than covers the needs of this code, so this turns out to be a simple but effective cheat to save time.</p>
			<p>With a zippy Prime class defined, we are ready to get down to the real work:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'primes'</span>  <span class="comment"># or the standard mathn library</span><br /><br />    <span class="comment"># Put the coder in a separate class, so we have the potential to use</span><br />    <span class="comment"># other coders, such as the one from the Starburst novel.</span><br />    <span class="keyword">class</span> RubyQuizCoder<br />      <span class="keyword">def</span> encode(char)<br />        char[0] + 1<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> decode(number)<br />        (number - 1).chr<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> max_code<br />        127<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we see the require for the code that we just examined.  Note that this code will work fine with a mathn require as well though.</p>
			<p>The class defined here is the simple encoding described in the quiz.  As the comment indicates, pulling this code into the class makes it easy to swap out with other encoding schemes.</p>
			<p>The work horse methods for the solution are encode() and decode(), of course.  Here's the easy one:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">def</span> encode(input, primes, coder)<br />      goedel_value = 1<br /><br />      input.each_line <span class="keyword">do</span> |line|<br />        0.upto(line.size - 1) <span class="keyword">do</span> |i|<br />          char = line[i, 1]<br />          encoding = coder.encode char<br />          <span class="keyword">next</span> <span class="keyword">if</span> encoding.nil?  <span class="comment"># skip characters without encoding</span><br />          goedel_value *= primes.<span class="keyword">next</span> ** encoding<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      puts goedel_value<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The code works its way line by line and character by character through the input.  Each character is encoded using the RubyQuizCoder class we saw earlier, used as an exponent for a prime based on its position, and finally multiplied into the overall Goedel value.  When all of the characters have been dealt with, the overall value is printed as a result.</p>
			<p>The reverse operation is harder to digest, because it's where the optimizations are hiding:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># Attempt to decode quickly by trying to perfectly divide by</span><br />    <span class="comment"># prime**(2**6), prime**(2**5), prime**(2**4), ..., prime**(2**0) and</span><br />    <span class="comment"># then adding the powers of 2 for which the division worked without a</span><br />    <span class="comment"># remainder.  For example, if a number were divisible by prime**101,</span><br />    <span class="comment"># then it's also divisible by prime**64 * prime**32 * prime**4 *</span><br />    <span class="comment"># prime**1 since 64 + 32 + 4 + 1 = 101.  So, we'll have to divide the</span><br />    <span class="comment"># large number exactly 7 times per prime no matter what the exponent.</span><br />    <span class="comment"># Note: 7 assumes that the encoding results in no value greater than</span><br />    <span class="comment"># 127.</span><br />    <span class="keyword">def</span> decode(input, primes, coder)<br />      goedel_value = input.gets.to_i<br />      max_two_expnt = (Math.log(coder.max_code) / Math.log(2)).to_i<br />      factors = (0..max_two_expnt).map { |i| [2**i, <span class="keyword">nil</span>] }<br /><br />      <span class="keyword">while</span> goedel_value &gt; 1<br />        current_prime = primes.<span class="keyword">next</span><br />        encoded = 0<br /><br />        factors[0][1] = current_prime<br />        (1..max_two_expnt).each <span class="keyword">do</span> |i|<br />          factors[i][1] = factors[i - 1][1] ** 2<br />        <span class="keyword">end</span><br /><br />        factors.reverse_each <span class="keyword">do</span> |expnt, factor|<br />          quotient, remainder = goedel_value.divmod(factor)<br />          <span class="keyword">if</span> remainder == 0<br />            encoded += expnt<br />            goedel_value = quotient<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        char = coder.decode(encoded)<br />        putc char <span class="keyword">unless</span> char.nil?<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The biggest trick in here is the use of factorization to narrow down the divisions needed.  Until the overall value hits one, each prime is pulled in turn and factored into the possible divisors.  Each of those numbers is then tried in reverse order.  Those that divide evenly are added to the encoded character count and drop the overall count accordingly.  After all of the factors have been tried, the character count is passed through our RubyQuizCoder object and the resulting character is printed.</p>
			<p>This strategy results in a constant number of divisions for each character and in most cases, those divisions should be significantly less than the brute force approach.</p>
			<p>The rest of the code just provides an interface to these routines:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">def</span> usage<br />      STDERR.puts <span class="string">"Usage: %s -e[ncode]|-d[ecode] [file]"</span> % <span class="global">$0</span><br />      exit 1<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># process command-line args and figure out which method to call</span><br /><br />    task = <span class="keyword">nil</span><br />    input = <span class="keyword">nil</span><br />    ARGV.each <span class="keyword">do</span> |arg|<br />      <span class="keyword">case</span> arg<br />      <span class="keyword">when</span> <span class="string">/^-+e/</span>   : task = :encode<br />      <span class="keyword">when</span> <span class="string">/^-+d/</span>   : task = :decode<br />      <span class="keyword">else</span> <span class="keyword">if</span> input : usage<br />           <span class="keyword">else</span>       input = open(arg)<br />           <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    input = STDIN <span class="keyword">if</span> input.nil?<br />    primes = Prime.new<br />    coder = RubyQuizCoder.new<br /><br />    <span class="keyword">case</span> task<br />    <span class="keyword">when</span> :encode : encode(input, primes, coder)<br />    <span class="keyword">when</span> :decode : decode(input, primes, coder)<br />    <span class="keyword">else</span>           usage<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This is just some basic argument parsing code.  It hunts for a -e or -d switch to figure out if we are encoding or decoding.  It also opens a file of input for the first non-switch argument or defaults to STDIN.  Failing to select a mode or providing multiple input parameters triggers the usage message and an exit() call.  Otherwise, the selected routine is called with the input, a prime generator, and the coder.</p>
			<p class="example">356592611993533159357704171943707065506245018107843654420869995255779400<br />940327637098004636805658940369248254005741705095861927174094085632357462<br />907907043655503052325570584135928519171701028451925211424184061134912519<br />346213124822184698766352106671144335797309339814960788404357329829880747<br />370816749488671200451708065007982023372864606432786154466561150882383337<br />665739304198857199016703678239557259404453555953430721034149637848167371<br />696741427087919115033228735590823604859393603457456530272005167282069777<br />767057670186595718538513692305202904620672162211361327059254731120977063<br />134449493970743739621694338383775782689258152219852727482221819916188854<br />728922544056620806588370831318213885828889837200379775053853865140225412<br />662845287202726609004691108889366849057859320331241672049374448503639685<br />391414041859040062271216363732269502663137649053220830210776147948360695<br />030849925289805667675539825659032822205396840604174306471211962857755270<br />446984071785349996985198175348758225276208258987173267939423506126205306<br />366658339817220773597781191289736402029252868902666231417359731588146165<br />666320778680777303480755853750057521054497117887073508511901428397946093<br />449376833443738252027373639560059173037124844900113551258953525303486104<br />043722150604562552368672756555770801627883622940792114968157184742775843<br />032899157541783062241525730231786371568328435169052449375068965888786768<br />418148739617709373626622156165087821359521473101982925802046545744126160<br />160591686651704019368238740807898239650093187094408149981270808624486401<br />576666800438277327766454315294642692798530476745070050857038213692995319<br />240862517113963583832414299967798488646237585020392202957001143544708578<br />006399968115609032521439107622793677586436726234995703756213467526362754<br />053665223526567818472971465689078159087061330179433352620768373562074252<br />272173230499663950656487104976363578669988246793426315517241324669161225<br />95456614469899787029059315850805248000000000000000000000000000000000</p>
			<p>Tomorrow we will unreverse some backwards math...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279614">steve</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279616">Eric Lavigne</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279621">Eric Lavigne (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279623">Hugh Sasse</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279629">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279635">Eric Lavigne (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279647">Eric I.</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279650">Eric I. (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279656">Justin Ethier</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/279908">Phrogz</a></li>
			</ol>
			<p><a href="quiz147_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
