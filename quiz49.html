<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Lisp Game (#49)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Lisp Game (#49)</span>
			<p>There's been quite a bit of discussion lately about how much Ruby is and isn't like Lisp.  While I've known of Lisp for some time now, I have never really taken the time to play with it until just recently.  I started with this great tutorial:</p>
			<p><a href="http://www.lisperati.com/casting.html">Casting SPELs in Lisp</a></p>
			<p>Of course, just reading it didn't tell me all about the differences between Ruby and Lisp, so I decided to translate it to Ruby.  That taught me a lot, so I thought I would share.</p>
			<p>This week's Ruby Quiz is to translate the game built in the above tutorial into the equivalent Ruby.</p>
			<p>The tutorial is very interactive, so you should probably target irb as your platform.  (I did.)  Don't worry about the prose here, we're just translating the code from the tutorial.</p>
			<p>I would say there are probably two extremes for how this can be done.  You can basically choose a direct command-for-command translation or decide to keep the premise but translate the code to typical Ruby constructs.  I think there's merit to both approaches.  I took the direct translation route for instance, and I had to do a fair bit of thinking when I hit the section on Lisp's macros.  On the flip side, I think it would be great too wrap all the data in Ruby's objects and use the tutorial to show off concepts like Ruby's open class system.  So aim for whatever approach interests you.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I'm not going to show one entire solution this week, but instead try to hit some highlights from many.  We received a variety of solutions with impressive insights and downright scary hacks.  Let's take the tour.</p>
			<p class="example">Cleaning Up the Data</p>
			<p>The tutorials data format, a nested group of lists, may be very Lispish, but it's not how we do things in Rubyland.  Dominik Bathon did a subtle but effective translation that started with the definition of two simple Structs:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> TextAdventureEngine<br /><br />        Location = Struct.new(:description, :paths)<br />        Path     = Struct.new(:description, :destination)<br /><br />        <span class="comment"># ...</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Mix in a few Hashes and already the data has a lot more structure:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> WizardGame &lt; TextAdventureEngine<br /><br />        <span class="keyword">def</span> initialize<br />            <span class="variable">@objects</span> = [:whiskey_bottle, :bucket, :frog, :chain]<br /><br />            <span class="variable">@map</span> = {<br />                :living_room =&gt; Location.new(<br />                    <span class="string">"you are in the living-room of a wizard's house. "</span> +<br />                    <span class="string">"there is a wizard snoring loudly on the couch."</span>,<br />                    { :west =&gt; Path.new(<span class="string">"door"</span>, :garden),<br />                      :upstairs =&gt; Path.new(<span class="string">"stairway"</span>, :attic) }<br />                ),<br />                :garden =&gt; Location.new(<br />                    <span class="string">"you are in a beautiful garden. "</span> +<br />                    <span class="string">"there is a well in front of you."</span>,<br />                    {:east =&gt; Path.new(<span class="string">"door"</span>, :living_room)}<br />                ),<br />                :attic =&gt; Location.new(<br />                    <span class="string">"you are in the attic of the abandoned house. "</span> +<br />                    <span class="string">"there is a giant welding torch in the corner."</span>,<br />                    {:downstairs =&gt; Path.new(<span class="string">"stairway"</span>, :living_room)}<br />                )<br />            }<br /><br />            <span class="variable">@object_locations</span> = {<br />                :whiskey_bottle =&gt; :living_room,<br />                :bucket =&gt; :living_room,<br />                :chain =&gt; :garden,<br />                :frog =&gt; :garden<br />            }<br /><br />            <span class="variable">@location</span> = :living_room<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The rest of Dominik's translation came out quite nice and it's not a lot of code.  Do look it over.</p>
			<p>One thing I would really want to see in a Ruby version of this tutorial is the use of Ruby's open class system to slowly build up a data solution.  Kero's code was working on this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Area<br />      <span class="keyword">def</span> initialize(descr, *elsewhere)<br />        <span class="variable">@descr</span> = descr<br />        <span class="variable">@elsewhere</span> = elsewhere<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Area<br />      attr_reader :descr<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Area<br />      attr_reader :elsewhere<br />      <span class="keyword">def</span> Area::path(ary)<br />        <span class="string">"there is a #{ary[1]} going #{ary[0]} from here."</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Area<br />      <span class="keyword">def</span> paths<br />        elsewhere.collect {|path|<br />          Area::path path<br />        }<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I think that would be a great way to slowly unfold the tutorial.</p>
			<p>Kero also figured out the obvious way to eliminate the very first command in the tutorial, be sure to look that up.</p>
			<p class="example">Replacing the Macros</p>
			<p>The interesting part of the tutorial in question is when it begins using macros to redefine the interface.  In Lisp, that allows the tutorial to go from using code like:</p>
			<p class="example">(walk-direction 'west)</p>
			<p>To:</p>
			<p class="example">(walk west)</p>
			<p>Of course, Ruby doesn't have macros.  (That's the discussion that inspired this quiz!)  So, most of the people who solved it handled the interface with a different Ruby idiom.  The solution we'll examine here doesn't replace all instances of Lisp macro usage.  Different applications would require different Ruby idioms to deal with, but the moral (to me, anyway) is use the tools your language provides.  Macros are one of the things that make Lisp act like Lisp.  On the other hand, method_missing() is a Ruby tool:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> Kernel<br />      <span class="keyword">def</span> method_missing(method_id, *args)<br />        <span class="keyword">if</span> args.empty?<br />          method_id<br />        <span class="keyword">else</span><br />          [method_id] + args<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That's some code from Brian Schroeder's direct translation of the tutorial.  The key insight at work here is how Ruby would see a line like:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    walk west<br /><br /></div></div>
			<p>The answer is:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    walk( west())<br /><br /></div></div>
			<p>Now we can understand Brian's method_missing() hack.  If a method isn't defined, like west(), method_missing() will be called and Brian just has it return the method name, so other methods will get it as an argument.  In other words, the above call sequence is simplified to:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    walk( :west)<br /><br /></div></div>
			<p>The walk() method is defined and knows how to handle a :west parameter.</p>
			<p>The second half of method missing does one more trick.  To understand it, we need to look at a different example.  Imagine the following call sequence from later in the game:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    weld chain, bucket<br /><br /></div></div>
			<p>That will work as I've shown it, assuming weld() is a real method and knows what to do with a :chain and :bucket, because Ruby sees the call as:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    weld( chain(), bucket())<br /><br /></div></div>
			<p>Which we have already seen would get simplified to:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    weld( :chain, :bucket)<br /><br /></div></div>
			<p>Brian went one step further though and eliminated the comma:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    weld chain bucket<br /><br /></div></div>
			<p>Ruby sees that as:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    weld( chain( bucket()))<br /><br /></div></div>
			<p>The last call resolves as we have already seen:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    weld( chain( :bucket))<br /><br /></div></div>
			<p>But chain() is also handled by method_missing() and now it has an argument.  That's what the second part of method_missing() is for.  It adds the method name to the argument list and returns it, which leaves us with:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    weld( [:chain, :bucket])<br /><br /></div></div>
			<p>As long as weld() knows how to handle the Array, you can do without the comma.</p>
			<p>Brian uses a different set of Ruby tools, define_method() and instance_eval(), to replace the game action macro.  I'm not going to show it here in the interests of space and time, but do take a peek at the code.  It's fancy stuff.</p>
			<p class="example">A Warning</p>
			<p>Use a global method_missing() hack like the above, only when you really know what you are doing.  When we're just fooling with irb like this, it is pretty harmless, but it still tripped me up a few times.  Many Ruby errors are hidden under the rug when you define a global catch-all like this.  That can make it tough to bug hunt.</p>
			<p>Some solutions restricted the method_missing() hack to irb only and/or reduced the amount of things method_missing() was allowed to handle.  These are good cautionary measures to take, when using a hack like this.</p>
			<p class="example">Reversing the Problem</p>
			<p>A couple of people tried bringing Lisp to Ruby, instead of Rubifying Lisp.  Watch how irb is responding to Dave Burt's solution:</p>
			<p class="example">irb(main):001:0&gt; require 'lisperati'<br />(YOU ARE IN THE LIVING_ROOM OF A WIZARDS HOUSE. THERE IS A WIZARD SNORING <br />LOUDLY ON THE COUCH. THERE IS A DOOR GOING WEST FROM HERE. THERE IS A <br />STAIRWAY GOING UPSTAIRS FROM HERE. YOU SEE A WHISKEY_BOTTLE ON THE FLOOR. <br />YOU SEE A BUCKET ON THE FLOOR.)<br />=&gt; true<br />irb(main):002:0&gt; pickup bucket<br />=&gt; (YOU ARE NOW CARRYING THE BUCKET)<br />irb(main):003:0&gt; walk west<br />=&gt; (YOU ARE IN A BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU. THERE IS <br />A DOOR GOING EAST FROM HERE. YOU SEE A FROG ON THE FLOOR. YOU SEE A CHAIN ON <br />THE FLOOR.)<br />irb(main):004:0&gt; inventory[]<br />=&gt; (BUCKET)</p>
			<p>I can't decide if that's unholy or not, but it sure is cool.  Here's the code Lispifying the Arrays:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Array<br />      <span class="keyword">def</span> inspect  <span class="comment"># (JUST FOR FUN, MAKE ARRAYS LOOK LIKE LISP LISTS)</span><br />        <span class="string">'('</span> + map{|x| x.upcase }.join(<span class="string">" "</span>) + <span class="string">')'</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>One simple override on inspect() gives us Lisp style output.  Yikes.</p>
			<p>There's more Lisp goodness hiding in Dave's code, so be sure and give it a look.</p>
			<p>Daniel Sheppard also took a very Lispish approach, building a Lisp interpreter and then feeding in the Lisp code directly from the web site:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'lisp'</span><br /><br />    lisp = Object.new<br />    lisp.extend(Lisp)<br />    lisp.extend(Lisp::StandardFunctions)<br /><br />    require <span class="string">'open-uri'</span><br />    require <span class="string">'fix_proxy.rb'</span><br /><br />    open(<span class="string">"http://www.lisperati.com/code.html"</span>) { |f|<br />        input = f.readlines.join.gsub(<span class="string">/&lt;[^&gt;]*&gt;/</span>, <span class="string">""</span>)<br />        <span class="comment">#puts input</span><br />        lisp.lisp(input)<br />    }<br /><br />    commands = [<br />        [ <span class="string">"(pickup whiskey-bottle)"</span>,<br />          <span class="string">"(YOU ARE NOW CARRYING THE WHISKEY-BOTTLE)"</span> ]<br />    ]<br />    open(<span class="string">"http://www.lisperati.com/cheat.html"</span>) { |f|<br />        f.each { |line|<br />            line.chomp!<br />            line.gsub!(<span class="string">"&lt;br&gt;"</span>,<span class="string">""</span>)<br />            <span class="keyword">if</span> <span class="string">/^&gt;(.*)/</span> === line<br />                line = <span class="global">$1</span><br />                line.gsub!(<span class="string">"Walk"</span>, <span class="string">"walk"</span>) <span class="comment">#bug in input</span><br />                commands &lt;&lt; [line, <span class="string">""</span>]<br />            <span class="keyword">else</span><br />                <span class="comment">#bugs in input</span><br />                line.gsub!(<span class="string">"WIZARDS"</span>, <span class="string">"WIZARD'S"</span>)<br />                line.gsub!(<span class="string">"ATTIC OF THE WIZARD'S"</span>, <span class="string">"ATTIC OF THE ABANDONED"</span>)<br />                commands[-1][1] &lt;&lt; line<br />            <span class="keyword">end</span><br />        }<br />    }<br />    commands.each <span class="keyword">do</span> |c|<br />        puts c[0]<br />        result = lisp.lisp(c[0])<br />        result = result.to_lisp.upcase<br />        <span class="keyword">unless</span> result == c[1]<br />            puts <span class="string">"Wrong!"</span><br />            p result<br />            p c[1]<br />            <span class="keyword">break</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Here you can see that openuri is used to load pages from the tutorial site, which are parsed for code and fed straight to the Lisp interpreter.  I must admit that I never expected to see a solution like that!</p>
			<p>I won't show the lisp.rb file here in the interests of time and space, but hopefully the above has you curious enough to take a peek on your own.  You won't be sorry you did.</p>
			<p class="example">Domain Specific Languages (DSLs)</p>
			<p>I'm told Jim Weirich is giving a talk on DSLs at RubyConf, and I believe he actually intends to use this very problem area to discuss them.  Some of you have a head start on that now.</p>
			<p>Both Jim Menard and Sean O'Halpin sent in the beginning of text adventure frameworks for Ruby.  Their goal seemed to be to create reasonable syntax for using Ruby in the creation of such games and there are interesting aspects to each approach.</p>
			<p>Let's look at a little bit of Sean's code first:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Game definition</span><br /><br />    game <span class="string">"Ruby Adventure"</span> <span class="keyword">do</span><br /><br />      directions :east, :west, :north, :south, :up, :down,<br />                 :upstairs, :downstairs<br /><br />      room :living_room <span class="keyword">do</span><br />        name        <span class="string">'Living Room'</span><br />        description <span class="string">"You are in the living-room of a wizard's house. "</span> +<br />                    <span class="string">"There is a wizard snoring loudly on the couch."</span><br />        exits :west     =&gt; [:door, :garden],<br />              :upstairs =&gt; [:stairway, :attic]<br />      <span class="keyword">end</span><br /><br />      room :garden <span class="keyword">do</span><br />        name        <span class="string">'Garden'</span><br />        description <span class="string">"You are in a beautiful garden. "</span> +<br />                    <span class="string">"There is a well in front of you."</span><br />        exits :east =&gt; [:door, :living_room]<br />      <span class="keyword">end</span><br /><br />      room :attic <span class="keyword">do</span><br />        name <span class="string">"Attic"</span><br />        description <span class="string">"You are in the attic of the wizard's house. "</span> +<br />                    <span class="string">"There is a giant welding torch in the corner."</span><br />        exits :downstairs =&gt; [:stairway, :living_room]<br />      <span class="keyword">end</span><br /><br />      thing :whiskey_bottle <span class="keyword">do</span><br />        name <span class="string">'whiskey bottle'</span><br />        description <span class="string">'half-empty whiskey bottle'</span><br />        location :living_room<br />      <span class="keyword">end</span><br /><br />      thing :bucket <span class="keyword">do</span><br />        name <span class="string">'bucket'</span><br />        description <span class="string">'rusty bucket'</span><br />        location :living_room<br />      <span class="keyword">end</span><br /><br />      thing :chain <span class="keyword">do</span><br />        name <span class="string">'chain'</span><br />        description <span class="string">'sturdy iron chain'</span><br />        location :garden<br />      <span class="keyword">end</span><br /><br />      thing :frog <span class="keyword">do</span><br />        name <span class="string">'frog'</span><br />        description <span class="string">'green frog'</span><br />        location :garden<br />      <span class="keyword">end</span><br /><br />      start :living_room<br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Interesting use of blocks and method calls there, isn't it?  What's really neat is that under the hood this is a fully object oriented system.  The method calls just simplify it for you.  Have a look at the game() method implementation, for example:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> game(name, &amp;block)<br />      g = Game.new(name, &amp;block)<br />      g.look<br />      g.main_loop<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I love this synthesis of Ruby objects with trivial interface code.</p>
			<p>Going a step further, it should be possible to derive the name() attribute from the Symbol parameter to room() and thing(), shaving off some more redundancy.</p>
			<p>As you can see, these method don't quite use the typical Ruby syntax.  Why is it `name 'frog'` and not `name = 'frog'`, for example?  The reason is that the blocks in this code are instance_eval()ed, to adjust self for the call.  Unfortunately, because of the way Ruby syntax is interpreted, `name = 'frog'` would be assumed to be a local variable assignment instead of a method call.  That forced Sean to use this more Perlish syntax.</p>
			<p>To follow up on that, let's see how those attribute methods are implemented:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> GameObject<br />      extend Attributes<br />      has :identifier, :name, :description<br />      <span class="keyword">def</span> initialize(identifier, &amp;block)<br />        <span class="variable">@identifier</span> = identifier<br />        instance_eval &amp;block<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Thing &lt; GameObject<br />      has :location<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Room &lt; GameObject<br />      has :exits<br /><br />      <span class="keyword">def</span> initialize(identifier, &amp;block)<br />        <span class="comment"># put defaults before super - they will be overridden in block</span><br />        <span class="comment"># (if at all)</span><br />        <span class="keyword">super</span><br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Looks like we need to see the magic has() method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> Attributes<br />      <span class="keyword">def</span> has(*names)<br />        <span class="keyword">self</span>.class_eval {<br />          names.each <span class="keyword">do</span> |name|<br />            define_method(name) {|*args|<br />              <span class="keyword">if</span> args.size &gt; 0<br />                instance_variable_set(<span class="string">"@#{name}"</span>, *args)<br />              <span class="keyword">else</span><br />                instance_variable_get(<span class="string">"@#{name}"</span>)<br />              <span class="keyword">end</span><br />              }<br />          <span class="keyword">end</span><br />          }<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Notice that the defined attribute methods have different behavior depending on the presence of any arguments in their call.  Omit the arguments and you're calling a getter.  Add an argument to set the attribute instead.</p>
			<p>For more typical Ruby idioms, we turn to Jim's code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'rads'</span><br /><br />    <span class="global">$world</span>.player.names = [<span class="string">'me'</span>, <span class="string">'myself'</span>]<br />    <span class="global">$world</span>.player.long_desc = <span class="string">'You look down at yourself. Plugh.'</span><br /><br />    living_room = Room.new(:living_room) { | r |<br />      r.short_desc = <span class="string">"The living room."</span><br />      r.names = [<span class="string">'living room'</span>, <span class="string">'parlor'</span>]<br />      r.long_desc = <span class="string">"You are in the living-room of a wizard's house."</span><br />      r.west :garden, <span class="string">"door"</span><br />      r.up :attic, <span class="string">"stairway"</span><br />    }<br /><br />    wizard = Decoration.new { | o |<br />      o.location = living_room<br />      o.short_desc = <span class="string">'There is a wizard snoring loudly on the couch.'</span><br />      o.names = <span class="string">%w(wizard)</span><br />      o.long_desc = <span class="string">"The wizard's robe and beard are unkempt. He sleeps "</span> +<br />                    <span class="string">"the sleep of the dead. OK, the sleep of the really, "</span> +<br />                    <span class="string">"really sleepy."</span><br />    }<br /><br />    <span class="comment"># ...</span><br /><br />    whiskey_bottle = Thing.new { | o |<br />      o.location = living_room<br />      o.short_desc = <span class="string">"whiskey bottle"</span><br />      o.names = [<span class="string">'whiskey bottle'</span>, <span class="string">'whiskey'</span>, <span class="string">'bottle'</span>]<br />      o.long_desc = <span class="string">"A half-full bottle of Old Throat Ripper. The label "</span> +<br />                    <span class="string">"claims it's \"the finest whiskey sold\" and warns "</span> +<br />                    <span class="string">"that \"mulitple applications may be required for "</span> +<br />                    <span class="string">"more than three layers of paint\"."</span><br />    }<br /><br />    bucket = Container.new { | o |<br />      o.location = living_room<br />      o.short_desc = <span class="string">"bucket"</span><br />      o.long_desc = <span class="string">"A wooden bucket, its bottom damp with a slimy sheen."</span><br />    }<br /><br />    <span class="comment"># ...</span><br /><br />    <span class="global">$chain_welded</span> = <span class="keyword">false</span><br />    <span class="global">$bucket_filled</span> = <span class="keyword">false</span><br /><br />    <span class="keyword">class</span> &lt;&lt; <span class="global">$world</span><br /><br />      <span class="keyword">def</span> have?(obj)<br />        obj.location == player<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ================================================================</span><br /><br />    startroom living_room<br /><br />    play_game<br /><br /></div></div>
			<p>In that code you can see Rooms being built, Decorations added, Things created and even custom methods added to the $world.  If you have any experience with Interactive Fiction (IF--a fancy name for these text adventure game), this declarative style code is probably looking pretty familiar.</p>
			<p>Jim went so far as to do a minimal port of TADS (Text ADventure System).  You can see the Ruby version, RADS, pulled in on the first line.</p>
			<p>The main difference you see here is the use of object constructors and that the blocks are passed the objects to configure, allowing the use of standard Ruby attribute methods.</p>
			<p>Both solutions are very interesting and worth digging deeper into, when you have some time.</p>
			<p class="example">Wrap Up</p>
			<p>Just because I didn't mention a solution does not mean it wasn't interesting, especially this week.  A lot of code came in and there were great tidbits all around.  If you want to learn the great Ruby Voodoo, start reading now!</p>
			<p>Thanks so much to all who played with this problem or even just discussed variations on Ruby Talk.  As always, you taught me a lot.</p>
			<p>Tomorrow's Ruby Quiz:  Automated ASCII Art...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158638">Jim Menard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158643">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158719">Markus Koenig</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158731">Brian Schr&ouml;der</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158733">Gregory Brown</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158740">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158768">soxinbox</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158870">Adam Shelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158886">Louis J Scoras</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158900">Edward Faulkner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158902">Sean O'Halpin</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/158911">Mark J.Reed</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159004">daz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159098">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159110">Daniel Sheppard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159206">Kero</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159263">Daniel Sheppard (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/159275">Sean O'Halpin (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/167848">Leslie Viljoen</a></li>
			</ol>
			<p><a href="quiz49_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
