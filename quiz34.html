<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Whiteout (#34)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Whiteout (#34)</span>
			<p>Perl programmers have all the fun.  They have an entire section of the CPAN devoted to their playing around.  The ACME modules are all fun little toys that have interesting if rarely very useful effects.</p>
			<p>This week's Ruby Quiz is to port ACME::Bleach to Ruby.  I won't make you go hunting through the CPAN to figure it out though.  Here's how our version will work:</p>
			<p class="example">1.  Make a Ruby file that is both an executable and a library.  We'll call<br />    it "whiteout".<br />2.  When "whiteout" is executed, it should take ARGV to be a list of Ruby<br />    source code files to alter in-place.  (You may save backup copies if you<br />    like, but the original file should be changed.)  Here are the changes:<br />    a.  A Shebang line, if present is to be passed through the filter<br />        without any changes.<br />    b.  The script should then add the line:  require "whiteout"<br />    c.  The entire rest of the file should be made invisible.  You might do<br />        this by converting the rest of the file to whitespace, as<br />        ACME::Bleach does.<br />3.  When "whiteout" is required, the original code must be executed with no<br />    change in functionality.</p>
			<p>Let's show those Perl guys that we know how to have a good time too!</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Does this library have any practical value?  Probably not.  It's been suggested in the Perl community that hacks like this are a good minor deterrent to those trying to read source code you would rather keep hidden, but it must be stressed that this is no form of serious security.  Regardless, it's a fun little toy to play with.</p>
			<p>It was mentioned in the discussion that Perl, where ACME::Bleach comes from, includes a framework for source filtering.  It can be used to make modules that modify source code much as we are doing in this quiz.  Perl's Switch.pm is a good example of this, but ironically ACME::Bleach is not.</p>
			<p>That naturally leads to the question, can you build source filters in Ruby?  Clearly we can build ACME::Bleach, but not all source filters are as simple I'm afraid.  Consider this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby -w</span><br /><br />    require <span class="string">"fix_my_broken_syntax"</span><br /><br />    invalid++<br /><br /></div></div>
			<p>Now the thought here is that fix_my_broken_syntax.rb will read my source, change it so that it does something valid, eval() it, and exit() before the invalid code is an issue.  Here's a trivial example of fix_my_broken_syntax.rb:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby -w</span><br /><br />    puts <span class="string">"Fixed!"</span><br />    exit<br /><br /></div></div>
			<p>Does that work?  Unfortunately, no:</p>
			<p class="example">$ ruby invalid.rb <br />invalid.rb:5: syntax error<br />invalid++<br />         ^</p>
			<p>Ruby never gets to loading the library, because it's not happy with the syntax of the first file.  That makes writing a source filter for anything that isn't valid Ruby syntax complicated and if it is valid Ruby syntax, you can probably just code it up in Ruby to begin with.</p>
			<p>Except for whiteout.rb, our version of ACME::Bleach.</p>
			<p>You can't build Ruby constructs out of whitespace alone, so some form of source filtering is required.  Luckily, we can get away with the approach described above for this source filter, because a bunch of whitespace (with no code) is valid Ruby syntax.  It just doesn't do anything.  Ruby will skip right over our whitespace and load the library that restores and runs the code.</p>
			<p>Most people took this approach.  Let's examine one such example by Robin Stocker:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/ruby</span><br /><br />    <span class="comment">#</span><br />    <span class="comment"># This is my solution for Ruby Quiz #34, Whiteout.</span><br />    <span class="comment"># Author::  Robin Stocker</span><br />    <span class="comment">#</span><br /><br />    <span class="comment">#</span><br />    <span class="comment"># The Whiteout module includes all functionality like:</span><br />    <span class="comment"># - whiten</span><br />    <span class="comment"># - run</span><br />    <span class="comment"># - encode</span><br />    <span class="comment"># - decode</span><br />    <span class="comment">#</span><br />    <span class="keyword">module</span> Whiteout<br /><br />      <span class="variable">@@bit_to_code</span> = { <span class="string">'0'</span> =&gt; <span class="string">" "</span>, <span class="string">'1'</span> =&gt; <span class="string">"\t"</span> }<br />      <span class="variable">@@code_to_bit</span> = <span class="variable">@@bit_to_code</span>.invert<br />      <span class="variable">@@chars_to_ignore</span> = [ <span class="string">"\n"</span>, <span class="string">"\r"</span> ]<br /><br />      <span class="comment">#</span><br />      <span class="comment"># Whitens the content of a file specified by _filename_.</span><br />      <span class="comment"># It leaves the shebang intact, if there is one.</span><br />      <span class="comment"># At the beginning of the file it inserts the require 'whiteout'.</span><br />      <span class="comment"># See #encode for details about how the whitening works.</span><br />      <span class="comment">#</span><br />      <span class="keyword">def</span> Whiteout.whiten( filename )<br />        code = <span class="string">''</span><br />        File.open( filename, <span class="string">'r'</span> ) <span class="keyword">do</span> |file|<br />          file.each_line <span class="keyword">do</span> |line|<br />            <span class="keyword">if</span> code.empty?<br />              <span class="comment"># Add shebang if there is one.</span><br />              code &lt;&lt; line <span class="keyword">if</span> line =~ <span class="string">/#!\s*.+/</span><br />              code &lt;&lt; <span class="string">"#{$/}require 'whiteout'#{$/}"</span><br />            <span class="keyword">else</span><br />              code &lt;&lt; encode( line )<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        File.open( filename, <span class="string">'w'</span> ) <span class="keyword">do</span> |file|<br />          file.write( code )<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>First, we can see that the module defines some module variables, which are really used as constants here.  Their contents hint at the encoding algorithm we'll see later.</p>
			<p>Then we have a method for managing the transformation of the source into whitespace.  It starts by opening the passed file and reading the code line-by-line.  If the first line is a shebang line, it's saved in the variable code.  Next, a "require 'whiteout'" line is added to code.  Finally, all other lines from the file are appended to code after being passed through an encode() method we'll examine shortly.  With the contents read and transformed, the method then reopens the source for writing and dumps the modifications into it.</p>
			<p>The next method is the reverse process:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment">#</span><br />      <span class="comment"># Reads the file _filename_, decodes and runs it through eval.</span><br />      <span class="comment">#</span><br />      <span class="keyword">def</span> Whiteout.run( filename )<br />        text = <span class="string">''</span><br />        File.open( filename, <span class="string">'r'</span> ) <span class="keyword">do</span> |file|<br />          decode = <span class="keyword">false</span><br />          file.each_line <span class="keyword">do</span> |line|<br />            <span class="keyword">if</span> <span class="keyword">not</span> decode<br />              <span class="comment"># We don't want to decode the "require 'whiteout'",</span><br />              <span class="comment"># so start decoding not before we passed it.</span><br />              decode = <span class="keyword">true</span> <span class="keyword">if</span> line =~ <span class="string">/require 'whiteout'/</span><br />            <span class="keyword">else</span><br />              text &lt;&lt; decode( line )<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="comment"># Run the code!</span><br />        eval text<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method again reads the passed file.  It skips over the "require 'whiteout'" line, then copies the rest of the file into the variable text, after passing it through decode() line-by-line.  The final line of the method calls eval() on text, which should now contain the restored program.</p>
			<p>On to encode() and decode():</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment">#</span><br />      <span class="comment"># Encodes text to "whitecode". It works like this:</span><br />      <span class="comment"># - Chars in @@char_to_ignore are ignored</span><br />      <span class="comment"># - Each byte is converted to its bit representation,</span><br />      <span class="comment">#   so that we have something like 01100001</span><br />      <span class="comment"># - Then, it is converted to whitespace according to @@bit_to_code</span><br />      <span class="comment"># - 0 results in a " " (space)</span><br />      <span class="comment"># - 1 results in a "\t" (tab)</span><br />      <span class="comment">#</span><br />      <span class="keyword">def</span> Whiteout.encode( text )<br />        white = <span class="string">''</span><br />        text.scan(<span class="string">/./</span>m) <span class="keyword">do</span> |char|<br />          <span class="keyword">if</span> <span class="variable">@@chars_to_ignore</span>.include?( char )<br />            white &lt;&lt; char<br />          <span class="keyword">else</span><br />            char.unpack(<span class="string">'B8'</span>).first.scan(<span class="string">/./</span>) <span class="keyword">do</span> |bit|<br />              code = <span class="variable">@@bit_to_code</span>[bit]<br />              white &lt;&lt; code<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> white<br />      <span class="keyword">end</span><br /><br />      <span class="comment">#</span><br />      <span class="comment"># Does the inverse of #encode, it takes "white"</span><br />      <span class="comment"># and returns the decoded text.</span><br />      <span class="comment">#</span><br />      <span class="keyword">def</span> Whiteout.decode( white )<br />        text = <span class="string">''</span><br />        char = <span class="string">''</span><br />        white.scan(<span class="string">/./</span>m) <span class="keyword">do</span> |code|<br />          <span class="keyword">if</span> <span class="variable">@@chars_to_ignore</span>.include?( code )<br />            text &lt;&lt; code<br />          <span class="keyword">else</span><br />            char &lt;&lt; <span class="variable">@@code_to_bit</span>[code]<br />            <span class="keyword">if</span> char.length == 8<br />              text &lt;&lt; [char].pack(<span class="string">"B8"</span>)<br />              char = <span class="string">''</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> text<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The comments in there detail the exact process we're looking at here, so I'm not going to repeat them.</p>
			<p>Note that @@char_to_ignore contains "\n" and "\r" so they are not translated.  The effect of that is that line-endings are untouched by this conversion.  Some solutions used such characters in their encoding algorithm.  The gotcha there is that any line-ending translation done to the modified source (say FTP through ASCII mode) will break the hidden code.  Robin's solution doesn't have that problem.</p>
			<p>Here's the code that ties all those methods into a solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment">#</span><br />    <span class="comment"># And here's the logic part of whiteout.</span><br />    <span class="comment"># If it was run directly, whites out the files in ARGV.</span><br />    <span class="comment"># And if it was required, decodes the whitecode and runs it.</span><br />    <span class="comment">#</span><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />      ARGV.each <span class="keyword">do</span> |filename|<br />        Whiteout.whiten( filename )<br />      <span class="keyword">end</span><br />    <span class="keyword">else</span><br />      Whiteout.run( <span class="global">$0</span> )<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Again, the comment saves me some explaining.</p>
			<p>That was Robin's first solution to a Ruby Quiz, but I never would have known that from looking at the code.  Thanks for sharing Robin!</p>
			<p>Obviously, a conversion of this type grossly inflates the size of the source.  Around eight times the size, to be exact.  A couple of solutions used zlib to control the expansion, which I thought was clever.  By compressing the source and then encoding() (and using a base three conversion) Dominik Bathom got results around three times the inflation instead.</p>
			<p>Ara.T.Howard took a different approach, using whiteout.rb as a database to store the trimmed files.  That was a very interesting process, demonstrated well in the submission email.  The advantages to this approach would be no inflation penalty and the code stays readable (just not in the original location).  The disadvantage I see is that it requires the exact same library to be present both at encoding and decoding, which probably makes sharing the altered code impractical.</p>
			<p>As always, my thanks to all who gave this little diversion an attempt.  I'm sure we'll see tons of whitespace only code on RubyForge in the future, thanks to our efforts.</p>
			<p>Tomorrow begins part one of our first two-part Ruby Quiz.  Stay tuned...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144607">Robin Stocker</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144608">Ryan Leavengood</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144611">Christian Neukirchen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144616">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144622">Ara.T.Howard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144623">Bill Atkins</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144629">Brain Schr&ouml;der</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144652">Dominik Bathom</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144657">Matthew D Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/144749">Matthew D Moss (2)</a></li>
			</ol>
			<p><a href="quiz34_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
