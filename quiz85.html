<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - C-Style Ints (#85)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">C-Style Ints (#85)</span>
			<p>by Aaron Patterson</p>
			<p>Write a class that can represent a signed or unsigned number with an arbitrary number of bits.  This class should support all bitwise operations ( &amp; ^ ~ | ), basic math operations ( + - / * ), and comparison operators.  It would behave like an integer in C (except with arbitrary length!), so an unsigned int 0xFFFFFFFF + 1 would equal 0x00000000.</p>
			<p>One edge case is what to do in an overflow case ( see the first irb session number 2 ).  Another is how to handle numbers that are wider than the specified number of bits.  I'm not really sure how to handle that part, but what I do is just take the last N number of bits.  So if 0xFFEE was passed in to my 8 bit vector, I would just take 0xEE.</p>
			<p class="example">Example irb sessions</p>
			<p>Here is an example of using an 8 bit unsigned int with an initial value of 0xFF:</p>
			<p class="example">irb(main):001:0&gt; n = UnsignedFixedWidthInt.new(0xFF, 8)<br />=&gt; 255<br />irb(main):002:0&gt; n += 2<br />=&gt; 1<br />irb(main):003:0&gt; n = n &lt;&lt; 1<br />=&gt; 2<br />irb(main):004:0&gt; n = n &gt;&gt; 1<br />=&gt; 1<br />irb(main):005:0&gt; ~n<br />=&gt; 254<br />irb(main):006:0&gt; n += 12<br />=&gt; 13<br />irb(main):007:0&gt; n = n &amp; 0x0E<br />=&gt; 12<br />irb(main):008:0&gt;</p>
			<p>Now an example of an 8 bit signed int with an initial value of 0x01:</p>
			<p class="example">irb(main):001:0&gt; n = SignedFixedWidthInt.new(0x01, 8)<br />=&gt; 1<br />irb(main):002:0&gt; n = n &lt;&lt; 7<br />=&gt; -128<br />irb(main):003:0&gt; n -= 1<br />=&gt; 127<br />irb(main):004:0&gt; n = n &gt;&gt; 6<br />=&gt; 1<br />irb(main):005:0&gt; n -= 2<br />=&gt; -1<br />irb(main):006:0&gt; n = n ^ 0xF3<br />=&gt; 12<br />irb(main):007:0&gt; n = n | 0x01<br />=&gt; 13<br />irb(main):008:0&gt;</p>
			<p>Here is an example of handling numbers that are too wide:</p>
			<p class="example">irb(main):001:0&gt; n = UnsignedFixedWidthInt.new(0x0, 8)<br />=&gt; 0<br />irb(main):002:0&gt; n += 0xFFEE<br />=&gt; 238<br />irb(main):003:0&gt;</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>There was quite a bit of confusion over what we were after in the quiz.  Ironically, I think that's all my fault for giving the author's simple quiz the name "C-Style Ints."  Things are always complicated when you drag C into them and some solvers bent over backwards to dissect C's behavior.  Luckily, that lead to some cool solutions for us to examine.</p>
			<p>One way to tackle this problem is to rebuild all the needed math operations.  That leads to quite a bit of code like this excerpt from Hank Lords's submission:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> UFWI<br />     include Comparable<br /><br />     attr_reader :width<br /><br />     <span class="keyword">def</span> initialize(int=0, width=8)<br />       <span class="keyword">if</span> block_given?<br />         <span class="variable">@width</span> = int<br />         <span class="variable">@bits</span> = Array.new(<span class="variable">@width</span>) {|index| Bit.new(<span class="keyword">yield</span>( index)) }<br />       <span class="keyword">else</span><br />         <span class="variable">@width</span> = width<br />         <span class="variable">@bits</span> = Array.new(<span class="variable">@width</span>) {|bit| Bit.new(int.to_i &gt;&gt; bit) }<br />       <span class="keyword">end</span><br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> to_i<br />       <span class="variable">@bits</span>.reverse.inject(0) {|num, bit| (num &lt;&lt; 1) + bit.to_i}<br />     <span class="keyword">end</span><br />     <span class="keyword">alias</span> :to_int :to_i<br /><br />     <span class="keyword">def</span> coerce(*args)<br />       to_int.coerce(*args)<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> &amp;(cint)<br />       a = <span class="keyword">self</span>.<span class="keyword">class</span>.new(cint, width)<br />       <span class="keyword">self</span>.<span class="keyword">class</span>.new(width) {|bit| <span class="variable">@bits</span>[bit] &amp; a[bit] }<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> / (cint)<br />       <span class="comment"># Binary euclidian division</span><br /><br />       b = <span class="keyword">self</span>.<span class="keyword">class</span>.new(cint, width)<br />       raise DivisionByZero <span class="keyword">if</span> b == 0<br />       b0 = <span class="keyword">self</span>.<span class="keyword">class</span>.new(1, width)<br />       width.times {<br />         <span class="keyword">break</span> <span class="keyword">if</span> <span class="keyword">self</span> &lt; b0*b<br />         b0 &lt;&lt;= 1<br />       }<br />       a0 = b0 &gt;&gt; 1<br /><br />       <span class="keyword">while</span> b0 - a0 &gt; 1 <span class="keyword">do</span><br />         c = (a0 &gt;&gt; 1) + (b0 &gt;&gt; 1)<br />         <span class="keyword">if</span> c * b &lt;= <span class="keyword">self</span><br />           a0 = c<br />         <span class="keyword">else</span><br />           b0 = c<br />         <span class="keyword">end</span><br />       <span class="keyword">end</span><br />       a0<br />     <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Obviously, I'm showing only a couple of operations here and you can see that this code uses a Bit class (not shown).  Hank did the work by teaching Ruby to work with ordinary bits and then building the needed number operations on top of that framework.  You can see the numbers being constructed as an Array of Bits in initialize(), either from a provided integer or using a block to generate the bits iteratively.</p>
			<p>The next couple of methods allow these numbers to be used in math operations with Ruby's native numbers.  The first step is to provide a conversion for this UFWI to a normal Ruby Integer.  Once we have that, a coerce() method is defined which Ruby uses to resolve numerical operations with custom objects.  This version just converts our UFWI to a normal Integer, then delegates the call to the built-in coerce().</p>
			<p>Finally, I've left in two example operations.  You can see that Hank resolves these operations using handle-rolled bit math.  In some cases (like &amp;()), this can be done trivially, but others (like /()) get a little complicated.  Hank did a top notch job creating all the needed operations.  I've just left them out here to keep this summary reasonably small.</p>
			<p>Hank's solution is solid, but it took a lot of work to create.  What we really want to do is to get Ruby to do as much of that work for us as humanly possible.  Many quiz solvers found ways to do this.  Here's a lovely version by Boris Prinz:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> UnsignedFixedWidthInt<br />      <span class="keyword">def</span> initialize(value, bits)<br />        raise ArgumentError.new(<span class="string">'number of bits must be &gt; 0'</span>) <span class="keyword">if</span> bits &lt;= 0<br />        <span class="variable">@bits</span>  = bits<br />        <span class="variable">@value</span> = value % 2**<span class="variable">@bits</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># operators returning a new FixedWidthInt</span><br />      <span class="string">%w{&amp; ^ | &lt;&lt; &gt;&gt; + - * / +@ -@ ~@}</span>.each <span class="keyword">do</span> |operator|<br />        define_method operator <span class="keyword">do</span> |*other|<br />          <span class="keyword">self</span>.<span class="keyword">class</span>.new(<span class="variable">@value</span>.send(operator, *other), <span class="variable">@bits</span>)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># methods forwarded to @value</span><br />      <span class="string">%w{== &lt; &gt; &lt;=&gt; inspect to_s to_i to_int}</span>.each <span class="keyword">do</span> |meth|<br />        define_method meth <span class="keyword">do</span> |*other|<br />          <span class="variable">@value</span>.send(meth, *other)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> coerce(other)<br />        Integer == other ? [other, <span class="variable">@value</span>] : [Float(other), Float(<span class="variable">@value</span>)]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> SignedFixedWidthInt &lt; UnsignedFixedWidthInt<br />      <span class="keyword">def</span> initialize(value, bits)<br />        <span class="keyword">super</span>(value, bits)<br />        <span class="comment"># value is negative if MSB is set:</span><br />        <span class="variable">@value</span> -= 2**<span class="variable">@bits</span> <span class="keyword">if</span> <span class="variable">@value</span>[<span class="variable">@bits</span> - 1] == 1<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>With this example, the majority of the work is done in the initialize() methods of UnsignedFixedWidthInt and SignedFixedWidthInt.  They simply store the bit width and numerical value for future use.  It the passed number is larger than the indicated width, it is truncated at this time.  The SignedFixedWidthInt adds a check for the sign bit and negates the number when set.</p>
			<p>Next Boris uses a little metaprogramming to quickly define a bunch of similar math operations.  These methods just delegate to the proper math method on the actual numerical object and hand the results back to the class constructor.  This insures that any result is truncated, if needed.</p>
			<p>Boris also uses the metaprogramming trick to define a handful of methods that return native Ruby types.  The end result is 20 method definitions in just a few lines of code.  Very nice results.</p>
			<p>Finally, Boris does add the coerce() method, similar to Hank's code, so the new integer types can be used in math operation with normal Ruby numerical types.</p>
			<p>My thanks to all who took a stab at this quiz.  Sorry my naming of it made it seem more involved than intended.  Have a look at Daniel Martin's thorough C conversion for a great example of that solution path.</p>
			<p>Tomorrow we will try our luck with a panagram problem...  (I had to look that word up.)</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199757">John Baylor</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199815">Sander Land</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199894">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199895">Juergen Strobel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199898">Sander Land (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199907">Hank Lords</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199917">Boris Prinz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/199968">Dave Burt (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/200231">Daniel Martin</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/200272">Daniel Martin (2)</a></li>
			</ol>
			<p><a href="quiz85_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
