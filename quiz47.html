<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Ruby Jobs Site (#47)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Ruby Jobs Site (#47)</span>
			<p>It's been proven now that you can develop functional web applications with very little time, using the right tools:</p>
			<p><a href="http://www.rubyonrails.com/media/video/rails_take2_with_sound.mov">A 15-Minute Blog</a></p>
			<p>I guess that puts web applications in the valid Ruby Quiz category, so let's tackle one using your framework of choice:  CGI, WEBrick servlets, Rails, or whatever.</p>
			<p>When I first came to Ruby, even just a year ago, I really doubt the community was ready to support a Ruby jobs focused web site.  Now though, times have changed.  I'm seeing more and more posting about Ruby jobs scattered among the various Ruby sites.  Rails has obviously played no small part in this and the biggest source of jobs postings is probably the Rails weblog, but there have been other Ruby jobs offered recently as well.</p>
			<p>Wouldn't it be nice if we had a centralized site we could go to and scan these listings for our interests?</p>
			<p>This week's Ruby Quiz is to create a web application that allows visitors to post jobs for other visitors to find.  Our focus will be on functionality at this point, so don't waste too much energy making the site beautiful.  (That can be done after you decide this was a brilliant idea and you're really going to launch your site!)</p>
			<p>What should a jobs site record for each position?  I'm not going to set any hard and fast rules on this.  The answer is simply:  Whatever you think we should enter.  If you need more ideas though, browse job listings in your local paper or check out a site like:</p>
			<p><a href="http://jobs.perl.org/">The Perl Job Site</a></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Naturally I always hope that the Ruby Quizzes are timely, but this one was maybe too much so.  One day before I released the quiz, the Ruby jobs site went live.  That probably knocked a lot of excitement out of the problem.  Oh well.  We can at least look over my solution.</p>
			<p>I built a minimal site using Rails.  It didn't take too long really, though I fiddled with a few things for a while, being picky.  As a testament to the power or Rails, I wrote very little code.  I used the code generators to create the three pieces I needed:  logins, jobs, and a mailer.  Then I just tweaked the code to tie it all together.</p>
			<p>The Rails code is spread out over the whole system, so I'm not going to recreate it all here.  You can download it, if you want to see it all or play with the site.</p>
			<p>Rails is an MVC framework, so the code has three layers.  The model layer is mainly defined in SQL with Rails, so here's that file:</p>
			<p class="example">DROP TABLE IF EXISTS people;<br />CREATE TABLE people (<br />    id           INT          NOT NULL auto_increment,<br />    full_name    VARCHAR(100) NOT NULL,<br />    email        VARCHAR(100) NOT NULL,<br />    password     CHAR(40)     NOT NULL,<br />    confirmation CHAR(6)      DEFAULT NULL,<br />    created_on   DATE         NOT NULL,<br />    updated_on   DATE         NOT NULL,<br />    PRIMARY KEY(id)<br />);<br /><br />DROP TABLE IF EXISTS jobs;<br />CREATE TABLE jobs (<br />    id              INT                NOT NULL auto_increment,<br />    person_id       INT                NOT NULL,<br />    company         VARCHAR(100)       NOT NULL,<br />    country         VARCHAR(100)       NOT NULL,<br />    state           VARCHAR(100)       NOT NULL,<br />    city            VARCHAR(100)       NOT NULL,<br />    pay             VARCHAR(50)        NOT NULL,<br />    terms           ENUM( 'contract',<br />                          'hourly',<br />                          'salaried' ) NOT NULL,<br />    on_site         ENUM( 'none',<br />                          'some',<br />                          'all' )      NOT NULL,<br />    hours           VARCHAR(50)        NOT NULL,<br />    travel          VARCHAR(50)        NOT NULL,<br />    description     TEXT               NOT NULL,<br />    required_skills TEXT               NOT NULL,<br />    desired_skills  TEXT,<br />    how_to_apply    TEXT               NOT NULL,<br />    created_on      DATE               NOT NULL,<br />    updated_on      DATE               NOT NULL,<br />    PRIMARY KEY(id)<br />);</p>
			<p>I wrote that for MySQL, but it's pretty simple SQL and I assume it would work with few changes in most databases.  The id fields are the unique identifiers Rails likes, created_on and updated_on are date fields Rails can maintain for you, and the rest is the actual data of my application.</p>
			<p>Wrapping ActiveRecord around the jobs table was trivial:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Job &lt; ActiveRecord::Base<br />        belongs_to :person<br /><br />        ON_SITE_CHOICES = <span class="string">%w{none some all}</span><br />        TERMS_CHOICES   = <span class="string">%w{contract hourly salaried}</span><br />        STATE_CHOICES   = <span class="string">%w{ Alabama Alaska Arizona Arkansas California<br />                              Colorado Connecticut Delaware Florida Georgia<br />                              Hawaii Idaho Illinois Indiana Iowa Kansas Kentucky<br />                              Louisiana Maine Maryland Massachusetts Michigan<br />                              Minnesota Mississippi Missouri Montana Nebraska<br />                              Nevada New\ Hampshire New\ Jersey New\ Mexico<br />                              New\ York North\ Carolina North\ Dakota Ohio<br />                              Oklahoma Oregon Pennsylvania Rhode\ Island<br />                              South\ Carolina South\ Dakota Tennessee Texas Utah<br />                              Vermont Virginia Washington West\ Virginia<br />                              Wisconsin Wyoming Other }</span><br /><br />        validates_inclusion_of :on_site, :<span class="keyword">in</span> =&gt; ON_SITE_CHOICES<br /><br />        validates_inclusion_of :terms, :<span class="keyword">in</span> =&gt; TERMS_CHOICES<br /><br />        validates_presence_of :company, :on_site, :terms,<br />                              :country, :state, :city,<br />                              :pay, :hours, :description, :required_skills,<br />                              :how_to_apply, :person_id<br /><br />        <span class="keyword">def</span> location<br />            <span class="string">"#{city}, #{state} (#{country})"</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Most of that is just some constants I use to build menus later in the view.  You can see my basic validations in there as well.  I also defined my own attribute of location() which is just a combination of city, state, and country.</p>
			<p>Wrapping people wasn't much different.  I used the login generator to create them, but renamed User to Person.  That seemed to fit better with my idea of building a site to collection information on Ruby people, jobs, groups, and events.  I did away with the concept of a login name in favor of email addresses as a unique identifier.  I also added an email confirmation to the login system, so I'll show that here:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Person &lt; ActiveRecord::Base<br />        <span class="comment"># ...</span><br /><br />        <span class="keyword">def</span> <span class="keyword">self</span>.authenticate( email, password, confirmation )<br />            person = find_first( [ <span class="string">"email = ? AND password = ?"</span>,<br />                                   email, sha1(password) ] )<br />            <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">if</span> person.nil?<br />            <span class="keyword">unless</span> person.confirmation.blank?<br />                <span class="keyword">if</span> confirmation == person.confirmation<br />                    person.confirmation = <span class="keyword">nil</span><br />                    person.save <span class="keyword">or</span> raise <span class="string">"Unable to remove confirmation."</span><br />                    person<br />                <span class="keyword">else</span><br />                    <span class="keyword">false</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        protected<br /><br />        <span class="comment"># ...</span><br /><br />        before_create :generate_confirmation<br /><br />        <span class="keyword">def</span> generate_confirmation<br />            code_chars = (<span class="string">"A"</span>..<span class="string">"Z"</span>).to_a + (<span class="string">"a"</span>..<span class="string">"z"</span>).to_a + (0..9).to_a<br />            code       = Array.new(6) { code_chars[rand(code_chars.size)] }.join<br />            write_attribute <span class="string">"confirmation"</span>, code<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>You can see at the bottom that I added a filter to add random confirmation codes to new people.  I enhanced authenticate() to later verify the code and remove it, showing a trusted email address.  An ActionMailer instance (not shown) sent the code to the person and the login form (not shown) was changed to read it on the first login.</p>
			<p>I made other changes to the login system.  I had it store just the Person.id() in the session, instead of the whole Person.  I also added a login_optional() filter, that uses information when available, but doesn't require it.  All of these were trivial to implement and are not shown here.</p>
			<p>The controller layer is hardly worth talking about.  The scaffold generator truly gave me most of what I needed in this simple case.  I added the login filters and modified create() to handle my unusual form that allows you to menu select a state in the U.S., or enter your own.  Here's a peak at those changes:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> JobController &lt; ApplicationController<br />        before_filter :login_required, :except =&gt; [:index, :list, :show]<br />        before_filter :login_optional, :only =&gt; [:show]<br /><br />        <span class="comment"># ...</span><br /><br />        <span class="keyword">def</span> create<br />            <span class="variable">@job</span>           = Job.new(params[:job])<br />            <span class="variable">@job</span>.person_id = <span class="variable">@person</span>.id<br />            <span class="variable">@job</span>.state     = params[:other_state] <span class="keyword">if</span> <span class="variable">@job</span>.state == <span class="string">"Other"</span><br />            <span class="keyword">if</span> <span class="variable">@job</span>.save<br />                flash[:notice] = <span class="string">"Job was successfully created."</span><br />                redirect_to :action =&gt; <span class="string">"list"</span><br />            <span class="keyword">else</span><br />                render :action =&gt; <span class="string">"new"</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>All very basic, as you can see.  If the state() attribute of the job was set to "Other", I just swap it out for the text field.</p>
			<p>My views were also mostly just cleaned up versions of the stuff Rails generated for me.  Here's a peak at the job list view:</p>
			<p class="example">&lt;h2&gt;Listing jobs&lt;/h2&gt;<br /><br />&lt;% if @jobs.nil? or @jobs.empty? -%&gt;<br />&lt;p&gt;No jobs listed, currently.  Check back soon.&lt;/p&gt;<br />&lt;% else -%&gt;<br />&lt;% @jobs.each do |job| -%&gt;<br />&lt;dl&gt;<br />    &lt;dt&gt;Posted:&lt;/dt&gt;<br />    &lt;dd&gt;&lt;%= job.created_on.strftime "%B %d, %Y" %&gt;&lt;/dd&gt;<br />	<br />    &lt;dt&gt;Company:&lt;/dt&gt;<br />    &lt;dd&gt;&lt;%= link_to h(job.company), :action =&gt; :show, :id =&gt; job %&gt; in<br />        &lt;%= h job.location %&gt;&lt;/dd&gt;<br />		<br />    &lt;dt&gt;Description:&lt;/dt&gt;<br />    &lt;dd&gt;&lt;%= excerpt(job.description, job) %&gt;&lt;/dd&gt;<br />&lt;/dl&gt;<br />&lt;% end -%&gt;<br />&lt;% end -%&gt;<br /><br />&lt;%= pagination_links @job_pages -%&gt;<br /><br />&lt;br /&gt;<br /><br />&lt;%= link_to "List your job", :action =&gt; "new" %&gt;</p>
			<p>This is a basic job listing, with pagination.  What this page really needs that I didn't add is some tools to control the sorting and filtering of jobs.  This would be great for looking at jobs just in your area.  The above code relies on a helper method called excerpt():</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> JobHelper<br />        <span class="keyword">def</span> excerpt( textile, id )<br />            html = sanitize(textilize(textile))<br />            html.sub!(<span class="string">/&lt;p&gt;(.*?)&lt;\/p&gt;(.*)\Z/</span>m) { <span class="global">$1</span>.strip }<br />            <span class="keyword">if</span> <span class="global">$2</span> =~ <span class="string">/\S/</span><br />                <span class="string">"#{html} #{link_to '...', :action =&gt; :show, :id =&gt; id}"</span><br />            <span class="keyword">else</span><br />                html<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I used Redcloth to markup all the job description and skill fields.  This method allows me to grab just the first paragraph of the description, to use in the job list view.  It adds a "..." link, if content was trimmed.</p>
			<p>Finally, I'll share one last trick.  Using Rails generators and then adding the files to Subversion can be tedious.  Because of that, I added an action to the Rakefile to do it for me:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">###  James's added tasks  ###</span><br /><br />    desc <span class="string">"Add generated files to Subversion"</span><br />    task :add_to_svn <span class="keyword">do</span><br />        sh <span class="string">%Q{svn status | ruby -nae 'puts $F[1] if $F[0] == "?"' | }</span> +<br />           <span class="string">%Q{xargs svn add}</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That's just a simple nicety, but I sure like it.  Saves me a lot of hassle.  Just make sure you set Subversion properties to ignore files you don't want automatically added to the repository.</p>
			<p>Tomorrow's Ruby Quiz is Gavin Kistner's third topic, this time on captchas...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/156619">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/156983">Paul Vaillant</a></li>
			</ol>
			<p><a href="quiz47_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
