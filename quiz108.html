<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Word Blender (#108)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Word Blender (#108)</span>
			<p>by Ben Bleything</p>
			<p>This is a riff on the Jumble puzzle found in many (US) newspapers. More specifically, it's based on the game TextTwist[1], made by GameHouse[2] and published in various places around the web.</p>
			<p>The mechanic of TextTwist is simple. The player is given six letters and is tasked with unscrambling those letters into as many words as possible. If the player can use all six letters in a word, they proceed to the next round.</p>
			<p>Your task is to build the back-end engine to run a TextTwist clone. Effectively, this means that you must generate a list of three- to six-letter words that can all be constructed from the same six letters. This list must contain at least one six-letter word.</p>
			<p>Bonus points for building a completely functional game!</p>
			<p class="example">[1]: http://games.yahoo.com/games/texttwist.html (just one example, java)<br />[2]: http://www.gamehouse.com/</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I'm almost embarrassed to admit that I originally turned this quiz down.  I thought it would be too similar to the Scrabble Stems problem we did long, long ago.  Ben politely explained that he felt it was different enough though, and then sent some guy named Guido after me in a parking lot one night.  That convinced me to actually work the problem, and I had a change of heart.  I think we can tell from the popularity of the problem that Ben is smarter than I am, so I'm glad I did.</p>
			<p>Many solvers chose to build the entire game, so we will take a look at that approach.  Though the quiz doesn't explicitly call for it, most programmers chose to add scoring or a time limit to their solution to spice up the action.  I went with the time limit and we will examine my own code below.</p>
			<p>The first step is to get a word list, of course.  There were several approaches to this process, since manipulating every word in the dictionary each time could get a little slow.  My answer to this was just to cache the word list after I had built it once and reuse that for all future runs.  Here's the code that handles the loading and caching:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># game date cache</span><br />    CACHE_FILE = <span class="string">".game_words"</span><br /><br />    <span class="keyword">if</span> File.exist? CACHE_FILE  <span class="comment"># load from cache</span><br />      word_list = File.open(CACHE_FILE) { |file| Marshal.load(file) }<br />    <span class="keyword">else</span>                       <span class="comment"># build word list</span><br />      <span class="comment"># prepare data structure</span><br />      words_by_signature = Hash.new { |words, sig| words[sig] = Array.new }<br /><br />      <span class="comment"># read dictionary</span><br />      File.foreach(ARGV.shift || <span class="string">"/usr/share/dict/words"</span>) <span class="keyword">do</span> |word|<br />        word.downcase!<br />        word.delete!(<span class="string">"^a-z"</span>)<br /><br />        <span class="keyword">next</span> <span class="keyword">unless</span> word.length.between? 3, 6<br /><br />        (words_by_signature[word.split(<span class="string">""</span>).sort.join] &lt;&lt; word).uniq!<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># prepare recursive signature search</span><br />      <span class="keyword">def</span> choices( sig,<br />                   seen = Hash.new { |all, cur| all[cur] = <span class="keyword">true</span>; <span class="keyword">false</span> },<br />                   &amp;blk )<br />        sig.length.times <span class="keyword">do</span> |i|<br />          shorter = sig[0...i] + sig[(i+1)...sig.length]<br />          <span class="keyword">unless</span> seen[shorter]<br />            blk[shorter]<br />            choices(shorter, seen, &amp;blk) <span class="keyword">unless</span> shorter.length == 3<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># prepare game data structure</span><br />      word_list = Hash.new<br /><br />      <span class="comment"># build game choices</span><br />      words_by_signature.keys.grep(<span class="string">/\A.{6}\Z/</span>) <span class="keyword">do</span> |possible|<br />        word_list[possible] = words_by_signature[possible]<br /><br />        choices(possible) <span class="keyword">do</span> |shorter_signature|<br />          <span class="keyword">if</span> words_by_signature.include? shorter_signature<br />            word_list[possible].push(*words_by_signature[shorter_signature])<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># cache for faster loads</span><br />      File.open(CACHE_FILE, <span class="string">"w"</span>) { |file| Marshal.dump(word_list, file) }<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This uses Marshal to build a trivial word cache with only a few lines of code.  If the cache exists, we slurp it back in.  Otherwise we build the cache and save it for future runs.</p>
			<p>To build the cache, I pluck all three to six letter words out of the indicated dictionary file and build a word list containing all six letter words linked to smaller words using the same letters.</p>
			<p>The main trick used in this recursive grouping of words is the use of "signatures."  A word's signature is just the sorted order of the letters in the word:  aejms for james, for example.  Comparing signatures makes it trivial to find words that use the same letters, since their signatures will be the same.</p>
			<p>Using the signatures, the choices() method just removes one character at a time recursing through the word list.  This allows me to find all of the smaller words that can be formed using the same letters.</p>
			<p>If you wanted to generate the entire list of games as the quiz suggested, the above is all you need.  Each key is one possible round with the values being the words that can be matched in that round.</p>
			<p>I wanted to play though and built a full game interface.  My interface requires Unix, because those are the tricks I know.  Here's the start of that code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    require <span class="string">"io/wait"</span><br /><br />    <span class="comment">### game interface (requires Unix) ###</span><br />    TERMINAL_STATE = <span class="string">`stty -g`</span><br />    system <span class="string">"stty raw -echo cbreak"</span><br />    at_exit { system <span class="string">"stty #{TERMINAL_STATE}"</span> }<br />    clear = <span class="string">`clear`</span><br /><br />    <span class="comment"># a raw mode savvy puts</span><br />    <span class="keyword">def</span> out(*args) print(*(args + [<span class="string">"\r\n"</span>])) <span class="keyword">end</span><br /><br />    <span class="comment"># for easy selection</span><br />    words = word_list.keys<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This setup code memorizes the original state of the user's terminal, modifies that state to raw mode so I can read individual characters as they are pressed, arranges to have the terminal settings restored at exit, grabs the escape sequence we can use to clear the terminal, and builds a puts() like method that works with raw mode.  This code doesn't really have much to do with Ruby.  I'm just shelling out to standard Unix utilities here.</p>
			<p>We're now ready for the game event loop:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    rounds = 0<br />    loop <span class="keyword">do</span><br />      <span class="comment"># select letters</span><br />      letters = current = words[rand(words.size)]<br />      <span class="keyword">while</span> word_list.include? letters<br />        letters = letters.split(<span class="string">""</span>).sort_by { rand }.join<br />      <span class="keyword">end</span><br />      letters.gsub!(<span class="string">/.(?=.)/</span>, <span class="string">'\0 '</span>)<br /><br />      <span class="comment"># round data</span><br />      advance       = <span class="keyword">false</span><br />      matches       = Array.new<br />      current_match = String.new<br />      start         = Time.now<br />      message       = <span class="keyword">nil</span><br />      last_update   = start - 1<br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>I begin by selecting a word for the round and scrambling that word's letters until they are no longer a real word.  Then I setup some variables to hold data for the round like whether or not the user has found a six letter word and should advance as well as any feedback message I am currently showing the user and the last time I refreshed the screen.</p>
			<p>Now we start the round event loop:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># round event loop</span><br />      <span class="keyword">until</span> Time.now &gt;= start + 2 * 60<br />        <span class="comment"># game display</span><br />        <span class="keyword">if</span> last_update &lt;= Time.now - 1<br />          print clear<br /><br />          out <span class="string">"Your letters:  #{letters}"</span><br />          out <span class="string">"   Time left:  #{120 - (Time.now - start).round} seconds"</span><br />          out <span class="string">"  Your words:  #{matches.join(', ')}"</span><br />          out<br />          <span class="keyword">unless</span> message.nil?<br />            out message<br />            out<br />          <span class="keyword">end</span><br />          print current_match<br />          <span class="global">$stdout</span>.flush<br /><br />          last_update = Time.now<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>The round event loop runs for two minutes and this first bit is responsible for drawing the screen.  After clearing the screen, it prints the letters, time left, words found, and any feedback message to the screen.  Note that I update the screen each second, assuming no other activity, so the user will notice the clock counting down.</p>
			<p>Here's the input processing:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># input handler</span><br />        <span class="keyword">if</span> <span class="global">$stdin</span>.ready?<br />          char = <span class="global">$stdin</span>.getc<br />              <span class="keyword">case</span> char<br />                <span class="keyword">when</span> ?a..?z, ?A..?Z  <span class="comment"># read input</span><br />                  current_match &lt;&lt; char.chr.downcase<br />                  message       =  <span class="keyword">nil</span><br />            last_update   =  start - 1<br />          <span class="keyword">when</span> ?\b, 127        <span class="comment"># backspace/delete</span><br />            current_match = current_match[0..-2]<br />                  message       =  <span class="keyword">nil</span><br />            last_update   =  start - 1<br />          <span class="keyword">when</span> ?\r, ?\n        <span class="comment"># test entered word</span><br />            <span class="keyword">if</span> word_list[current].include? current_match<br />              matches &lt;&lt; current_match<br />              matches = matches.sort_by { |word| [word.size, word] }<br />              <span class="keyword">if</span> <span class="keyword">not</span> advance <span class="keyword">and</span> current_match.length == 6<br />                advance = <span class="keyword">true</span><br />                message = <span class="string">"You will advance to the next round!"</span><br />              <span class="keyword">else</span><br />                      message = <span class="keyword">nil</span><br />              <span class="keyword">end</span><br />            <span class="keyword">else</span><br />              message = <span class="string">"Unknown word."</span><br />            <span class="keyword">end</span><br />            current_match = String.new<br />            last_update   = start - 1<br />              <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This just checks to see if there is data waiting on STDIN.  We don't want to read from it without checking as that could block the application waiting for input.  The ready?() method used here is added by the io/wait library and will return true if there is data waiting.  The rest of the code just handles the input we get.  Letters are recorded, we support backspace, and a carriage-return tells us to try the current word, set some feedback, and refresh the display.</p>
			<p>When the round is done, we finish out the game loop:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># round results</span><br />      print clear<br />      missed = word_list[current] - matches<br />      <span class="keyword">unless</span> missed.empty?<br />        out <span class="string">"Other words using \"#{letters}:\""</span><br />        out missed.sort_by { |word| [word.size, word] }.join(<span class="string">", "</span>)<br />        out<br />      <span class="keyword">end</span><br />      <span class="keyword">if</span> advance<br />        rounds += 1<br /><br />        out <span class="string">"You made #{matches.size} word#{'s' if matches.size != 1}, "</span>,<br />            <span class="string">"including at least one six letter word.  Nice work."</span><br />        out <span class="string">"Press any key to begin the next round."</span><br /><br />        <span class="global">$stdin</span>.getc<br />      <span class="keyword">else</span><br />        out <span class="string">"You made #{matches.size} word#{'s' if matches.size != 1}, "</span>,<br />            <span class="string">"but failed to find a six letter word."</span><br /><br />        <span class="keyword">break</span>  <span class="comment"># end game</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># game results</span><br />    out <span class="string">"You completed #{rounds} round#{'s' if rounds != 1}.  "</span>,<br />        <span class="string">"Thanks for playing."</span><br /><br /></div></div>
			<p>The above code just prints missed words and results.  If you found a six letter word, the code will loop to a new round.  Otherwise it will break out of the program.</p>
			<p>A big thank you to Ben (and Guido!) for convincing me to try the quiz and to all those that took the time to play with it.</p>
			<p>Tomorrow we'll try a problem that has been making the rounds, literally...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232983">Fedor Labounko</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232985">Ionut Artarisi</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232990">Jason Mayer</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/232997">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233024">Chunyun Zhao</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233026">Chunyun Zhao (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233034">Ben Ford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233040">Daniel Finnie</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233048">Eric I.</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233067">Dale Martenson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233075">Dan Manges</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233081">Martin Boese</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233101">Ionut Artarisi (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233271">Bob Showalter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233328">Ken Bloom</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233490">William James</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233533">Martin DeMello</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/233609">David Phillips</a></li>
			</ol>
			<p><a href="quiz108_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
