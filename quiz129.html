<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - LSRC Name Picker (#129)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">LSRC Name Picker (#129)</span>
			<p>As most of you have probably heard, the Lone Star Rubyconf is on the horizon:</p>
			<p><a href="http://lonestarrubyconf.com/">Lone Star Rubyconf</a></p>
			<p>What you haven't heard before now is that the conference organizers need our help.  As is typical for these events, several gifts will be given away to the attendees.  Names for the prize recipients need to be selected at random.</p>
			<p>That's where this quiz comes in.</p>
			<p>The LSRC organizers would like us to build name picking applications they can choose from.  The functionality is very basic:</p>
			<p class="example">* Your application needs to accept input as a list of attendees.<br />  At a minimum, you should accept names, but it might be nice to<br />  allow for additional details like the attendee's organization.<br /><br />* Each time your application is run, it should select and display<br />  a single name from the list.  Your application should remember<br />  previously selected names and not choose them a second time.</p>
			<p>The real quiz is how fancy you can make that process.  The LSRC organizers are looking for a lot of sex appeal in their name picker.  Solutions that incorporate the conference name or stars will be given extra consideration.  The goal is something that will have a room full of attendees entranced when run on the projector.  Any interface that meets the above criteria will do.</p>
			<p>The conference organizers will recognize the author(s) of any selected solution(s) at the event (your output can also include a byline), which will surely lead to unending fame.  Fortune may have to follow at a later date.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Everyone who had my name in their example prize list deserves extra credit.  I won millions in cash and prizes as I examined the solutions this week.  I can't wait until the checks start coming in the mail.</p>
			<p>I was occasionally beat out by some Yukihiro Matsumoto guy though.  Weird.</p>
			<p>As usual, there were a lot of great solutions.  We had everything from clever ASCII art to full GUI applications.  There were also a lot of clever ways to taunt the attendees before a name is picked.</p>
			<p>I'm going to look at Carl Porth's solution because the code is compact and pretty approachable.  I also laughed out-loud when I ran his code.  Do play around with the other solutions though or you will be missing a lot of fun applications and code.</p>
			<p>Carl's solution is a Camping application.  If you aren't too familiar with Camping, as I wasn't, Carl's solution makes a nice gentle introduction.  Here's how it begins:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby -wKU</span><br /><br />    require <span class="string">"rubygems"</span><br />    require <span class="string">"camping"</span><br />    require <span class="string">"RMagick"</span><br /><br />    <span class="keyword">module</span> Enumerable<br />      <span class="keyword">def</span> rand<br />        entries[Kernel.rand(entries.size)]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    Camping.goes :NamePicker<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>First we see that Carl loads Camping and RMagick as his weapons of choice.  Then we have a simple helper method for choosing a random member of some Enumerable object.</p>
			<p>The final line is how you always begin a Camping application.  It tells the framework to create a namespace for your application in a module called NamePicker.  The code then goes on to fill in that namespace:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">module</span> NamePicker::Controllers<br />      <span class="keyword">class</span> Index &lt; R <span class="string">'/'</span><br />        <span class="keyword">def</span> get<br />          render :index<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">class</span> Stylesheet &lt; R <span class="string">'/style.css'</span><br />        <span class="keyword">def</span> get<br />          <span class="variable">@headers</span>[<span class="string">'Content-Type'</span>] = <span class="string">'text/css'</span><br />          File.read(<span class="keyword">__FILE__</span>).gsub(<span class="string">/.*__END__/</span>m, <span class="string">''</span>)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">class</span> StaticImage &lt; R <span class="string">'/images/(.*)'</span><br />        <span class="keyword">def</span> get(static_name)<br />          <span class="variable">@headers</span>[<span class="string">'Content-Type'</span>] = <span class="string">"image/jpg"</span><br />          <span class="variable">@headers</span>[<span class="string">'X-Sendfile'</span>] = <span class="string">"#{current_dir}/images/#{static_name}"</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">class</span> PickedNameImage &lt; R <span class="string">'/picked_names/(.*?)\.gif'</span><br />        <span class="keyword">def</span> get(name)<br />          make_image(name)<br />          <span class="variable">@headers</span>[<span class="string">'Content-Type'</span>] = <span class="string">"image/gif"</span><br />          <span class="variable">@headers</span>[<span class="string">'X-Sendfile'</span>] = <span class="string">"#{current_dir}/picked_names/#{name}.gif"</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">class</span> Page &lt; R <span class="string">'/(\w+)'</span><br />        <span class="keyword">def</span> get(page_name)<br />          render page_name<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>These are the controllers for this application.  They manage all of the traffic through the pages.</p>
			<p>The main point of interest in these is Camping's R() routing method.  As you can see, it builds classes these controllers can inherit from.  The regular expression you pass to it are the URLs that controller will service.</p>
			<p>The first controller covers index requests.  The next two serve up static file and image content.  PickedNameImage also serves images, but these are dynamically generated from a selected name using the make_image() helper method.  Both types of images are handled by Camping just by the code setting some headers about the file to send.  The final controller handles all other page requests.</p>
			<p>You can see that the Stylesheet controller makes use of some content embedded later in the file.  It looks like this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment">__END__<br /><br />    body {<br />      background-color:black;<br />      text-align:center;<br />      font-size:30px;<br />      font-family:impact;<br />      color:red;<br />      letter-spacing:3px;<br />    }<br />    a { color:red }<br />    p { margin:80px }<br /><br /></span></div></div>
			<p>Now, unlike Rails, Camping views are just simple Ruby methods.  Here's a look at those:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">module</span> NamePicker::Views<br />      <span class="keyword">def</span> layout<br />        html <span class="keyword">do</span><br />          head <span class="keyword">do</span><br />            title <span class="string">"LOLPIXNAMES"</span><br />            link :href=&gt; R(Stylesheet), :rel=&gt;<span class="string">'stylesheet'</span>, :type=&gt;<span class="string">'text/css'</span><br />          <span class="keyword">end</span><br />          body { <span class="keyword">self</span> &lt;&lt; <span class="keyword">yield</span> }<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> index<br />        p { img :src =&gt; R(StaticImage, <span class="string">"icanpixname.jpg"</span>) }<br />        p { a <span class="string">"PIX A NAME"</span>, :href =&gt; <span class="string">'/pick_name'</span> }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> pick_name<br />        all_names = open(<span class="string">'names'</span>).readlines.map <span class="keyword">do</span> |e|<br />          e.gsub(<span class="string">/[^a-zA-Z 0-9]/</span>,<span class="string">''</span>)<br />        <span class="keyword">end</span>.reject { |e| e.empty? }<br /><br />        picked_names = Dir[<span class="string">"picked_names/*.gif"</span>].map <span class="keyword">do</span> |e|<br />          e.sub(<span class="string">/picked_names\/(.*?)\.gif$/</span>,<span class="string">'\\1'</span>)<br />        <span class="keyword">end</span><br /><br />        unpicked_names = all_names - picked_names<br />        name = unpicked_names.rand<br /><br />        p <span class="keyword">do</span><br />          img :src =&gt; R(StaticImage, <span class="string">"ipixedname.jpg"</span>)<br />          br<br />          img :src =&gt; <span class="string">"picked_names/#{name}.gif"</span><br />        <span class="keyword">end</span><br />        p { a <span class="string">"I CAN PIX YR NAME AGAIN"</span>, :href =&gt; <span class="string">'/pick_name'</span> }<br />        p { a <span class="string">"KTHXBYE"</span>, :href =&gt; <span class="string">'/credits'</span> }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> credits<br />        h1 <span class="string">"CREDITZ"</span><br />        ul <span class="keyword">do</span><br />          li <span class="string">"http://flickr.com/photos/mag3737/296800129/"</span><br />          li <span class="string">"http://flickr.com/photos/brian-fitzgerald/608882248/"</span><br />          li <span class="string">"http://www.ocf.berkeley.edu/~gordeon/fonts.html"</span><br />        <span class="keyword">end</span><br />        p <span class="string">"Carl Porth: badcarl@gmail.com"</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The point of interest in these methods is the appearance of Markaby, which is used to build HTML pages.  Markaby is very similar to Builder, if you are familiar with that library, save that it doesn't need the explicit receiver.</p>
			<p>The only action that does some work here is pick_name().  It pulls in names from a name file, cross-checks those against what it has previously generated, and selects an unpicked name.  Then it renders some HTML to show the selection.</p>
			<p>All we have left at this point are the helper methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">module</span> NamePicker::Helpers<br />      <span class="keyword">def</span> make_image(text)<br />        gif = Magick::ImageList.new<br /><br />        decode_name(text.upcase).each <span class="keyword">do</span> |frame_text|<br />          frame = Magick::Image.new(30*frame_text.size, 52) <span class="keyword">do</span><br />            <span class="keyword">self</span>.background_color = <span class="string">'black'</span><br />          <span class="keyword">end</span><br /><br />          Magick::Draw.new.annotate(frame, 0,0,0,0, frame_text) <span class="keyword">do</span><br />            <span class="keyword">self</span>.font         = <span class="string">'Impact.ttf'</span><br />            <span class="keyword">self</span>.pointsize    = 50<br />            <span class="keyword">self</span>.fill         = <span class="string">'white'</span><br />            <span class="keyword">self</span>.stroke       = <span class="string">'black'</span><br />            <span class="keyword">self</span>.stroke_width = 2<br />            <span class="keyword">self</span>.gravity      = Magick::CenterGravity<br />          <span class="keyword">end</span><br /><br />          gif &lt;&lt; frame<br />        <span class="keyword">end</span><br /><br />        gif.delay = 15<br />        gif.iterations = 1<br /><br />        gif.write(<span class="string">"picked_names/#{text}.gif"</span>)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> encode_name(name, indexes=[])<br />        <span class="keyword">return</span> [] <span class="keyword">if</span> name.size == indexes.size + 1<br /><br />        new_index = ((0...name.size).to_a - indexes).rand<br />        random_words(name, indexes) + encode_name(name, indexes &lt;&lt; new_index)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> random_words(word, indexes_to_replace,<br />                       number_of_words=indexes_to_replace.size)<br />        (0..number_of_words).to_a.map <span class="keyword">do</span><br />          new_word = word.dup<br />          indexes_to_replace.each { |i| new_word[i] = (<span class="string">"A"</span>..<span class="string">"Z"</span>).rand }<br />          new_word<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> decode_name(name)<br />        encode_name(name).reverse<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> current_dir<br />        File.expand_path(File.dirname(<span class="keyword">__FILE__</span>))<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>All of these methods work together to generate the selected name image shown when the application runs.  The process builds an animated Gif image where the frames show the name in various degrees of being scrambled.  As the animation plays out, the name unscrambles to reveal a winner.</p>
			<p>The make_image() method does the heavy lifting by iterating over variations of the name and using RMagick to build frames for them.  The other methods scramble the name by replacing certain indices with random letters.</p>
			<p>That's about all there is to Carl's code, save some humor.  Fire it up in your browser to make sure you get a taste of that.  "KTHXBYE!"</p>
			<p>My thanks to all who solved the quiz, made me laugh, and, most importantly, to those who awarded me prizes.</p>
			<p>Tomorrow we have a problem using a c__ss_c g_me...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257026">Jesse Merriman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257036">Bob Showalter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257050">Florian A&szlig;mann</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257063">Florian A&szlig;mann (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257069">Florian A&szlig;mann (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257111">Carl Porth</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257220">steve d</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257257">Rub&eacute;n Medell&iacute;n</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257391">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257604">Morton Goldberg</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/257724">Ivo Dancet</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258111">Gregory Seidman</a></li>
			</ol>
			<p><a href="quiz129_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
