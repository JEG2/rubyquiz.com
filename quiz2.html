<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Secret Santas (#2)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Secret Santas (#2)</span>
			<p>Honoring a long standing tradition started by my wife's dad, my friends all play a Secret Santa game around Christmas time.  We draw names and spend a week sneaking that person gifts and clues to our identity.  On the last night of the game, we get together, have dinner, share stories, and, most importantly, try to guess who our Secret Santa was.  It's a crazily fun way to enjoy each other's company during the holidays.</p>
			<p>To choose Santas, we use to draw names out of a hat.  This system was tedious, prone to many "Wait, I got myself..." problems.  This year, we made a change to the rules that further complicated picking and we knew the hat draw would not stand up to the challenge.  Naturally, to solve this problem, I scripted the process.  Since that turned out to be more interesting than I had expected, I decided to share.</p>
			<p>This weeks Ruby Quiz is to implement a Secret Santa selection script.</p>
			<p>Your script will be fed a list of names on STDIN.  An example might be:</p>
			<p class="example">Luke Skywalker   &lt;luke@theforce.net&gt;<br />Leia Skywalker   &lt;leia@therebellion.org&gt;<br />Toula Portokalos &lt;toula@manhunter.org&gt;<br />Gus Portokalos   &lt;gus@weareallfruit.net&gt;<br />Bruce Wayne      &lt;bruce@imbatman.com&gt;<br />Virgil Brigman   &lt;virgil@rigworkersunion.org&gt;<br />Lindsey Brigman  &lt;lindsey@iseealiens.net&gt;</p>
			<p>Note:  If you cannot tell, I made those addresses up and you'll need to replace them with something meaningful.  Please don't pester those people, should they happen to be real.</p>
			<p>The format for these names is:</p>
			<p class="example">FIRST_NAME space FAMILY_NAME space &lt;EMAIL_ADDRESS&gt; newline</p>
			<p>We'll keep things simple and say that people only have two names, so you don't have to worry about tricky names like Gray II.</p>
			<p>Your script should then choose a Secret Santa for every name in the list.  Obviously, a person cannot be their own Secret Santa.  In addition, my friends no longer allow people in the same family to be Santas for each other and your script should take this into account.</p>
			<p>Output is obvious.  E-mail the Santa and tell them who their person is.</p>
			<p>The extra credit for this quiz is to convince all your friends how much fun this can really be, so you can put your script to good use.  Go forth spreading holiday cheer into the world!</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Please allow me a quick clarification, before I talk about this week's quiz.  Joe Cheng asked:</p>
			<p class="example">Will you accept solutions that just print out the e-mails<br />instead of sending them? :)</p>
			<p>My answer to this is simply that you may submit whatever you like to a Ruby Quiz.  There's no right and wrong answers here.  However, when I define a specification in a quiz, that's what I'm prepared to benchmark, test and summarize.  Please understand if I do not include altered solutions in those processes.  (This has been added to the Ruby Quiz FAQ.)</p>
			<p>Let's move on to the problem at hand.</p>
			<p>As many have now pointed out, this problem is trickier than it first appears.  The first solution that came to my mind when playing with this problem was simple:</p>
			<p class="example">1.  Choose a name from the list.<br />2.  Filter all matching surnames out of the Santa list.<br />3.  Assign a random Santa from the list in step 2, to the name in step 1.<br />4.  Repeat until all names are assigned...</p>
			<p>As I quickly learned, that doesn't quite work.  The easiest way to see why it doesn't work is to consider three families, one member each:</p>
			<p class="example">Skywalker can be assigned as a Santa for Portokalos.<br />Portokalos can then be assigned as the Santa for Skywalker.<br />And then we're stuck!  There are no matches left for Brigman or whoever.</p>
			<p>Depending on how you implement the above, you'll probably get incorrect output or get stuck in an infinite loop at this point.  That was when I personally began to take this problem seriously, and look at other options.  Let's see what others found.</p>
			<p>The submitted solutions are more or less variations on three major themes:</p>
			<p class="example">Random Sorts<br />Circular Lists and/or Family Grouping<br />"Hill Climbing" Algorithms</p>
			<p>Let's examine each of those in turn, starting with random sorts.  Here's the code from my own submission that handles this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="global">$players</span> = STDIN.readlines.map { |line| line.chomp }<br />    <span class="global">$santas</span> = <span class="global">$players</span>.sort_by { rand }<br /><br />    <span class="keyword">def</span> check_families?<br />        <span class="global">$players</span>.each_with_index <span class="keyword">do</span> |who, i|<br />            <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> who[<span class="string">/\S+ &lt;/</span>] == <span class="global">$santas</span>[i][<span class="string">/\S+ &lt;/</span>]<br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> <span class="keyword">true</span><br />    <span class="keyword">end</span><br /><br />    <span class="global">$santas</span> = <span class="global">$players</span>.sort_by { rand } <span class="keyword">until</span> check_families?<br /><br /></div></div>
			<p>The idea there is simple, keep randomly shuffling $santas until we can verify that none of the match-ups share the same surname.  That ensures no one will have themself or common family members, of course.  This method does give us a good random shuffle of the match-ups, but unfortunately, the performance is far from stellar.</p>
			<p>Still, in a Secret Santa selection script, how critical is performance?  This type of answer could be a viable solution in this case, though it usually isn't in the majority of "Real World" problems.</p>
			<p>The techniques in the second category of solutions, circular lists/family groupings, were quite varied.  One solution built a circular linked list, separated family members in that list, and then assigned Santas straight down.  Another tactic, used in more than one submission, was to separate the input into family groups, choose a member from the most populated family, and assign a Santa from the next highest populated family, until the list was exhausted.</p>
			<p>Algorithms like this are far more efficient that my random sort above, critically so in pathological cases.  They do make a trade off though.  These types of assignments are not unbiased and do not allow for all possible permutations of assignment.  Consider this: in a circular list approach, it is impossible for two players of the game to be assigned to each other as Santas.  That's not to say this is a minus of these algorithms, some groups may even prefer this behavior, but if you're looking for something quite random you probably need to look at little further.</p>
			<p>However, Niklas Frykholm submitted what I believe to be a variation of the family grouping theme that does produce unbiased matches.  Here's the matching portion of his code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Array<br />        <span class="keyword">def</span> random_member(&amp;block)<br />            <span class="keyword">return</span> select(&amp;block).random_member <span class="keyword">if</span> block<br />            <span class="keyword">return</span> <span class="keyword">self</span>[rand(size)]<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> count(&amp;block)<br />            <span class="keyword">return</span> select(&amp;block).size<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> String<br />        <span class="keyword">def</span> clean_here_string<br />            indent = <span class="keyword">self</span>[<span class="string">/^\s*/</span>]<br />            <span class="keyword">return</span> <span class="keyword">self</span>.gsub(<span class="string">/^#{indent}/</span>, <span class="string">""</span>)<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Person<br />        attr_reader :first, :family, :mail<br />        <span class="keyword">def</span> initialize(first, family, mail)<br />            <span class="variable">@first</span>, <span class="variable">@family</span>, <span class="variable">@mail</span> = first, family, mail<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> to_s() <span class="string">"#{first} #{family} &lt;#{mail}&gt;"</span> <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> AssignSanta<br />        <span class="keyword">def</span> initialize(persons)<br />            <span class="variable">@persons</span> = persons.dup<br />            <span class="variable">@santas</span> = persons.dup<br />            <span class="variable">@families</span> = persons.collect {|p| p.family}.uniq<br />            <span class="variable">@families</span>.each { |f|<br />                <span class="keyword">if</span> santa_surplus(f) &lt; 0<br />                    raise <span class="string">"No santa configuration possible"</span><br />            }<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Key function -- extra santas available for a family</span><br />        <span class="comment">#        if this is negative -- no santa configuration is possible</span><br />        <span class="comment">#        if this is 0 -- next santa must be assigned to this family</span><br />        <span class="keyword">def</span> santa_surplus(family)<br />            <span class="keyword">return</span> <span class="variable">@santas</span>.count {|s| s.family != family} -<br />                   <span class="variable">@persons</span>.count {|p| p.family == family}<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> call<br />            <span class="keyword">while</span> <span class="variable">@persons</span>.size() &gt; 0<br />                family = <span class="variable">@families</span>.detect { |f|<br />                    santa_surplus(f)==0 <span class="keyword">and</span><br />                    <span class="variable">@persons</span>.count{|p| p.family == f} &gt; 0<br />                }<br />                person = <span class="variable">@persons</span>.random_member { |p|<br />                    family == <span class="keyword">nil</span> || p.family == family<br />                }<br />                santa = <span class="variable">@santas</span>.random_member{ |s|<br />                    s.family != person.family<br />                }<br />                <span class="keyword">yield</span>(person, santa)<br />                <span class="variable">@persons</span>.delete(person)<br />                <span class="variable">@santas</span>.delete(santa)<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The exciting stuff is at the bottom, particularly the santa_surplus() method.  Niklas' code tracks how many Santas are still available to all the families at each step and uses this information to avoid running out of options for future selections.  But don't take my word for it, he posted a wonderful follow-up breakdown of exactly how it works to Ruby Talk:</p>
			<p><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/cgi-bin/scat.rb/ruby/ruby-talk/114760">Niklas Explains his Algorithm</a></p>
			<p>The final type of solution was what is generally known as a "Hill Climbing" algorithm.  Dennis Ranke explains his version nicely:</p>
			<p class="example">I start by assigning a random santa to everyone without caring about the<br />constraints. Then I go through the list of people and for each one not<br />having a correct santa I swap santas with someone else, so that both have<br />correct santas afterwards.<br />As far as I can see, this will only fail when no solution is possible and<br />should be reasonably unbiased.</p>
			<p>Put another way, you start with a random and likely quite incorrect match-up, then correct it one swap at a time.  Here's the code to match the description:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Person<br />       attr_reader :first, :last, :email<br />       attr_accessor :santa<br /><br />       <span class="keyword">def</span> initialize(line)<br />         m = <span class="string">/(\S+)\s+(\S+)\s+&lt;(.*)&gt;/</span>.match(line)<br />         raise <span class="keyword">unless</span> m<br />         <span class="variable">@first</span> = m[1].capitalize<br />         <span class="variable">@last</span> = m[2].capitalize<br />         <span class="variable">@email</span> = m[3]<br />       <span class="keyword">end</span><br /><br />       <span class="keyword">def</span> can_be_santa_of?(other)<br />         <span class="variable">@last</span> != other.last<br />       <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    input = <span class="global">$stdin</span>.read<br /><br />    people = []<br />    input.each_line <span class="keyword">do</span> |line|<br />       line.strip!<br />       people &lt;&lt; Person.new(line) <span class="keyword">unless</span> line.empty?<br />    <span class="keyword">end</span><br /><br />    santas = people.dup<br />    people.each <span class="keyword">do</span> |person|<br />       person.santa = santas.delete_at(rand(santas.size))<br />    <span class="keyword">end</span><br /><br />    people.each <span class="keyword">do</span> |person|<br />       <span class="keyword">unless</span> person.santa.can_be_santa_of? person<br />         candidates = people.select { |p|<br />             p.santa.can_be_santa_of?(person) &amp;&amp;<br />             person.santa.can_be_santa_of?(p)<br />         }<br />         raise <span class="keyword">if</span> candidates.empty?<br />         other = candidates[rand(candidates.size)]<br />         temp = person.santa<br />         person.santa = other.santa<br />         other.santa = temp<br />         finished = <span class="keyword">false</span><br />       <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    people.each <span class="keyword">do</span> |person|<br />       printf <span class="string">"%s %s -&gt; %s %s\n"</span>, person.santa.first, person.santa.last,<br />                                  person.first, person.last<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Santas are randomly assigned in the first people.each() iteration above and then swapped until correct in the following people.each() iteration.  I was surprised at how simple this solution came out, with such effective results.</p>
			<p>That's all I have time to cover, but that's certainly not all there is to see in the submitted solutions.  I learn new tricks every time I read the code to put together one of these summaries.  They're certainly worth a look, if you haven't given them one already.  Other highlights include Warren Brown's rules based approach and Gavin Kistner's Ouroboros class for building circular lists, but again, I think all the solutions are worth examining.</p>
			<p>Before I wrap this up, let me congratulate Robo and Cristi BALAN who both claimed inexperience and promptly proved it false with working code.  I singled Robo out in the discussion early on to hint at the quiz's complexity, but the truth is that his solution could work fine for the problem at hand.  Who cares if you sometimes have to run it twice?  I sure don't.</p>
			<p>My thanks to all who submitted and all those that just tolerate our babble on Ruby Talk.  Look for Gavin's quiz tomorrow morning...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114675">Robo</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114677">Thomas Leitner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114678">Gavin Kistner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114682">Joe Cheng</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114684">Andre Nathan</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114690">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114693">Dennis Ranke</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114695">Joe Cheng (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114698">Martin Ankerl</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114700">Roeland Moors</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114720">Jeremy Hinegardner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114734">Cristi BALAN</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114746">Niklas Frykholm</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114833">Warren Brown</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/114851">Ara.T.Howard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/115005">Cedric Foll</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/115108">Peter McMaster</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/115116">Peter McMaster(2)</a></li>
			</ol>
			<p><a href="quiz2_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
