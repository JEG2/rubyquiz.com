<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
	<title>Ruby Quiz - Short But Unique (#83)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Short But Unique (#83)</span>
			<p>by Ryan Williams</p>
			<p>I use Eclipse (with RadRails!) I have a bunch of files open in tabs. Once enough files are open, Eclipse starts to truncate the names so that everything fits.  It truncates them from the right, which means that pretty soon I'm left unable to tell which tab is "users_controller.rb" and which is "users_controller_test.rb", because they're both truncated to "users_control...".</p>
			<p>The quiz would be to develop an abbrev-like module that shortens a set of strings so that they are all within a specified length, and all unique.  You shorten the strings by replacing a sequence of characters with an ellipsis character [U+2026].  If you want it to be ascii-only, use three periods instead, but keep in mind that then you can only replace blocks of four or more characters.</p>
			<p>It might look like this in operation:</p>
			<p>  ['users_controller', 'users_controller_test',
   'account_controller', 'account_controller_test',
   'bacon'].compress(10)
  =&gt; ['users_c...', 'use...test', 'account...', 'acc...test', 'bacon']</p>
			<p>There's a lot of leeway to vary the algorithm for selecting which characters to crop, so extra points go to schemes that yield more readable results.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>This is a pretty real world problem many applications struggle with.  I dare say it's hard to get right, which is probably why so many applications don't even try.  We had a few adventurous solvers though and they got some workable results.  Let's look into Daniel Martin's solution.</p>
			<p>I felt Daniel got some great output, by favoring the word boundaries of the terms to shorten.  Here's a sample of the code being run on the quiz problem set:</p>
			<p class="example">users...er<br />use...test<br />account...<br />acc...test<br />bacon</p>
			<p>Notice how the compression favors keeping word intact, when possible.  That seems to give fairly good results overall.</p>
			<p>Alright, let's see how Daniel does it:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Returns the length of the longest common</span><br />    <span class="comment"># substring of "a" and "b"</span><br />    <span class="keyword">def</span> string_similarity(a, b)<br />      retval = 0<br />      (0 ... b.length).each { |offset|<br />        len = 0<br />        (0 ... b.length - offset).each { |aind|<br />          <span class="keyword">if</span> (a[aind] <span class="keyword">and</span> b[aind+offset] == a[aind])<br />            len += 1<br />            retval = len <span class="keyword">if</span> retval &lt; len<br />          <span class="keyword">else</span><br />            len = 0<br />          <span class="keyword">end</span><br />        }<br />      }<br />      (1 ... a.length).each { |offset|<br />        len = 0<br />        (0 ... a.length - offset).each { |bind|<br />          <span class="keyword">if</span> (b[bind] <span class="keyword">and</span> a[bind+offset] == b[bind])<br />            len += 1<br />            retval = len <span class="keyword">if</span> retval &lt; len<br />          <span class="keyword">else</span><br />            len = 0<br />          <span class="keyword">end</span><br />        }<br />      }<br />      retval<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The comment above this method tells you exactly what it does, which is to return the numerical length of the longest common substring for the parameters.  It works by walking each possible substring of b and checking that the string occurs in a somewhere.  It then reverses and repeats the process because one string might be longer than the other.  The highest count seen overall is returned.</p>
			<p>Daniel mentioned that he has been out of Ruby for a bit and his Ruby might be a little rusty.  The above code works just fine, of course, but we can shorten it up a bit, if we want to.  Here's another way to write the above:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="global">$KCODE</span> = <span class="string">"u"</span>          <span class="comment"># make jcode happy (silence a warning)</span><br />    require <span class="string">"jcode"</span>       <span class="comment"># for String#each_char</span><br />    require <span class="string">"enumerator"</span>  <span class="comment"># for Enumerable#each_cons</span><br /><br />    <span class="keyword">def</span> string_similarity(str1, str2)<br />      long, short = [str1, str2].sort_by { |str| str.length }<br />      long.length.downto(0) <span class="keyword">do</span> |len|<br />        long.enum_for(:each_char).each_cons(len) <span class="keyword">do</span> |substr|<br />          <span class="keyword">return</span> substr.length <span class="keyword">if</span> short.include? substr.join<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      <span class="keyword">return</span> 0<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Again, this works the same.  I try all possible substrings of the longer string, from longest to shortest, for inclusion in the shorter string.  Since the code works with the longest strings first, we can return the first answer we find.  I'm not saying either method is better, but hopefully you can figure out how they work, between the two of them.</p>
			<p>Let's get back to Daniel's code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">def</span> score_compression(target, start, len, alltargets)<br />      score = target.length - len<br />      score += 3 <span class="keyword">if</span> len == 0<br />      score += 3 <span class="keyword">if</span> (target[start,1] =~ <span class="string">%r(_|\W)</span> <span class="keyword">or</span><br />                     target[start-1,2] =~ <span class="string">%r([a-z0-9][A-Z])</span>)<br />      score += 3 <span class="keyword">if</span> (target[start+len-1,1] =~ <span class="string">%r(_|\W)</span> <span class="keyword">or</span><br />                     target[start+len-1,2] =~ <span class="string">%r([a-z0-9][A-Z])</span>)<br />      prebit = target[0,start]<br />      postbit = target[start+len,target.length]<br />      scoreminus = 0<br />      alltargets.each{|s|<br />        scoreminus += string_similarity(s,prebit)<br />        scoreminus += string_similarity(s,postbit)<br />      }<br />      score - (1.0 / alltargets.length) * scoreminus<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The above code just rates a possible replacement.  The target variable holds the original string, start and len mark the area to be replaced with the repeat string, and alltargets holds the other strings that need compressing.</p>
			<p>The most interesting part starts on the third line of the method, where a couple of checks are used to score substitutions at word boundaries higher.  Note that the checks include punctuation boundaries and changes in case as a boundary.  This, in my opinion, is the source of the quite readable end result.</p>
			<p>Note that the last section of that method compares the pieces of the string that will be left after the replacement with other strings in the result set using the substring count method we examined earlier.  This code is there to prevent two strings from being compressed to the same representation (though I doubt this weighted scoring system is perfect).</p>
			<p>Finally, here's the method that does the actual work:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Array<br />      <span class="keyword">def</span> compress(n, repstr = <span class="string">'...'</span>)<br />        retval = []<br />        <span class="keyword">self</span>.each { |s|<br />          short_specs =<br />          (s.length - n + repstr.length ..<br />           s.length - n + repstr.length + 2).inject([]) { |sp,l|<br />            sp + (0 .. s.length - l).map {|st| [st,l]}<br />          }.select { |a| a[1] &gt; repstr.length}<br />          <span class="keyword">if</span> (s.length &lt;= n) <span class="keyword">then</span> short_specs.unshift([0,0]) <span class="keyword">end</span><br />          retval.push(<br />            short_specs.inject([-999,<span class="string">""</span>]) { |record, spec|<br />              candidate = s.dup<br />              candidate[spec[0],spec[1]] = repstr <span class="keyword">if</span> spec[1] &gt; 0<br />              <span class="keyword">if</span> retval.include?(candidate)<br />                record<br />              <span class="keyword">else</span><br />                score = score_compression(s,spec[0],spec[1],<span class="keyword">self</span>)<br />                <span class="keyword">if</span> score &gt;= record[0]<br />                  [score, candidate]<br />                <span class="keyword">else</span><br />                  record<br />                <span class="keyword">end</span><br />              <span class="keyword">end</span><br />            }[1]<br />          )<br />        }<br />        retval<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This code was a little tricky for me to break down, so let me see if I can explain it in manageable chunks.  This method works over each string in the Array, building a compressed replacement for each one as it goes.  To build those replacements it first constructs an Array of indices and lengths where it could replace content with the replacement string.  It then scores each of those replacements and selects the highest candidate as the result.</p>
			<p>Here's how one might invoke the above:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />      ARGV[1,ARGV.length].compress(ARGV[0].to_i).each {|s| puts s}<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Now, since Unicode has been such a hot topic lately, let's see how this code handles using a real ellipsis character.  If I change the above code to:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />      puts ARGV[1..-1].compress(ARGV[0].to_i, <span class="string">"…"</span>)<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>and run the code again, here's the new output:</p>
			<p class="example">users…er<br />use…test<br />account…<br />acc…test<br />bacon</p>
			<p>Oops, I asked for 10 characters but got less than that.  The reason is that the code we just examined is counting the byte length of our replacement string, in this bit of code right here:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Array<br />      <span class="keyword">def</span> compress(n, repstr = <span class="string">'...'</span>)<br />        retval = []<br />        <span class="keyword">self</span>.each { |s|<br />          short_specs =<br />          (s.length - n + repstr.length ..<br />           s.length - n + repstr.length + 2).inject([]) { |sp,l|<br />            sp + (0 .. s.length - l).map {|st| [st,l]}<br />          }.select { |a| a[1] &gt; repstr.length}<br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>As a fix, I'm going to set the $KCODE variable for Unicode support, load the jcode library for its helper methods, and change all those repstr.length calls to repstr.jlength.  Here's a look at those changes:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="global">$KCODE</span> = <span class="string">"u"</span><br />    require <span class="string">"jcode"</span><br /><br />    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Array<br />      <span class="keyword">def</span> compress(n, repstr = <span class="string">'...'</span>)<br />        retval = []<br />        <span class="keyword">self</span>.each { |s|<br />          short_specs =<br />          (s.length - n + repstr.jlength ..<br />           s.length - n + repstr.jlength + 2).inject([]) { |sp,l|<br />            sp + (0 .. s.length - l).map {|st| [st,l]}<br />          }.select { |a| a[1] &gt; repstr.jlength}<br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>Does that fix us up?  Let's see:</p>
			<p class="example">users…ller<br />users…test<br />account…er<br />account…st<br />bacon</p>
			<p>Bingo.  Now we get the extra characters from using the shorter string.  Don't let people tell you Ruby can't handle Unicode today.</p>
			<p>My thanks to all who gave this quiz a shot.  I expect you all to email your solutions as patches all the applications out there that botch the display of tabs like this.</p>
			<p>Tomorrow we have an easy problem for those working through Learn to Program...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/197973">Daniel Martin</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/198150">Gautan Dey</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/198213">Sander Land</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/198262">Brian Mattern</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/198369">Brian Mattern (2)</a></li>
			</ol>
			<p><a href="quiz83_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
