<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Time Window (#144)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Time Window (#144)</span>
			<p>by Brian Candler</p>
			<p>Write a Ruby class which can tell you whether the current time (or any given time) is within a particular "time window". Time windows are defined by strings in the following format:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#    0700-0900                     # every day between these times</span><br />    <span class="comment">#    Sat Sun                       # all day Sat and Sun, no other times</span><br />    <span class="comment">#    Sat Sun 0700-0900             # 0700-0900 on Sat and Sun only</span><br />    <span class="comment">#    Mon-Fri 0700-0900             # 0700-0900 on Monday to Friday only</span><br />    <span class="comment">#    Mon-Fri 0700-0900; Sat Sun    # ditto plus all day Sat and Sun</span><br />    <span class="comment">#    Fri-Mon 0700-0900             # 0700-0900 on Fri Sat Sun Mon</span><br />    <span class="comment">#    Sat 0700-0800; Sun 0800-0900  # 0700-0800 on Sat, plus 0800-0900 on Sun</span><br /><br /></div></div>
			<p>Time ranges should exclude the upper bound, i.e. 0700-0900 is 07:00:00 to 08:59:59. An empty time window means "all times everyday". Here are some test cases to make it clearer:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> TestTimeWindow &lt; Test::Unit::TestCase<br />      <span class="keyword">def</span> test_window_1<br />        w = TimeWindow.new(<span class="string">"Sat-Sun; Mon Wed 0700-0900; Thu 0700-0900 1000-1200"</span>)<br /><br />        assert ! w.include?(Time.mktime(2007,9,25,8,0,0))   <span class="comment"># Tue</span><br />        assert   w.include?(Time.mktime(2007,9,26,8,0,0))   <span class="comment"># Wed</span><br />        assert ! w.include?(Time.mktime(2007,9,26,11,0,0))<br />        assert ! w.include?(Time.mktime(2007,9,27,6,59,59)) <span class="comment"># Thu</span><br />        assert   w.include?(Time.mktime(2007,9,27,7,0,0))<br />        assert   w.include?(Time.mktime(2007,9,27,8,59,59))<br />        assert ! w.include?(Time.mktime(2007,9,27,9,0,0))<br />        assert   w.include?(Time.mktime(2007,9,27,11,0,0))<br />        assert   w.include?(Time.mktime(2007,9,29,11,0,0))  <span class="comment"># Sat</span><br />        assert   w.include?(Time.mktime(2007,9,29,0,0,0))<br />        assert   w.include?(Time.mktime(2007,9,29,23,59,59))<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> test_window_2<br />        w = TimeWindow.new(<span class="string">"Fri-Mon"</span>)<br />        assert ! w.include?(Time.mktime(2007,9,27)) <span class="comment"># Thu</span><br />        assert   w.include?(Time.mktime(2007,9,28))<br />        assert   w.include?(Time.mktime(2007,9,29))<br />        assert   w.include?(Time.mktime(2007,9,30))<br />        assert   w.include?(Time.mktime(2007,10,1))<br />        assert ! w.include?(Time.mktime(2007,10,2)) <span class="comment"># Tue</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> test_window_nil<br />        w = RDS::TimeWindow.new(<span class="string">""</span>)<br />        assert w.include?(Time.mktime(2007,9,25,1,2,3))     <span class="comment"># all times</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /></div></div>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I've said it before, and I'll say it again this time:  I love the easy problems.  I'm always impressed by the creativity in the solutions for them.  The tricks solvers manage to sneak into their code are so great.  Let me show you a few highlights from this week's solutions.</p>
			<p>For the first trick, let's have a peek at Eric's send()-changes-the-rules comparison:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># Equality is defined as a TimeSpecifier on the RHS being in the</span><br />        <span class="comment"># this range.</span><br />        <span class="keyword">def</span> ==(time_spec)<br />          <span class="comment"># do either a &lt; or a &lt;= when comparing the end of the range</span><br />          <span class="comment"># depending on value of @include_end</span><br />          end_comparison = <span class="variable">@include_end</span> ? :&lt;= : :&lt;<br /><br />          <span class="comment"># NOTE: the call to the send method below is used to call the</span><br />          <span class="comment"># method in end_comparison</span><br />          <span class="keyword">if</span> <span class="variable">@start_t</span> &lt; <span class="variable">@end_t</span><br />            time_spec &gt;= <span class="variable">@start_t</span> &amp;&amp; time_spec.send(end_comparison, <span class="variable">@end_t</span>)<br />          <span class="keyword">else</span>  <span class="comment"># a reverse range, such as "Fri-Mon", needs an ||</span><br />            time_spec &gt;= <span class="variable">@start_t</span> || time_spec.send(end_comparison, <span class="variable">@end_t</span>)<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>In this code Eric is doing a range inclusion test.  The interesting aspect is that the range can include or exclude the end point, just like Ruby's native Range class.  To handle that, Eric sticks a Symbol for a comparison operator in a variable and lets send() sort it out during the actual comparison.</p>
			<p>Here's another trick, this time from Gordon.  It's a terrific yet simple recursive parser for the time formats allowed by this quiz:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment">#recursive method to parse input string</span><br />        <span class="keyword">def</span> parse(token)<br />          <span class="keyword">case</span> token<br />          <span class="keyword">when</span> <span class="string">""</span><br />            REWeek.new(0)<br />          <span class="keyword">when</span> <span class="string">/^(.+);(.+)/</span> <span class="comment"># split at semicolons</span><br />            parse(<span class="global">$1</span>) | parse(<span class="global">$2</span>)<br />          <span class="keyword">when</span> <span class="string">/(\D+) (\d.+)/</span> <span class="comment"># split days and times</span><br />            parse(<span class="global">$1</span>) &amp; parse(<span class="global">$2</span>)<br />          <span class="keyword">when</span> <span class="string">/(\D+) (\D+)/</span>, <span class="string">/(\d+-\d+) (\d+-\d+)/</span> <span class="comment"># split at spaces</span><br />            parse(<span class="global">$1</span>) | parse(<span class="global">$2</span>)<br />          <span class="keyword">when</span> <span class="string">/([A-Z][a-z][a-z])-([A-Z][a-z][a-z])/</span> <span class="comment"># create range of days</span><br />            REWeek.new(Runt.const_get(<span class="global">$1</span>), Runt.const_get(<span class="global">$2</span>))<br />          <span class="keyword">when</span> <span class="string">/([A-Z][a-z][a-z])/</span> <span class="comment"># create single day</span><br />            DIWeek.new(Runt.const_get(<span class="global">$1</span>))<br />          <span class="keyword">when</span> <span class="string">/(\d\d)(\d\d)-(\d\d)(\d\d)/</span> <span class="comment">#create time range</span><br />            start = Time.mktime(2000,1,1,<span class="global">$1</span>.to_i,<span class="global">$2</span>.to_i)<br />            <span class="comment"># 0600-0900 should work like 0600-0859,</span><br />            stop = Time.mktime(2000,1,1,<span class="global">$3</span>.to_i,<span class="global">$4</span>.to_i) - 1<br />            REDay.new(start.hour, start.min, stop.hour, stop.min)<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>To understand this code, you need to know that Gordon used Runt to do the actual time comparisons.  Runt's time objects (REWeek, DIWeek, and REDay) can be "anded" and "ored" together using the &amp; and | operators.  Have a look at how elegant that makes the above parser.</p>
			<p>I'm going to simplify the code a bit to show this next one, but the idea is straight out of Ken's solution.  Have a look at how he handles optional captures in a regular expression:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    DAYS    = <span class="string">%w[Sun Mon Tue Wed Thu Fri Sat]</span><br />    DAY_RE  = <span class="string">/\b(?:#{DAYS.join("|")})\b/</span><br />    DAYS_RE = <span class="string">/(#{DAY_RE})(?=[;\s]|$)|(#{DAY_RE})-(#{DAY_RE})/</span><br /><br />    <span class="keyword">def</span> show_match(day_str)<br />      day_str.scan(DAYS_RE) <span class="keyword">do</span> |day, start_day, end_day|<br />        day       &amp;&amp;= DAYS.index(day)<br />        start_day &amp;&amp;= DAYS.index(start_day)<br />        end_day   &amp;&amp;= DAYS.index(end_day)<br />        p [day, start_day, end_day]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    show_match(<span class="string">"Mon; Wed-Fri"</span>)<br />    <span class="comment"># &gt;&gt; [1, nil, nil]</span><br />    <span class="comment"># &gt;&gt; [nil, 3, 5]</span><br /><br /></div></div>
			<p>The interesting part here was the use of the &amp;&amp;= operator.  This Regexp can match in two ways:  a single day name or two day names as a range.  Because of that, we don't know which variables will be set inside the scan() block.  Ken shows that this doesn't really matter though, as we can perform index conversion on just those that are set with a little operator magic.</p>
			<p>To show a final trick, don't forget that you can get a free initialize() method plus accessors from Struct to bootstrap your class building.  This is a classic Ruby idiom and we saw it in two different forms this week.  First, using inheritance by Philip:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> TimeWindow<br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">class</span> Range &lt; Struct.new(:day_parts, :time_parts)<br />        <span class="comment"># ...</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Or using the under-documented block parameter to the constructor as Yossef showed:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> TimeInterval<br />      <span class="comment"># ...</span><br /><br />      UnboundTime = Struct.new(:hour, :minute) <span class="keyword">do</span><br />        <span class="comment"># ...</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Alright, enough fancy stuff.  Let's get to a solution already.</p>
			<p>Last week, Jesús had the huge all-features-included solution, but this week he gives us the the short and sweet version.  Let's examine that below.</p>
			<p>Jesús breaks the problem down into two classes.  The first class represents some range of time:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'time'</span><br /><br />    <span class="keyword">class</span> TimeRange<br />      <span class="keyword">def</span> initialize(s)<br />        <span class="variable">@day_of_week</span> = []<br />        <span class="variable">@hour</span> = []<br />        s.strip.split(<span class="string">" "</span>).each <span class="keyword">do</span> |range|<br />          <span class="keyword">if</span> (match = range.match(<span class="string">/(\d{4})-(\d{4})/</span>))<br />            <span class="variable">@hour</span> &lt;&lt; (match[1].to_i...match[2].to_i)<br />          <span class="keyword">elsif</span> (match = range.match(<span class="string">/([a-zA-Z]{3})-([a-zA-Z]{3})/</span>))<br />            first = Time::RFC2822_DAY_NAME.index(match[1])<br />            second = Time::RFC2822_DAY_NAME.index(match[2])<br />            <span class="keyword">if</span> (first &lt; second)<br />              <span class="variable">@day_of_week</span> &lt;&lt; (first..second)<br />            <span class="keyword">else</span><br />              <span class="variable">@day_of_week</span> &lt;&lt; (first..(Time::RFC2822_DAY_NAME.size-1))<br />              <span class="variable">@day_of_week</span> &lt;&lt; (0..second)<br />            <span class="keyword">end</span><br />          <span class="keyword">else</span><br />            <span class="variable">@day_of_week</span> &lt;&lt; ( Time::RFC2822_DAY_NAME.index(range) ..<br />                              Time::RFC2822_DAY_NAME.index(range) )<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is the main parser for the solution.  It tokenizes a given time range and processes hour ranges, day ranges, and individual days.  All of these pieces are added to the @day_of_week and @hour Arrays as Ranges representing the times they include.  Days are handled as indexes in an Array loaded by the Ruby standard library and hours and minutes are converted to simple Integers.</p>
			<p>The thing to note in the parser is how days are handled.  First, a Range of days can be tricky index-wise.  For example, Friday to Sunday would be the Range 5..0 and that doesn't make sense.  To handle that, Jesús adds two Ranges in such cases:  5..6 and 0..0 for our example.  Then Ruby's standard Range membership tests will function for the problem.  Single days are treated similarly by adding a Range with the same start and end point.</p>
			<p>Let's have a look at the rest of that class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> include?(time)<br />        dow = time.wday<br />        hour = time.strftime(<span class="string">"%H%M"</span>).to_i<br />        any?(<span class="variable">@day_of_week</span>, dow) <span class="keyword">and</span> any?(<span class="variable">@hour</span>, hour)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> any?(enum, value)<br />        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> enum.empty?<br />        enum.any?{|x| x.include?(value)}<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Together, these methods tell if a passed Time object occurs in this TimeRange.  The include?() method first converts the Time object into the formats stored in the internal Range objects.  After that, a hand-off is made to any?() to verify that both the days and times match-up.</p>
			<p>The last step is to wrap these TimeRange objects in the interface dictated by the quiz:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> TimeWindow<br />      <span class="keyword">def</span> initialize(s)<br />        <span class="variable">@ranges</span> = []<br />        s.split(<span class="string">";"</span>).each <span class="keyword">do</span> |part|<br />          <span class="variable">@ranges</span> &lt;&lt; TimeRange.new(part)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> include?(time)<br />        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> <span class="variable">@ranges</span>.empty?<br />        <span class="variable">@ranges</span>.any? {|x| x.include?(time)}<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Creating a TimeWindow is as simple as, split()ing the input on ";" characters and creating a new TimeRange from each chunk.  This makes the include?() test trivial as well, since it can just forward the call to all of the TimeRange objects and see if any of them accept.</p>
			<p>My usual thanks to all for being so creative and giving me cool examples to show off in this summary.</p>
			<p>Tomorrow we will dig into just how editors are constructed...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275091">Rub&eacute;n Mart&iacute;nez</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275092">Justin Ethier</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275097">Eric I.</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275117">Gordon Thiesfeld</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275134">Juanger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275135">Ken Bloom</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275148">Yossef Mendelssohn</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275169">Philip Gatt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275183">Jes&uacute;s Gabriel y Gal&aacute;n</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275203">Kaushik Sridharan</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275202">Gordon Thiesfeld (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/275532">James Koppel</a></li>
			</ol>
			<p><a href="quiz144_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
