<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Quoted Printable (#23)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Quoted Printable (#23)</span>
			<p>The quoted printable encoding is used primarily in email, though it has recently seen some use in XML areas as well.  The encoding is simple to translate to and from.</p>
			<p>This week's quiz is to build a filter that handles quoted printable translation.</p>
			<p>Your script should be a standard Unix filter, reading from files listed on the command-line or STDIN and writing to STDOUT.  In normal operation, the script should encode all text read in the quoted printable format.  However, your script should also support a -d command-line option and when present, text should be decoded from quoted printable instead.  Finally, your script should understand a -x command-line option and when given, it should encode &lt;, &gt; and &amp; for use with XML.</p>
			<p>Here are the rules we will use, from the quoted printable format:</p>
			<p class="example">1.  Bytes with ASCII values from 33 (exclamation point) through 60 (less<br />    than) and values from 62 (greater than) through 126 (tilde) should be<br />    passed through the encoding process unchanged.  Note that the -x switch<br />    modifies this rule slightly, as stated above.<br /><br />2.  Other bytes are to be encoded as an equals sign (=) followed by two<br />    hexadecimal digits.  For example, when -x is active less than (&lt;) will<br />    become =3C.  Use only capital letters for hex digits.<br /><br />3.  The exceptions are spaces and tabs.  They should remain unencoded as<br />    long as any non-whitespace character follows them on the line.  Spaces<br />    and tabs at the end of a line, must be encoded per rule 2 above.<br /><br />4.  Native line endings should be translated to carriage return-line feed<br />    pairs.<br /><br />5.  Quoted printable lines are limited to 76 characters of length (not<br />    counting the line ending pair).  Longer lines must be divided up.  Any<br />    line endings added by the encoding process should be proceeded by an<br />    equals sign, so the unecoder will know to remove them.  The equals sign<br />    must be the last character on the line, followed immediately by the line<br />    end pair.  Such an equals sign does count as a non-whitespace character<br />    for rule 3, allowing preceding spaces and tabs to remain unencoded. <br />    The equals sign must fit inside the 76 character limit.</p>
			<p>To unecode, just reverse the process.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>It was pointed out, first in private email and later on Ruby Talk, that your quiz editor isn't quite up on all of Ruby's features.  Support for the Quoted Printable encoding is already in the language.  You can access this with the "M" format specification of Array.pack() and String.unpack().  Dave burt posted a modification to his solution using these features.  Here's that class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> String<br />     <span class="keyword">def</span> to_quoted_printable(*args)<br />       [<span class="keyword">self</span>].pack(<span class="string">"M"</span>).gsub(<span class="string">/\n/</span>, <span class="string">"\r\n"</span>)<br />     <span class="keyword">end</span><br />     <span class="keyword">def</span> from_quoted_printable<br />       <span class="keyword">self</span>.gsub(<span class="string">/\r\n/</span>, <span class="string">"\n"</span>).unpack(<span class="string">"M"</span>).first<br />     <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Ruby's Quoted Printable encoder uses standard Unix line endings, which is why you see the gsub() translations to the specified carriage-return line-feed pairs above.  That doesn't handle the XML aspect of the quiz, but you can add that with a few more calls to gsub() at both ends.</p>
			<p>Ignoring my knowledge gap, we still have some interesting solutions to discuss.</p>
			<p>Let's start with a solution.  Here's Glenn Parker's code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby -w</span><br /><br />    require <span class="string">'getoptlong'</span><br /><br />    MaxLength = 76<br /><br />    <span class="keyword">def</span> main<br />      opts = GetoptLong.new(<br />        [ <span class="string">"-d"</span>, GetoptLong::NO_ARGUMENT ],<br />        [ <span class="string">"-x"</span>, GetoptLong::NO_ARGUMENT ]<br />      )<br />      <span class="global">$opt_decode</span> = <span class="keyword">false</span><br />      <span class="global">$opt_xml</span> = <span class="keyword">false</span><br />      opts.each <span class="keyword">do</span> |opt, arg|<br />        <span class="keyword">case</span> opt<br />        <span class="keyword">when</span> <span class="string">"-d"</span>: <span class="global">$opt_decode</span> = <span class="keyword">true</span><br />        <span class="keyword">when</span> <span class="string">"-x"</span>: <span class="global">$opt_xml</span> = <span class="keyword">true</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">if</span> <span class="global">$opt_decode</span><br />        decode_input<br />      <span class="keyword">else</span><br />        encode_input<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> encode_input<br />      STDOUT.binmode  <span class="comment"># We need to control the line-endings.</span><br />      <span class="keyword">while</span> (line = gets) <span class="keyword">do</span><br />        <span class="comment"># Note: String#chomp! swallows more than just $/.</span><br />        line.sub!(<span class="string">/#{$/</span>}<span class="global">$/</span>o, <span class="string">""</span>)<br />        <span class="comment"># Encode the entire line.</span><br />        line.gsub!(<span class="string">/[^\t -&lt;&gt;-~]+/</span>) { |str| encode_str(str) }<br />        line.gsub!(<span class="string">/[&amp;&lt;&gt;]+/</span>)       { |str| encode_str(str) } <span class="keyword">if</span> <span class="global">$opt_xml</span><br />        line.sub!(<span class="string">/\s*$/</span>)          { |str| encode_str(str) }<br />        <span class="comment"># Split the line up as needed.</span><br />        <span class="keyword">while</span> line.length &gt; MaxLength<br />          <span class="comment">### original code ###</span><br />          <span class="comment"># split = line.index("=", MaxLength - 4) - 1</span><br />          <span class="comment"># split = (MaxLength - 2) if split.nil? or (split &gt; MaxLength - 2)</span><br />          <span class="comment">### BUGFIX:  index() can return nil, so don't subtract -JEG2 ###</span><br />          split = line.index(<span class="string">"="</span>, MaxLength - 4)<br />          split = (MaxLength - 2) <span class="keyword">if</span> split.nil? <span class="keyword">or</span> ( split - 1 &gt;<br />                                                     MaxLength - 2 )<br />          <span class="comment">### END BUGFIX ###</span><br />          print line[0..split], <span class="string">"=\r\n"</span><br />          line = line[(split + 1)..-1]<br />        <span class="keyword">end</span><br />        print line, <span class="string">"\r\n"</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> encode_str(str)<br />      encoded = <span class="string">""</span><br />      str.each_byte { |c| encoded &lt;&lt; <span class="string">"=%02X"</span> % c }<br />      encoded<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> decode_input<br />      <span class="keyword">while</span> (line = gets) <span class="keyword">do</span><br />        line.chomp!<br />        line.gsub!(<span class="string">/=([\dA-F]{2})/</span>) { <span class="global">$1</span>.hex.chr }<br />        <span class="keyword">if</span> line[-1] == ?=<br />          print line[0..-2]<br />        <span class="keyword">else</span><br />          print line, <span class="global">$/</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    main<br /><br /></div></div>
			<p>Let me talk a little about that shebang line.  It doesn't work on my system:</p>
			<p class="example">$ chmod +x quoted_printable.rb <br />$ ./quoted_printable.rb <br />env: ruby -w: No such file or directory</p>
			<p>That's one of the minuses of using the "env ruby" trick.  If you don't want to hardcode the path and still want to enable warnings inside the script, the following works:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby</span><br />    <span class="global">$VERBOSE</span> = <span class="keyword">true</span>  <span class="comment"># enable warnings</span><br /><br /></div></div>
			<p>That doesn't have anything to do with the quiz, of course, and you could still run Glenn's code with "ruby quoted_printable.rb", but having been bitten by that same problem myself, I wanted to mention it.</p>
			<p>Getting back to the code, Glenn pulls in getoptlong, defines a constant to hold the line length, and then defines a method called main().  main() just parses command line options (setting the globals $opt_decode and $opt_xml as needed), then hands off work to either decode_input() or encode_input().</p>
			<p>For encoding, encode_input() handles most of the work.  It starts by shutting off line ending translation with a call to binmode().  I believe that's only needed when your code is running on Windows, but it's still a great habit to form anytime you're going to muck with raw line endings.</p>
			<p>From there, encode_input() loops over STDIN with a line-by-line read.  Note that it performs its own chomp() with a call to sub!().  The author explains why in his submission email:</p>
			<p class="example">I found it a bit more frustrating that String#chomp! is a greedier than <br />you might expect, discarding all sorts of potential line endings, <br />instead of limiting itself to $/.</p>
			<p>The next three substitutions encode the needed characters on the line.  They're just a combination of simple Regexps and calls to encode_str().  If you glance down at encode_str(), you can see that it's a very simple byte to hex translator.</p>
			<p>The final while loop in encode_input() breaks up long lines.  It looks more complex above, because I added a bug fix too it.  When running tests on the code, Glenn's script crashed on me.  The issue was that String.index() can return nil and you can't subtract 1 from nil.  I just moved the "- 1" down a line to work around this.</p>
			<p>The reason index() is called looking for an "=" is to prevent breaking up an already encoded character.  If there aren't any encoded characters, the line is split at MaxLength.</p>
			<p>This method of breaking up the lines can break lines mid-word.  You might want to consider trying to break them at word boundaries though.  A big advantage of Quoted Printable is that it's really a Base64-like encoding, that keeps plain text pretty readable.  That's why I suggested its use to embed data in XML.  To that end, breaking lines on word boundaries just enhances that characteristic.</p>
			<p>Getting back to the code one last time, decode_input() is even easier to follow.  It too is a line-by-line read, with a gsub!() used to unencode and a basic if statement used to unwrap lines (by dropping the = and not printing a line ending).</p>
			<p>The other solutions are all quite interesting and I do encourage everyone to check them out.  Most submissions modified String to add the conversions.  Matthew Moss also added foreach() style readers to IO.  Dave Burt included a nice set of test cases, used by himself and at least one other person.  Good stuff all around.</p>
			<p>My thanks to all who endure my mental lapses, and to those who gently correct me.  I need all the help I can get.</p>
			<p>Great news:  We have a record four quizzes queued up right now, all of them including some contribution from others!  I'm so pleased.  We'll start our run tomorrow with a quiz for people who know when to Hold'em and when to fold 'em...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133484">Glenn Parker</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133507">Matthew Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133524">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133583">Dave Burt (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133587">Patrick Hurley</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133656">Florian Gross</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133723">Patrick Hurley (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133772">Dave Burt (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133778">Patrick Hurley (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133868">Florian Gross (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/133977">Florian Gross (3)</a></li>
			</ol>
			<p><a href="quiz23_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
