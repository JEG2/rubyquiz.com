<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Literate Ruby (#102)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Literate Ruby (#102)</span>
			<p>by Justin Bailey</p>
			<p>"Literate Programming"[1] is an idea popularized by Donald Knuth, where the traditional order of code and comments in a source file is switched. Instead of using special delimiters to mark comments, special delimiters are used to mark *code*.</p>
			<p>Innocuous as it sounds, this style of programming makes for a great way to post code snippets, tutorials, or even whole libraries to mailing lists, blogs, and web pages. It's also an excellent way to develop your CS homework ;)</p>
			<p>There are, of course, a variety of ways to make a source file "literate". One popular method is called "bird notation". Code is delimited by lines starting with "&gt;":</p>
			<div class="code"><span class="type">ruby</span><div class="body">    &gt; puts <span class="string">"The first line of literate Ruby you may have ever seen"</span><br /><br /></div></div>
			<p>Another method, used in the Haskell language, is borrowed from LateX and makes it very easy to embed working code into longer papers:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    \<span class="keyword">begin</span>{code}<br />    puts <span class="string">"And here, we have"</span><br />    puts <span class="string">"the second and third lines of literate Ruby to be produced."</span><br />    \<span class="keyword">end</span>{code}<br /><br /></div></div>
			<p>Beyond *how* to represent literate code, a host of issues present themselves. Can a class, method, or even string span multiple code sections? Can the different styles of code demarcation be mixed in one file? How do you "escape" code demarcation? What about inserting the output of code lines into the same literate file?</p>
			<p>Your task is to enable literate Ruby. What that means is up to you. Is literate programming only available at the file level (e.g. only files ending in ".lrb" are considered literate)? Or is literate programming supported with eval/class_eval/module_eval? Would this enable embedded literated here (i.e. &lt;&lt;) docs?</p>
			<p>At the minimum, this quiz should be seen as a literate program, and your code should be able to run it!  [Editor's Note: The indention added to Ruby blocks in this quiz are a side effect of the Ruby Quiz software.  Feel free to remove them when treating this quiz as literate code.  --JEG2]</p>
			<p>Justin</p>
			<div class="code"><span class="type">ruby</span><div class="body">    &gt; puts <span class="string">"Here's to hoping you enjoyed the quiz!"</span><br /><br /></div></div>
			<p>[1] http://en.wikipedia.org/wiki/Literate_programming</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>We definitely have to do more quizzes where the nature of the problem encourages submitters to summarize their own solution!  Multiple submitters did just that, so I recommend taking the time to read through the submission emails if you haven't already.</p>
			<p>Before we get to the solutions, let me make sure everyone knows about the feature similar to this quiz already baked into Ruby.  You can often use the -x switch to execute code buried inside of normal content, like an email message.  Here's an example:</p>
			<p class="example">$ ruby -x fake_email.txt<br />This is for running Ruby code inside other text!<br /><br />The code is assumed to start at the Shebang line and end at __END__.<br />$ cat fake_email.txt<br />Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do<br />eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim<br />ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut<br />aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit<br />in voluptate velit esse cillum dolore eu fugiat nulla pariatur.<br />Excepteur sint occaecat cupidatat non proident, sunt in culpa qui<br />officia deserunt mollit anim id est laborum.<br /><br />#!/usr/bin/env ruby -w<br /><br />puts &lt;&lt;END_OUTPUT<br />This is for running Ruby code inside other text!<br /><br />The code is assumed to start at the Shebang line and end at __END__.<br />END_OUTPUT<br /><br />__END__<br /><br />Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do<br />eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim<br />ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut<br />aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit<br />in voluptate velit esse cillum dolore eu fugiat nulla pariatur.<br />Excepteur sint occaecat cupidatat non proident, sunt in culpa qui<br />officia deserunt mollit anim id est laborum.</p>
			<p>Of course, this is not perfect.  It does not handle documents that slowly build up code as they discuss it.  For that, we will need to go to the solutions.</p>
			<p>The parser for this quiz isn't overly complex to write.  Most people used a couple of regular expressions to locate the code.  Here is one such parser from Cameron Pope:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> LRB<br />      <span class="keyword">def</span> parse(io)<br />        current_state = :in_text<br />        io.each_line <span class="keyword">do</span> |line|<br />          <span class="keyword">if</span> current_state == :in_text<br />            <span class="keyword">case</span> line<br />            <span class="keyword">when</span> <span class="string">/^&gt;\s?(.*)/</span>: <span class="keyword">yield</span> :code, <span class="global">$1</span> + <span class="string">"\n"</span> <span class="keyword">if</span> block_given?<br />            <span class="keyword">when</span> <span class="string">/\\begin\{.*\}\s*.*/</span>: current_state = :in_code<br />            <span class="keyword">else</span> <span class="keyword">yield</span> :text, line <span class="keyword">if</span> block_given?<br />            <span class="keyword">end</span><br />          <span class="keyword">else</span><br />            <span class="keyword">case</span> line<br />              <span class="keyword">when</span> <span class="string">/\\end\{.*\}\s*.*/</span>: current_state = :in_text<br />              <span class="keyword">else</span> <span class="keyword">yield</span> :code, line <span class="keyword">if</span> block_given?<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span> <span class="comment"># class LRB</span><br /><br /></div></div>
			<p>This parser walks the passed IO object line by line.  Each line of content is yielded to the provided block along with a type identifier.  The parser begins by assuming the content it is reading is :text, and it yields lines with that type.  However, if a line begins with the email quote marker (&gt;), that line will be yielded with a :code type.  When a LaTeX style marker is found (\begin{code}), the parser switches modes to assume all following lines are now code, until it encounters the matching marker (\end{code}).</p>
			<p>With a parser in place, the interesting element becomes the supported forms of output.  Here are those methods from Cameron's code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'rubygems'</span><br />    require <span class="string">'bluecloth'</span><br />    <span class="keyword">class</span> LRB<br />      <span class="keyword">def</span> <span class="keyword">self</span>.to_code(io)<br />        code = String.new<br />        LRB.new.parse(io) <span class="keyword">do</span> |type, line|<br />          code &lt;&lt; line <span class="keyword">if</span> type == :code<br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> code<br />      <span class="keyword">end</span><br />      <span class="keyword">def</span> <span class="keyword">self</span>.to_markdown(io)<br />        doc = String.new<br />        LRB.new.parse(io) <span class="keyword">do</span> |type, line|<br />          <span class="keyword">case</span> type<br />          <span class="keyword">when</span> :code: doc &lt;&lt; <span class="string">"    "</span> &lt;&lt; line<br />          <span class="keyword">when</span> :text: doc &lt;&lt; line<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> doc<br />      <span class="keyword">end</span><br />      <span class="keyword">def</span> <span class="keyword">self</span>.to_html(io)<br />        markdown = <span class="keyword">self</span>.to_markdown io<br />        doc = BlueCloth::new markdown<br />        doc.to_html<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span> <span class="comment"># class LRB</span><br /><br /></div></div>
			<p>The to_code() method is the most basic.  It just uses the parser to walk the document content, accumulating all of the code it finds along the way.  In the end, it returns the collected code.</p>
			<p>The to_markdown() method is similar, but it collects text and code.  Text is added normally, but code is indented four spaces to match the rules of Markdown.  The resulting Markdown content is returned.</p>
			<p>From there, to_html() is trivial.  The document is converted to Markdown using the method we just examined and then handed off to BlueCloth for translation.</p>
			<p>The Markdown option is a great fit here, since it was designed with human readability in mind.  The whole point of Literate Programming is to write about code, and we obviously want people to read what we write, so that's a good match.</p>
			<p>All we have left is Cameron's interface code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">if</span> <span class="global">$0</span> == <span class="keyword">__FILE__</span><br />     opt = ARGV.shift<br />     file = ARGV.shift<br />      <span class="keyword">case</span> opt<br />        <span class="keyword">when</span> <span class="string">'-c'</span>: puts LRB::to_code(File.new(file))<br />        <span class="keyword">when</span> <span class="string">'-t'</span>: puts LRB::to_markdown(File.new(file))<br />        <span class="keyword">when</span> <span class="string">'-h'</span>: puts LRB::to_html(File.new(file))<br />        <span class="keyword">when</span> <span class="string">'-e'</span>: eval LRB::to_code(File.new(file))<br />        <span class="keyword">else</span><br />          usage = &lt;&lt;<span class="string">"ENDING"</span><br />    Usage:<br />      lrb.rb [option] [file]<br /><br />    Options:<br />      -c: extract code<br />      -t: extract text documentation<br />      -h: extract html documentation<br />      -e: evaluate as Ruby program<br />    ENDING<br />        puts usage<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Here you see a simple set of four supported options.  The first three are the basic conversions we just examined.  The fourth option also pulls the code, but it eval()s it, instead of printing the results.</p>
			<p>Another step a couple of the solutions took was to enhance require() to locate .lrb files.  Here's an example of how this is accomplished, by Vincent Fourmond:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Here, we hack our way through require so that we can include</span><br />    <span class="comment"># .lrb files and understand them as literate ruby.</span><br />    <span class="keyword">module</span> Kernel<br />      <span class="keyword">alias</span> :old_kernel_require :require<br />      <span class="keyword">undef</span> :require<br />      <span class="keyword">def</span> require(file)<br />        <span class="comment"># if file doesn't have an extension, we look for it</span><br />        <span class="comment"># as a .lrb file.</span><br />        <span class="keyword">if</span> file =~ <span class="string">/\.[^\/]*$/</span><br />          old_kernel_require(file)<br />        <span class="keyword">else</span><br />          found = <span class="keyword">false</span><br />          <span class="keyword">for</span> path <span class="keyword">in</span> (<span class="global">$:</span>).map {|x| File.join(x, file + <span class="string">".lrb"</span>) }<br />            <span class="keyword">if</span> File.readable?(path)<br />              found = <span class="keyword">true</span><br />              RWeb::run_code(RWeb::unliterate_file(path).first,<br />                             <span class="keyword">self</span>.send(:binding))<br />              <span class="keyword">break</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />          old_kernel_require(file) <span class="keyword">unless</span> found<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The comments explain the process pretty well here.  The idea is to check for a .lrb file in Ruby's load path, for any require() without an extension.  If such a file is found, it's loaded via Vincent's RWeb Literate Ruby processor.  If not found or if the file had an extension, is is passed-through to Ruby's own require() for traditional handling.</p>
			<p>My thanks to all the people who unknowingly helped me design the quiz/summary format and parser for Ruby Quiz 2.0.  As always, the solutions introduced great new tricks I never would have thought of.</p>
			<p>Tomorrow we will tackle a question commonly asked on Ruby Talk in the hopes that we can answer if once and for all...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/225741">Louis J Scoras</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/225742">Vincent Fourmond</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/225744">Ken Bloom</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/225745">Ken Bloom (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/225753">Hugh Sasse</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/225782">Ross Bamford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/225837">Cameron Pope</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226019">Alex Wayne</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226184">Adam Shelly</a></li>
			</ol>
			<p><a href="quiz102_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
