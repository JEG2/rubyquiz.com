<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - DictionaryMatcher (#103)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">DictionaryMatcher (#103)</span>
			<p>by Ken Bloom</p>
			<p>From time to time someone asks on ruby-talk how they can write a regexp of the form:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="string">/alligator|crocodile|bear|dinosaur|...|seven-thousandth-word/</span><br /><br /></div></div>
			<p>It's not hard to write such a regexp, but Ruby has in internal limit on how big the regular expression can be, so users find they can't do this matching function easily.</p>
			<p>Implement a class DictionaryMatcher that determines whether any of the strings added to it are substrings of a string S. This should function as almost a drop-in replacement for a Regexp, therefore your implementation should support the following operations:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># creates a new empty matcher</span><br />    dm=DictionaryMatcher.new<br /><br />    <span class="comment"># adds strings to the matcher</span><br />    dm &lt;&lt; <span class="string">"string"</span><br />    dm &lt;&lt; <span class="string">"Ruby"</span><br /><br />    <span class="comment"># determines whether a given word was one of those added to the matcher</span><br />    dm.include?(<span class="string">"Ruby"</span>)                 <span class="comment"># =&gt; true</span><br />    dm.include?(<span class="string">"missing"</span>)              <span class="comment"># =&gt; false</span><br />    dm.include?(<span class="string">"stringing you along"</span>)  <span class="comment"># =&gt; false</span><br /><br />    <span class="comment"># Regexp-like substing search</span><br />    dm =~ <span class="string">"long string"</span>            <span class="comment"># =&gt; 5</span><br />    dm =~ <span class="string">"rub you the wrong way"</span>  <span class="comment"># =&gt; nil</span><br /><br />    <span class="comment"># will automatically work as a result of implementing</span><br />    <span class="comment"># DictionaryMatcher#=~ (see String#=~)</span><br />    <span class="string">"long string"</span> =~ dm  <span class="comment"># =&gt; true</span><br /><br />    <span class="comment"># implement the rest of the interface implemented by Regexps (well, almost)</span><br />    <span class="keyword">class</span> DictionaryMatcher<br />      alias_method :===, :=~<br />      alias_method :match, :=~<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>If you can add additional features, like a case insensitivity option when creating a new DictionaryMatcher this is also very useful.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>As stated in the quiz, this question comes up quite a bit.  There are a few ways to address including a fairly simple approach.  Let's examine Jamie Macey's rather short solution for an example of that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> DictionaryMatcher &lt; Array<br />     alias_method :===, :=~<br />     alias_method :match, :=~<br /><br />     <span class="keyword">def</span> initialize(default = [], options = <span class="keyword">nil</span>)<br />       <span class="keyword">super</span>(default)<br /><br />       <span class="keyword">unless</span> options.nil? <span class="keyword">or</span> options.is_a? Fixnum<br />         options = Regexp::IGNORECASE<br />       <span class="keyword">end</span><br />       <span class="variable">@regexp_options</span> = options<br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> =~(string)<br />       <span class="keyword">self</span>.map{|e| Regexp.new(e, <span class="variable">@regexp_options</span>) =~ string }.compact.min<br />     <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Jamie's idea is easy enough to follow:  DictionaryMatcher is just an Array of expressions and we can hit the String with them one at a time to find a match.  This code even has an advantage over many of the solutions in that the individual expressions themselves can be arbitrarily complex (full regular expressions).</p>
			<p>The big downside to this approach though is speed.  Unfortunately, it's a pretty big downside in this case because if you had been dealing with a small number of matches to begin with, you probably wouldn't have needed a DictionaryMatcher.  The main reason performance is bad is that all expressions must be tested, to find the match that occurs first in the String.  All that context shifting in and out of the regular expression engine just takes time.</p>
			<p>If we're going to get around that, we need a clever way to store the terms we are looking for and a custom match process that takes advantage of that data structure.</p>
			<p>The structure used by the majority of the solutions to store the words is called a trie or prefix tree.  Louis J Scoras wrote a solution using Trie objects, and even taught them how to display themselves.  This might help you see how this works.  Have a look at this example (with corrected indentation):</p>
			<div class="code"><span class="type">ruby</span><div class="body">    &gt;&gt; t = Trie.new<br />    =&gt;<br />    &gt;&gt; t[<span class="string">"cat"</span>] = <span class="keyword">true</span><br />    =&gt; <span class="keyword">true</span><br />    &gt;&gt; t[<span class="string">"cab"</span>] = <span class="keyword">true</span><br />    =&gt; <span class="keyword">true</span><br />    &gt;&gt; t[<span class="string">"cate"</span>] = <span class="keyword">true</span><br />    =&gt; <span class="keyword">true</span><br />    &gt;&gt; t[<span class="string">"bob"</span>] = <span class="keyword">true</span><br />    =&gt; <span class="keyword">true</span><br />    &gt;&gt; t<br />    =&gt; b =&gt;<br />         o =&gt;<br />           b =&gt;<br />             value: <span class="keyword">true</span><br />       c =&gt;<br />         a =&gt;<br />           b =&gt;<br />             value: <span class="keyword">true</span><br />           t =&gt;<br />             value: <span class="keyword">true</span><br />             e =&gt;<br />               value: <span class="keyword">true</span><br /><br /></div></div>
			<p>This structure is similar to a Hash, in that it has keys and values.  (Values are only used to indicate word boundaries, so we will leave those as true and focus on the keys.)  Where a Trie differs from a Hash is how it stores the keys.</p>
			<p>The key "cat" isn't stored as one complete String, instead it is stored as a separate "c", "a", and "t".  Those individual letters are nested beneath each other in the structure to indicate order.  "c" comes before the "a" beneath it, which comes before the "t" beneath it.</p>
			<p>Now, to add "cab" or even "cate" into the structure just involves adding in the new letters at the right depth.  "bob", on the other hand, begins a new tree, since it starts with a different letter.</p>
			<p>This structure can be used to make rather efficient large matches.  Where a Regexp has to ask does "cat", "cab", or "cate" match here, the tree version just checks to see if the "c" matches here.  When it does, more letters still need to be checked, but when it doesn't we instantly know that all "c" words are no good and we can move on.</p>
			<p>To see how that comes together, let's examine some of Ross Bamford's solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> DictionaryMatcher<br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> initialize(*words)<br />        <span class="variable">@pt</span> = {}<br />        words.each { |word| <span class="keyword">self</span> &lt;&lt; word }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> &lt;&lt;(word)<br />        <span class="comment"># small memory optimization - if there's a longer word that shares</span><br />        <span class="comment"># this prefix, we can discard it since we'll only ever take the</span><br />        <span class="comment"># shortest match anyway.</span><br />        word.split(<span class="string">''</span>).inject(<span class="variable">@pt</span>) <span class="keyword">do</span> |pt, chr|<br />          pt[chr] ||= {}<br />        <span class="keyword">end</span>.clear[:__WORD__] = <span class="keyword">true</span><br /><br />        <span class="keyword">self</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> match(str, start_ofs = 0)<br />        start_ofs.upto(str.length) <span class="keyword">do</span> |i|<br />          word = <span class="string">""</span><br />          next_pt = <span class="variable">@pt</span><br />          si = i<br />          <span class="keyword">while</span> next_pt = next_pt[chr = str[i,1]]<br />            word &lt;&lt; chr<br />            <span class="keyword">return</span> MatchData.new(si, i, word, str) <span class="keyword">if</span> next_pt[:__WORD__]<br />            i+=1<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">nil</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> =~(str)<br />        m = match(str) <span class="keyword">and</span> m.start_offset<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I've trimmed a lot of code here, but what I've shown is the heart of the matching algorithm.  Ross uses a simple set of nested Hashes to build his prefix tree (@pt) in initialize().</p>
			<p>Words are inserted into the tree in the &lt;&lt;() method.  It splits the word into letters, and walks the nested Hashes inserting each letter.  When it reaches the end of the word, any further nesting is cleared (an optimization explained in the comment) and the special :__WORD__ marker is inserted to indicate a word boundary.</p>
			<p>The rest of the magic is in the match() method.  It works much as I explained before.  It walks the String index by index.  If a character is found in the prefix tree, it tries to find a run of matches by walking the tree forward (the while loop).  When it makes it all the way to a word boundary marker, it declares victory by returning Ross's custom MatchData object (not shown).  If the tree walk fails, the code advances to the next index and when the indices are exhausted, nil is tossed to indicate that no match could be found.</p>
			<p>The =~() method also uses match(), but changes the return value to mimic Ruby.</p>
			<p>There's certainly more to see in the solutions and I hope this gives you enough of a map to encourage your own spelunking expidition into the code.  A big thank you to all of the programmers who helped reduce this FAQ to a link we can pass on to those who ask.</p>
			<p>Sharpen your turtles folks, because it's pretty picture drawing time with tomorrow's Ruby Quiz...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226825">Ken Bloom</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226833">Edwin Fine</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226837">Louis J Scoras</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226838">Adam</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226840">Jamie Macey</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226842">Ken Bloom (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226884">Ross Bamford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/227191">Ken Bloom (3)</a></li>
			</ol>
			<p><a href="quiz103_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
