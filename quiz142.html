<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Itinerary for a Traveling Salesman (#142)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Itinerary for a Traveling Salesman (#142)</span>
			<p>by Morton Goldberg</p>
			<p>A salesman wants to call on his customers, each of which is located in a different city.  He asks you to prepare an itinerary for him that will minimize his driving miles.  The itinerary must take him to each city exactly once and return him to his starting point. Can you write a Ruby program to generate such an itinerary?</p>
			<p>This problem is famous and known to be NP-complete. So how can you be expected to solve it as a weekend Ruby Quiz project?  It's unreasonable isn't it?  Yes, it is, unless the conditions are relaxed somewhat.</p>
			<p>First, let's restrict the problem to a space for which the solution is known: a grid of points as defined by the following Ruby code: </p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Square grid (order n**2, where n is an integer &gt; 1). Grid points are</span><br />    <span class="comment"># spaced on the unit lattice with (0, 0) at the lower left corner and</span><br />    <span class="comment"># (n-1, n-1) at the upper right.</span><br /><br />    <span class="keyword">class</span> Grid<br />       attr_reader :n, :pts, :min<br />       <span class="keyword">def</span> initialize(n)<br />          raise ArgumentError <span class="keyword">unless</span> Integer === n &amp;&amp; n &gt; 1<br />          <span class="variable">@n</span> = n<br />          <span class="variable">@pts</span> = []<br />          n.times <span class="keyword">do</span> |i|<br />             x = i.to_f<br />             n.times { |j| <span class="variable">@pts</span> &lt;&lt; [x, j.to_f] }<br />          <span class="keyword">end</span><br />          <span class="comment"># @min is length of any shortest tour traversing the grid.</span><br />          <span class="variable">@min</span> = n * n<br />          <span class="variable">@min</span> += Math::sqrt(2.0) - 1 <span class="keyword">if</span> <span class="variable">@n</span> &amp; 1 == 1<br />       <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Second, let's relax the requirement that the itinerary be truly minimal. Let's only require that it be nearly minimal, say, within 5%. Now you can tackle the problem with one of several heuristic optimization algorithms which run in polynomial time.  In particular, you could use a genetic algorithm (GA).</p>
			<p class="example">Genetic Algorithm (GA)</p>
			<p>From one point of view a GA is a stochastic technique for solving an optimization problem--for finding the extremum of a function.  From another point of view it is applied Darwinian evolution.</p>
			<p>To see how a GA works, let's look at some pseudocode.  </p>
			<p class="example">Step 1.  Generate a random initial population of itineraries.<br />Step 2.  Replicate each itinerary with some variation.<br />Step 3.  Rank the population according to a fitness function.<br />Step 4.  Reduce the population to a prescribed size,<br />         keeping only the best ranking itineraries.<br />Step 5.  Go to step 2 unless best itinerary meets an exit criterion.</p>
			<p>Simple, isn't it? But perhaps some discussion will be useful.</p>
			<p>Step 1.  You can get the points you need to generate a new random itinerary by calling <code>pts</code> on an instance <code>grid</code> of the <code>Grid</code> class shown above.</p>
			<p>Step 2.  GAs apply what are called <em>genetic operators</em> to replicas of the population to produce variation.  Genetic operators are usually referred to by biological sounding names such <em>mutation</em>, <em>recombination</em>, or <em>crossover</em>.  Recombination means some kind of permutation.  In my GA solution of the problem proposed here, I used two recombination operators, <em>exchange</em> and <em>reverse</em>.  Exchange means cutting an itinerary at three points (yielding four fragments) and swapping the middle two fragments.  Reverse means cutting an itinerary at two points (yielding three fragments) and reversing the order of the middle fragment.</p>
			<p>Step 3.  The fitness function for the traveling salesman problem can be the total distance traversed when following an itinerary (including the return to the starting point), or it can be a related function that reaches its minimum for exactly the same itineraries as does the total distance function.</p>
			<p>A GA can be rather slow, but has the advantage of being easy to implement.  My experience with problem I have proposed is that a GA can produce a solution meeting the 5% criterion reasonably quickly and that it can find an exact solution if given enough time.</p>
			<p class="example">An Exact Solution</p>
			<p>To give you an idea of how a solution looks when plotted, here is a picture of a minimal tour on a 7 X 7 grid.</p>
			<p style="text-align: center"><img src="images/7x7tour.jpg" alt="" width="313" height="314" /></p>
			<p>This exact solution was found by my Ruby GA solver in about two minutes.</p>
			<p class="example">Wikipedia Links</p>
			<p>Two Wikipedia pages have a great deal of relevant information on the topic of this quiz.  </p>
			<p><a href="http://en.wikipedia.org/wiki/Traveling_salesman_problem">Traveling salesman problem</a></p>
			<p><a href="http://en.wikipedia.org/wiki/Genetic_algorithm">Genetic algorithm</a></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>This time, we tried to put the focus on how you solved the quiz, instead of the solution itself.  A great aspect of genetic algorithms is that you really don't need to know much about the problem domain in order to find a workable solution for it.  That comes with tradeoffs though, naturally.  It takes longer to find a solution this way and there are no guarantees it will be great when you do settle on something.  Still, I think it's very valuable to examine just how these solutions work.</p>
			<p>I'm going to show Joseph Seaton's code here.  It's smaller than many of the solutions submitted, but still quite approachable.  It finds good answers pretty quickly on my box.</p>
			<p>Here's how the code begins:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby</span><br />    require <span class="string">'rubygems'</span><br />    require <span class="string">'rvg/rvg'</span><br />    require <span class="string">'grid'</span><br />    include Magick<br /><br />    <span class="keyword">class</span> GeneticGridGuess<br />     <span class="keyword">def</span> initialize grid<br />       <span class="variable">@grid</span>, <span class="variable">@min</span> = grid.pts, grid.min*1.05<br />       puts <span class="string">"Minumum time (within 5%): #{@min}"</span><br />       <span class="variable">@len</span>, <span class="variable">@seg</span> = <span class="variable">@grid</span>.length, (<span class="variable">@grid</span>.length*0.3).ceil<br />       <span class="variable">@psize</span> = Math.sqrt(<span class="variable">@len</span>).ceil*60<br />       <span class="variable">@mby</span> = (<span class="variable">@psize</span>/20).ceil<br />       <span class="variable">@pop</span> = []<br />       <span class="variable">@psize</span>.times <span class="keyword">do</span><br />         i = <span class="variable">@grid</span>.sort_by { rand }<br />         <span class="variable">@pop</span> &lt;&lt; [dist(i),i]<br />       <span class="keyword">end</span><br />       popsort<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>When I first read the requires for this script, I didn't know what rvg was.  I went searching for the library I needed to install and couldn't easily find one.  For those that don't know, rvg is a feature of RMagick that provides you with vector-based drawing tools.  If you have an up-to-date RMagick install, you have rvg as well.</p>
			<p>The constructor in this code should be pretty easy to digest.  It pulls the point list and minimum path for a passed Grid, careful to increase the minimum to our looser goal.  It also pulls the Grid.length() and uses that to build a size for mutated segments.  The @psize holds the population size our selections will be made from and @mby (for "multiply by," I assume) is a multiplier used in the reproduction process.  The rest of the code here just builds the initial population from random sorts of the points.</p>
			<p>Next, let's have a peek at the two helper methods used above:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> dist i<br />       <span class="comment">#Uninteresting but fast as I can make it:</span><br />       t = 0<br />       g = i+[i[0]]<br />       <span class="variable">@len</span>.times <span class="keyword">do</span> |e|<br />          t += Math.sqrt((g[e][0]-g[e+1][0])**2+(g[e][1]-g[e+1][1])**2)<br />       <span class="keyword">end</span><br />       t<br />     <span class="keyword">end</span><br />     <span class="keyword">def</span> popsort<br />       <span class="variable">@pop</span> = <span class="variable">@pop</span>.sort_by { |e| e[0] }<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>The dist() method provides a standard Euclidean Distance measure and popsort() just sorts the current population by this measure.  The thing to note here is that the population is always stored as a dist(), followed by the path.  This prevents needing to recalculate the dist() multiple times.</p>
			<p>The final two methods of this class do the real work in the solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> solve<br />       <span class="keyword">while</span> iter[0] &gt; <span class="variable">@min</span><br />         puts <span class="variable">@pop</span>[0][0]<br />       <span class="keyword">end</span><br />       <span class="variable">@pop</span>[0]<br />     <span class="keyword">end</span><br />     <span class="keyword">def</span> iter<br />       <span class="variable">@pop</span> = (<span class="variable">@pop</span>[0..20]*<span class="variable">@mby</span>).collect <span class="keyword">do</span> |e|<br />         n = e[1].dup<br />         <span class="keyword">case</span> rand(10)<br />         <span class="keyword">when</span> 0..6 <span class="comment">#Guesses concerning these values</span><br />           seg = rand(<span class="variable">@seg</span>)<br />           r = rand(<span class="variable">@grid</span>.length-seg+1)<br />           n[r,seg] = n[r,seg].reverse<br />         <span class="keyword">when</span> 7<br />           n = n.slice!(rand(<span class="variable">@grid</span>.length)..-1) + n<br />         <span class="keyword">when</span> 8..9<br />           r = []<br />           3.times { r &lt;&lt; rand(<span class="variable">@grid</span>.length)}<br />           r.sort!<br />           n = n[0...r[0]] + n[r[1]...r[2]] + n[r[0]...r[1]] + n[r[2]..-1]<br />         <span class="keyword">end</span><br />         [dist(n),n]<br />       <span class="keyword">end</span><br />       popsort<br />       <span class="variable">@pop</span>[0]<br />     <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The solve() method drives the process, continuing the search until a solution drops below our minimum accepted fitness measure.  Many solutions also used time as a cut-off factor and I would recommend that approach.  Genetic algorithms don't guarantee a solution and even when they do find one it could take quite some time.</p>
			<p>The iter() method moves the population forward one generation.  The process is simple:  select the best 20 members of the current population, multiply that set by some factor, mutate each member of the expanded set in some way, and save the result as our new population.  The population is then resorted and the best returned.</p>
			<p>I believe there's a small error in that code.  Since the whole population is mutated, it is possible that a better solution could be discarded and replaced by inferior solutions.  The code should probably also save the best solution seen thus far, just in case.</p>
			<p>The mutations are largely from the quiz description.  70% of the time a reverse mutation is performed and 20% of the time an exchange mutation.  10% of the time, a variation of the exchange is used where just two random segments are traded.</p>
			<p>These are all asexual mutations, but some did try crossovers.  An ordered crossover works pretty well in this case.  With that approach you select two parents, pick a crossover point in the path, and build two offspring from transforms around that point.  The first child has the points of the first parent up to the crossover point, but the later points are reordered to match the second parent.  This is reversed in the second child.</p>
			<p>With the framework in place, we're ready to see the application code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    gridsize = ARGV[0] ? ARGV[0].to_i : (print <span class="string">"Grid size: "</span>; STDIN.gets.to_i)<br />    grid = GeneticGridGuess.new(Grid.new(gridsize)).solve<br /><br />    puts <span class="string">"In time #{grid[0]}:"</span><br />    grid[1].each <span class="keyword">do</span> |e|<br />     print <span class="string">"#{e[0].to_i},#{e[1].to_i} "</span><br />    <span class="keyword">end</span><br />    puts<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The first line of this code pulls the grid size from a command-line argument or STDIN.  The second line builds the Grid, creates the solver, and puts it to work.  The rest of the code just prints the points of the best solution.</p>
			<p>Though that's enough to give us some boring numerical output, Joseph also had code to draw pretty pictures:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> !ARGV[1]<br />     image = RVG.new(gridsize*100,gridsize*100) <span class="keyword">do</span> |canvas|<br />       canvas.background_fill = <span class="string">'white'</span><br />       cgrid = grid[1].collect <span class="keyword">do</span> |e|<br />         [e[0]*100+10,e[1]*100+10]<br />       <span class="keyword">end</span><br />       cgrid.each <span class="keyword">do</span> |point|<br />         canvas.circle(5,point[0],point[1]).styles(:fill=&gt;<span class="string">'black'</span>)<br />       <span class="keyword">end</span><br />       canvas.polygon(*cgrid.flatten).<br />              styles(:stroke=&gt;<span class="string">'black'</span>, :stroke_width=&gt;2, :fill=&gt;<span class="string">'none'</span>)<br />     <span class="keyword">end</span>.draw<br />     image.display <span class="keyword">rescue</span> image.write(<span class="string">"#{gridsize}x#{gridsize}tour.jpg"</span>)<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I made a small change in this code so it would draw the picture to disk when the X Window library needed for display is not available.</p>
			<p>This code is run if a second command-line argument is not given to disable it.  It works by creating a canvas, plotting each point in the path on that canvas, and finally adding a polygon to represent the path found by the solver.  As you can see, RMagick's RVG class simplifies the shape drawing quite a bit.</p>
			<p>My thanks to all the geneticists brave enough to share your Frankenstein creations with the rest of us.</p>
			<p>Tomorrow we will try generating search results instead of travel plans...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273002">steve d</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273010">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273061">Dave Pederson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273035">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273125">Eugene Kalenkovich</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273218">Joseph Seaton</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273292">Eric I.</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273391">Morton Goldberg</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/273518">Morton Goldberg (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/284201">Sander Land</a></li>
			</ol>
			<p><a href="quiz142_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
