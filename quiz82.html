<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Running Coach (#82)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Running Coach (#82)</span>
			<p>by Benjohn Barnes</p>
			<p>I've started to jog with my girlfriend. It's hell. We're following a "programme" at this web site:</p>
			<p><a href="http://www.coolrunning.com/engine/2/2_3/181.shtml">The Couch-to-5K Running Plan</a></p>
			<p>The aim is to get you from being able to alternate hobbling and brisk walking, to being able to jog for 20 minutes solidly. Over eight weeks you exercise for twenty minutes, three times a week. Over the eight weeks, the ratio of jog to walk steadily increases, and the jogs get longer, while the walks become shorter.</p>
			<p>I was explaining to a friend that it's incredibly difficult for me to look at a stop watch and work out in my head if we're supposed to be jogging or walking, how many more jogs we've got to do, and when I can stop and rest. He suggested: 'why not tape yourself giving prompts about when to start and stop'. A brilliant plan. 'Even better, record it on to your phone'. Genius! Except I'm the kind of person who's lazy enough to spend eight times as long writing a program to try to do this for me.</p>
			<p>So, the quiz is:</p>
			<p>Write a program to create the tracks for each of the eight weeks. Make it give helpful and enthusiastic advice like "you've got to run for another minute / 30 seconds / 15 seconds ...", "walk now for two minutes, you've got three jogs left", "you're on jog 2 of 6", or "well done, that's your last jog. Don't forget to cool down and stretch!"</p>
			<p>I just used my Mac's speech synth, and parked my phone near to the speaker on record, in a quiet room (except for the planes every minute heading down to Heathrow). There'd be "bonus points" for actually creating the MP3 directly. Of course, you don't really need to get the computer to speak. It could just print out the messages at the appropriate time.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>This quiz turns out to be a little bit of work, if you want to get some decent feedback to the user.  Adam Shelly hammered out a reasonably complete solution though, so let's have a look at it:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="global">$CheerThreshold</span> = 6   <span class="comment">#decrease to get more random encouragement</span><br />    <span class="global">$LongThreshold</span> = 120  <span class="comment">#minimum time to be considered a "long" run</span><br /><br />    <span class="keyword">class</span> Phase<br />     attr_reader :action, :seconds<br />     <span class="keyword">def</span> initialize action, time<br />       <span class="variable">@action</span> = action.downcase<br />       <span class="variable">@seconds</span> = time.to_i<br />     <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>We can see some setup work here for variables that allow users to tweak the output.  We also have the trivial Phase class definition, which is just a data class for linking actions and times.</p>
			<p>Here's the main event loop:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Coach<br />     <span class="keyword">def</span> initialize filename<br />       File.open(filename) {|f|<br />         <span class="variable">@rawdata</span> = f.read.split(<span class="string">"\n"</span>)<br />       }<br />       <span class="variable">@duration</span> = 0<br />       <span class="variable">@runs</span> = <span class="variable">@longs</span> = <span class="variable">@walks</span> = 0<br />       <span class="variable">@encouragometer</span> = 0<br />       <span class="variable">@step</span> = [30,15,10,5,5]<br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> coach<br />       build_timeline<br />       say summarize(2)<br />       say start_prompt<br />       <span class="variable">@time</span> = Time.now<br />       <span class="variable">@target_time</span> = <span class="variable">@time</span><br />       <span class="keyword">while</span> (phase = <span class="variable">@phases</span>.shift)<br />         update_summary phase<br />         narrate_phase phase<br />         <span class="keyword">if</span> <span class="variable">@phases</span>.size &gt; 0<br />           say transition(<span class="variable">@phases</span>[0].action)<br />           say summarize(rand(2))<br />         <span class="keyword">end</span><br />       <span class="keyword">end</span><br />       say finish_line<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>There's nothing too interesting about initialize() which is just assigning defaults to the instance variables.  Have a look at the coach() method though.  This is the process the application runs through, and I really like how well it reads.  It builds up the timeline of events, hits user with a summary and starting prompt, then launches into Phase processing.  Each Phase is narrated to the user, and then the code transitions naturally to the next Phase.  Finally the code sends the finish line message to indicate a successful workout.</p>
			<p>Let's see what narrating a phase involves:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> narrate_phase phase<br />       say what_to_do_for(phase)<br />       <span class="variable">@target_time</span> += phase.seconds<br />       delta = (<span class="variable">@target_time</span> - Time.now).to_i<br />       stepidx = 0<br />       <span class="keyword">while</span> (delta &gt; 0)<br />         stepidx+=1 <span class="keyword">if</span> delta &lt; <span class="variable">@step</span>[stepidx]+1<br />         wait_time = delta % <span class="variable">@step</span>[stepidx]<br />         wait_time += <span class="variable">@step</span>[stepidx] <span class="keyword">if</span> wait_time &lt;= 0<br />         wait(wait_time)<br />         delta = (<span class="variable">@target_time</span> - Time.now).to_i<br />         encourage_maybe<br />         say whats_left(phase.action,delta) <span class="keyword">if</span> delta &gt; 0<br />       <span class="keyword">end</span><br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>Obviously, this method is mostly about time management.  It breaks a Phase down into smaller chunks, so that it can provide encouragement frequently and inform the user of what is left to be done.</p>
			<p>Note the clever output messages here again that read so naturally:  what_to_do_for(), encourage_maybe(), and whats_left().</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> update_summary phase<br />       <span class="variable">@duration</span> -= phase.seconds<br />       <span class="variable">@runs</span> -= 1 <span class="keyword">if</span> phase.action == <span class="string">'run'</span><br />       <span class="variable">@longs</span> -= 1 <span class="keyword">if</span> phase.action == <span class="string">'run'</span> <span class="keyword">and</span> phase.seconds &gt;= <span class="global">$LongThreshold</span><br />       <span class="variable">@walks</span> -= 1 <span class="keyword">if</span> phase.action == <span class="string">'walk'</span><br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> build_timeline<br />       <span class="variable">@phases</span> = <span class="variable">@rawdata</span>.map {|command|<br />         p = Phase.new(*command.split)<br />         <span class="variable">@duration</span> += p.seconds<br />         <span class="variable">@runs</span> += 1 <span class="keyword">if</span> p.action == <span class="string">'run'</span><br />         <span class="variable">@longs</span> += 1 <span class="keyword">if</span> p.action == <span class="string">'run'</span> <span class="keyword">and</span> p.seconds &gt;= <span class="global">$LongThreshold</span><br />         <span class="variable">@walks</span> += 1 <span class="keyword">if</span> p.action == <span class="string">'walk'</span><br />         p<br />       }<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>These two methods are quite similar save that one adds and the other subtracts.  First, build_timeline() constructs the Phase objects from the import file.  As it goes through, it counts things like the total number of walks and runs a person needs to complete.  Then, update_summary() runs inside each Phase of the event loop ticking off the walks and runs the user has completed.</p>
			<p>Here's the say() method that would eventually need to be replaced with speech programming:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> say s<br />       puts s<br />       <span class="comment">#todo: replace with speech</span><br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>Now, take a look at this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> wait n<br />         <span class="keyword">if</span> <span class="global">$DEBUG</span><br />           puts <span class="string">"...waiting #{n} seconds..."</span><br />           <span class="variable">@target_time</span> -= n<br />         <span class="keyword">else</span><br />           <span class="global">$stdout</span>.flush<br />           sleep(n)<br />         <span class="keyword">end</span><br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is obviously the delay method and it mainly just calls sleep().  However, I like how it can be set to just explain what the pause would have been, in $DEBUG mode.  That makes testing the application much more pleasant.</p>
			<p>Two more helper methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="keyword">def</span> encourage_maybe<br />       <span class="variable">@encouragometer</span> += rand(3)<br />       <span class="keyword">if</span> (<span class="variable">@encouragometer</span> &gt; <span class="global">$CheerThreshold</span>)<br />         say cheer<br />         <span class="variable">@encouragometer</span> = 0<br />       <span class="keyword">end</span><br />     <span class="keyword">end</span><br /><br />     <span class="keyword">def</span> timesay secs<br />       secs = secs.to_i<br />       s = <span class="string">""</span><br />       <span class="keyword">if</span> secs &gt; 60<br />         min = secs/60<br />         secs -= min*60<br />         s += <span class="string">"#{min} minute"</span><br />         s += <span class="string">'s'</span> <span class="keyword">if</span> min &gt; 1<br />         s += <span class="string">' and '</span> <span class="keyword">if</span> secs &gt; 0<br />       <span class="keyword">end</span><br />       <span class="keyword">if</span> secs &gt; 0<br />         s += <span class="string">"#{secs} second"</span><br />         s += <span class="string">'s'</span> <span class="keyword">if</span> secs &gt; 1<br />       <span class="keyword">end</span><br />       s<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ...</span><br /><br /></div></div>
			<p>There's the definition for the encourage_maybe() call I pointed out earlier.  It just randomly decides if a cheer should be emitted.</p>
			<p>The other method, timesay(), is a helper like we are use to in Rails.  It just humanizes the output of some number of seconds by breaking it into minutes and seconds.</p>
			<p>Next the code has several output methods, of which I'll just show a couple:</p>
			<div class="code"><span class="type">ruby</span><div class="body">     <span class="comment"># ...</span><br /><br />     <span class="comment"># All the phrases should be below this line, not mixed up in the logic</span><br />     <span class="keyword">def</span> what_to_do_for phase<br />       s = <span class="string">"#{phase.action} for #{timesay(phase.seconds)} \n"</span><br />       s += <span class="string">"You are almost done"</span> <span class="keyword">if</span> <span class="variable">@phases</span>.size == 1<br />       s<br />     <span class="keyword">end</span><br />     <span class="keyword">def</span> whats_left act, time<br />       timestr = timesay(time)<br />       s = [<br />         <span class="string">"You have #{timestr} more to #{act}"</span>,<br />         <span class="string">"#{act} for #{timestr} more"</span>,<br />         <span class="string">"only #{timestr} left of #{act}ing"</span>,<br />         <span class="string">"You have #{timestr} more to #{act}"</span>,<br />         <span class="string">"#{timestr} left in this phase"</span>,<br />         <span class="string">"There are #{timestr} until the next activity"</span><br />       ]<br />       s[rand(s.size)]<br />     <span class="keyword">end</span><br /><br />     <span class="comment"># ... several more output routines not shown ...</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>You can see that these methods just use simple conditional logic or random picks to vary the program's output.  With several of these methods, the end result is a fairly good mix of prompts for the user.</p>
			<p>Here's the last line that turns it into a solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    Coach.new(ARGV[0]||<span class="string">"week3.txt"</span>).coach<br /><br /></div></div>
			<p>My thanks to those who stole the time from their busy running schedules to code up a solution.  These scripts should have us all in shape by RubyConf!</p>
			<p>Tomorrow, we will try an extremely common computerism, but see if we can handle it a little better than the usual treatment...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/196965">Benjohn Barnes</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/197123">Adam Shelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/197244">Leslie Viljoen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/197578">Adam Shelly (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/197779">Adam Shelly (3)</a></li>
			</ol>
			<p><a href="quiz82_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
