<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Twisting a Rope (#137)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Twisting a Rope (#137)</span>
			<p>by John Miller</p>
			<p>This week's task is to implement the Rope data structure as a Ruby class.  This topic comes out of the ICFP programming competition (http://www.icfpcontest.com/) which had competitors manipulating a 7.5 million character string this year.</p>
			<p class="example">What is a Rope:</p>
			<p>You may not realize it, but for many changes to the content of a String, Ruby creates a new copy of the original with the modifications applied.  For small strings that are created once and read often this is actually a very efficient way to do thing, but what happens when the string starts to get long, and is undergoing a lot of changes?  First, the program will spend more and more of its processing cycles just copying bits around.  Second, the garbage collector will be called more and more often to pick up the little stringy scraps you've left all over the memory.</p>
			<p>Ropes (the name is a pun for a heavy duty string) are tree structures where a node represents the concatenation of its left branch with its right, and leaves are flat strings. (This is a little sloppy. A rope may contain shared subtrees, and is thus really a directed acyclic graph, where the out-edges of each vertex are ordered. We will continue to be sloppy.)  E.g. To prepend Text A to Text B, one creates a Node (call it N1) with A as its left branch and B as its right.   To further append Text C create a new Node N2 with its left branch pointing to  N1 and its right to C.  Easy, right?  To find out more see Boehm, Atkinson and  Plass "Ropes: an Alternative to Strings" at:</p>
			<p><a href="http://rubyurl.com/2FRbO">Ropes: an Alternative to Strings</a></p>
			<p>The task comes in three parts, each increasing in difficulty:</p>
			<p>Part one:</p>
			<p>Create a Rope class that can do the following:</p>
			<p class="example">a. 'append' or 'prepend' a String or another Rope <br />   (alias the &lt;&lt; operator to the append function)     <br />b. Return the fully concatenated text with 'to_s' <br />c. define 'slice' to call to_s.slice  <br />d. provide a 'length' method</p>
			<p>Part two:</p>
			<p>Add the following:</p>
			<p class="example">a. Add the ability to 'index' a single character given a 0-based offset<br />   from the beginning of the string.<br />b. Add the ability to 'shift' a single character from the front of a Rope.<br />   (Remove and return the character) <br />c. Add your own 'slice' method that returns a String. Implement as many of <br />   the String method's forms as possible.  To run the example code this<br />   function will only need to understand the slice(offset,length) form.<br />   Major Bonus for Regex and Substring forms. <br />d. "Balance" the tree with a 'normalize' method. <br />   (see Boehm, Atkinson and Plass 1319 Rebalancing)</p>
			<p>Part three: (bonus)</p>
			<p>Add the following:</p>
			<p class="example">a. Change the 'slice' method to return a Rope. Ideally this method should<br />   do as little string copying as possible. (Doing this will well<br />   dramatically increase the speed of the example code)<br />b. Allow 'shift' to optionally accept an integer number of characters to<br />   remove and return.<br />c. modify the '&lt;&lt;' operator so that can efficiently append a few<br />   characters at a time. (see Boehm, Atkinson and Plass 1318 para. 4)<br />d. *Major Bonus* Add the ability to append and prepend IO classes in a<br />   lazy fashion. (see Boehm, Atkinson and Plass 1318 para. 2)</p>
			<p>The following code may help you explore how efficient your code is and show where Ropes are useful.  `ruby -r /path/to/your/rope/class this_script.rb Rope` will run the test with your code.  Run the script without arguments to see how well String does.  Also play around with the SIZE and CHUNKS constants to get a feel for how they affect performance.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'benchmark'</span><br /><br />    <span class="comment">#This code make a String/Rope of  CHUNCKS chunks of text</span><br />    <span class="comment">#each chunck is SIZE bytes long.  Each chunck starts with </span><br />    <span class="comment">#an 8 byte number.  Initially the chuncks are shuffled the</span><br />    <span class="comment">#qsort method sorts them into ascending order.</span><br />    <span class="comment">#</span><br />    <span class="comment">#pass the name of the class to use as a parameter</span><br />    <span class="comment">#ruby -r rope.rb this_file Rope</span><br /><br />    puts <span class="string">'preparing data...'</span><br />    TextClass = Object.const_get(ARGV.shift || :String)<br /><br />    <span class="keyword">def</span> qsort(text)<br />      <span class="keyword">return</span> TextClass.new <span class="keyword">if</span> text.length == 0<br />      pivot = text.slice(0,8).to_s.to_i<br />      less = TextClass.new<br />      more = TextClass.new<br />      offset = 8+SIZE<br />      <span class="keyword">while</span> (offset &lt; text.length)<br />        i = text.slice(offset,8).to_s.to_i<br />        (i &lt; pivot ? less : more) &lt;&lt; text.slice(offset,8+SIZE)<br />        offset = offset + 8+SIZE<br />      <span class="keyword">end</span><br />      print <span class="string">"*"</span><br />      <span class="keyword">return</span> qsort(less) &lt;&lt; text.slice(0,8+SIZE) &lt;&lt; qsort(more)<br />    <span class="keyword">end</span><br /><br />    SIZE  = 512 * 1024<br />    CHUNCKS = 128<br />    CHARS = <span class="string">%w[R O P E]</span><br />    data = TextClass.new<br />    bulk_string =<br />      TextClass.new(Array.new(SIZE) { CHARS[rand(4)] }.join)<br />    puts <span class="string">'Building Text...'</span><br />    build = Benchmark.measure <span class="keyword">do</span><br />      (0..CHUNCKS).sort_by { rand }.each <span class="keyword">do</span> |n|<br />        data&lt;&lt; sprintf(<span class="string">"%08i"</span>,n) &lt;&lt; bulk_string<br />      <span class="keyword">end</span><br />      data.normalize  <span class="keyword">if</span> data.respond_to? :normalize<br />    <span class="keyword">end</span><br />    GC.start<br />    sort = Benchmark.measure <span class="keyword">do</span><br />      puts <span class="string">"Sorting Text..."</span><br />      qsort(data)<br />      puts<span class="string">"\nEND"</span><br />    <span class="keyword">end</span><br /><br />    puts <span class="string">"Build: #{build}Sort: #{sort}"</span><br /></div></div>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>The discussion for this quiz was very interesting.  It's probably worth your time to go back and read those messages, if you haven't already.  Some points I got out of the discussion were:</p>
			<p class="example">* It's tricky to get ropes right.  Clever implementations may loose key<br />  rope qualities, like the O(1) concatenation time.<br />* The functional approach, building immutable ropes, is probably<br />  superior considering how ropes are intended to be used.<br />* Autorebalancing didn't hurt much, at least in the quiz test case.<br />* Copy-On-Write is helpful, when it works.</p>
			<p>Many of these points came out due to Eric Mahurin's work in benchmarking the submitted solutions.  Eric also submitted several variations of rope classes, a few of which I want to take a look at below.  Let's begin with the class Eric uses to build the rope trees:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> Mahurin<br />      <span class="keyword">class</span> Rope<br />        include Enumerable<br />        <span class="comment"># form a binary tree from two ropes (possibly sub-trees)</span><br />        <span class="keyword">def</span> initialize(left,right)<br />          <span class="variable">@left</span> = left<br />          <span class="variable">@right</span> = right<br />          <span class="variable">@llength</span> = <span class="variable">@left</span>.length<br />          <span class="variable">@length</span> = <span class="variable">@llength</span>+<span class="variable">@right</span>.length<br />          <span class="variable">@depth</span> = [left.depth, right.depth].max+1<br />        <span class="keyword">end</span><br />        <span class="comment"># number of elements in this rope</span><br />        <span class="keyword">def</span> length<br />          <span class="variable">@length</span><br />        <span class="keyword">end</span><br />        <span class="comment"># depth of the tree (to help keep the tree balanced)</span><br />        <span class="keyword">def</span> depth<br />          <span class="variable">@depth</span><br />        <span class="keyword">end</span><br />        <span class="comment"># left rope (not needed when depth==0)</span><br />        <span class="keyword">def</span> left<br />          <span class="variable">@left</span><br />        <span class="keyword">end</span><br />        <span class="comment"># right rope (not needed when depth==0)</span><br />        <span class="keyword">def</span> right<br />          <span class="variable">@right</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we see the setup and relevant attributes of Rope objects.  First we have the fact that they are binary trees, with left and right subtrees.  Next we see that Eric is going to track two lengths for Rope objects, both the total length and the length of just the left subtree.  The reasoning for that will become apparent when we examine indexing.  Finally, Eric tracks a depth, for use in rebalancing.</p>
			<p>There are really two major operations that are key to a Rope implementation:  concatenation and indexing.  Here's the concatenation side of the puzzle:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># appended rope (non-modifying)</span><br />        <span class="keyword">def</span> +(other)<br />          <span class="comment"># balance as an AVL tree</span><br />          balance = other.depth-<span class="variable">@depth</span><br />          <span class="keyword">if</span> balance&gt;+1<br />            left = other.left<br />            right = other.right<br />            <span class="keyword">if</span> left.depth&gt;right.depth<br />              <span class="comment"># rotate other to right before rotating self+other to left</span><br />              (<span class="keyword">self</span> + left.left) + (left.right + right)<br />            <span class="keyword">else</span><br />              <span class="comment"># rotate self+other to left</span><br />              (<span class="keyword">self</span> + left) + right<br />            <span class="keyword">end</span><br />          <span class="keyword">elsif</span> balance&lt;-1<br />            <span class="keyword">if</span> <span class="variable">@right</span>.depth&gt;<span class="variable">@left</span>.depth<br />              <span class="comment"># rotate self to left before rotating self+other to right</span><br />              (<span class="variable">@left</span> + <span class="variable">@right</span>.left) + (<span class="variable">@right</span>.right + other)<br />            <span class="keyword">else</span><br />              <span class="comment"># rotate self+other to right</span><br />              <span class="variable">@left</span> + (<span class="variable">@right</span> + other)<br />            <span class="keyword">end</span><br />          <span class="keyword">else</span><br />            <span class="keyword">self</span>.<span class="keyword">class</span>.new(<span class="keyword">self</span>, other)<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        alias_method(:&lt;&lt;, :+)<br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method is only this long because it automatically rebalances the tree as needed.  In fact, if you glance down to the final else clause, you will see the trivial implementation, which is just to construct a new Rope from the current Rope and the concatenated element.</p>
			<p>The rebalancing done here is, as the comment suggests, a textbook AVL implementation.  With an AVL tree, you subtract the left depth from the right depth to get a tree's balance factor.  Anything in the range of -1 to 1 is a balanced tree.  If the factor is outside of that range, one or two rotations are required to rebalance the tree.</p>
			<p>I'm not going to go into the specific rotations.  If you would like to read up on them, I recommend:</p>
			<p><a href="http://fortheloot.com/public/AVLTreeTutorial.rtf">The AVL Tree Rotations Tutorial</a></p>
			<p>Let's move on to the indexing methods used to pull information back out of a Rope:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># slice of the rope</span><br />      <span class="keyword">def</span> slice(start, len)<br />        <span class="keyword">return</span> <span class="keyword">self</span> <span class="keyword">if</span> start.zero? <span class="keyword">and</span> len==<span class="variable">@length</span><br />        rstart = start-<span class="variable">@llength</span><br />        <span class="keyword">return</span> <span class="variable">@right</span>.slice(rstart, len) <span class="keyword">if</span> rstart&gt;=0<br />        llen = <span class="variable">@llength</span>-start<br />        rlen = len-llen<br />        <span class="keyword">if</span> rlen&gt;0<br />          <span class="variable">@left</span>.slice(start, llen) + <span class="variable">@right</span>.slice(0, rlen)<br />        <span class="keyword">else</span><br />          <span class="variable">@left</span>.slice(start, len)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      <span class="comment"># element at a certain position in the rope</span><br />      <span class="keyword">def</span> at(index)<br />        rindex = index-<span class="variable">@llength</span><br />        <span class="keyword">if</span> rindex&lt;0<br />          <span class="variable">@left</span>.at(index)<br />        <span class="keyword">else</span><br />          <span class="variable">@right</span>.at(rindex)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Have a look at the at() method first, because it's easier to digest and it shows the concept of indexing this tree structure.  Essentially, to index in the tree you check a position against the left length.  If it's less than, index the left side.  If it's greater than, index the right.  This search tactic is the hallmark attribute of binary trees.</p>
			<p>The slice() method works the same way.  It's just more complicated because it has to work with two indices instead of one.  Finding the start index is the same strategy we saw in at().  If that index is in the right subtree, the end will be as well and the code makes the recursive hand-off without further checks.  When it's in the left, the end must be located.  If that end point turns out to also be in the left, the hand-off is made to the left side.  When it is in the right, a partial slice() is made from both halves and combined.  This covers all the cases.</p>
			<p>Eric added a couple more methods to the Rope class that cover iteration and converting to a String:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># iterate through the elements in the rope</span><br />        <span class="keyword">def</span> each(&amp;block)<br />          <span class="variable">@left</span>.each(&amp;block)<br />          <span class="variable">@right</span>.each(&amp;block)<br />        <span class="keyword">end</span><br />        <span class="comment"># flatten the rope into a string (optionally starting with a prefix)</span><br />        <span class="keyword">def</span> to_s(s=<span class="string">""</span>)<br />          <span class="variable">@right</span>.to_s(<span class="variable">@left</span>.to_s(s))<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>That covers the tree implementation.  What we haven't seen yet though, are the leaf nodes.  We need two types for the implementation I want to examine, EmptyRope and StringRope.  Here's the first of those:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      EmptyRope = Object.new<br />      <span class="keyword">class</span> &lt;&lt; EmptyRope<br />        include Enumerable<br />        <span class="keyword">def</span> length<br />          0<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> depth<br />          0<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> +(other)<br />          other<br />        <span class="keyword">end</span><br />        alias_method(:&lt;&lt;, :+)<br />        <span class="keyword">def</span> slice(start, len)<br />          <span class="keyword">self</span><br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> each<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> to_s<br />          <span class="string">""</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This implementation is kind of a poor man's singleton instance (the design pattern, not the Ruby concept, though we see both here).  There shouldn't be any surprises in this code.  The attributes are zeroed, concatenation results in whatever the concatenated element is, and slice()ing just returns self which doubles as an empty String.</p>
			<p>That leaves just one last leaf, StringRope:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">class</span> StringRope<br />        include Enumerable<br />        <span class="keyword">def</span> <span class="keyword">self</span>.new(*args)<br />          <span class="keyword">if</span> args.empty?<br />            EmptyRope<br />          <span class="keyword">else</span><br />            <span class="keyword">super</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> initialize(data)<br />          <span class="variable">@data</span> = data<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> length<br />          <span class="variable">@data</span>.length<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> depth<br />          0<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>This class just wraps a String to support the Rope API we've been examining.  About the only interesting trick here is the is that the default new() for this class is overridden to allow returning an EmptyRope as needed.  Anytime the argument is provided though, this method does hand-off to the default new() implementation.</p>
			<p>Here's the concatenation method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> +(other)<br />        balance = other.depth<br />        <span class="keyword">if</span> balance&gt;1<br />          left = other.left<br />          right = other.right<br />          <span class="keyword">if</span> left.depth&gt;right.depth<br />            <span class="comment"># rotate other to right before rotating self+other to left</span><br />            (<span class="keyword">self</span> + left.left) + (left.right + right)<br />          <span class="keyword">else</span><br />            <span class="comment"># rotate self+other to left</span><br />            (<span class="keyword">self</span> + left) + right<br />          <span class="keyword">end</span><br />        <span class="keyword">else</span><br />          Rope.new(<span class="keyword">self</span>, other)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      alias_method(:&lt;&lt;, :+)<br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>We see some more balance work here, but the algorithm is simplified since only the right side can be a subtree.  Beyond that, we've seen this code before.</p>
			<p>Here are the final few methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ..</span><br /><br />        <span class="keyword">def</span> slice(start, len)<br />          <span class="keyword">return</span> <span class="keyword">self</span> <span class="keyword">if</span> start.zero? <span class="keyword">and</span> len==<span class="variable">@data</span>.length<br />          <span class="comment"># depend on ruby's COW mechanism to just reference the slice data</span><br />          <span class="keyword">self</span>.<span class="keyword">class</span>.new(<span class="variable">@data</span>.slice(start, len))<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> at(index)<br />          <span class="variable">@data</span>[index]<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> each(&amp;block)<br />          <span class="variable">@data</span>.each_char(&amp;block)<br />        <span class="keyword">end</span><br />        <span class="keyword">def</span> to_s(s=<span class="string">""</span>)<br />          s.concat(<span class="variable">@data</span>.to_s)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Note here that slice() was overridden to return a StringRope instead of a String.  As the comment says, Ruby internally uses some Copy On Write semantics to reference sliced Strings.  This should keep it from wildly duplicating the data, but it was found that a couple of solutions had problems with this for unknown reasons.</p>
			<p>That covers a basic Rope implementation.  We won't bother to go into the destructive methods as you are probably better off working without them.</p>
			<p>My thanks to all who explored this newly popular data structure with us.  It looks like there will be a talk on ropes at this year's Rubyconf, so hopefully we gave the speaker some extra material to work with.</p>
			<p>This week's Ruby Quiz will start a day early, to adjust for my Lone Star Rubyconf schedule this weekend.  The no-spoiler period is still 48 hours and I will still summarize it at the same time, you just get an extra day to work on it.  Stay tuned for that problem in just a few minutes...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267193">Carl Porth</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267205">Himadri Choudhury</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267218">Carl Porth (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267300">Eric Mahurin</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267312">Mauricio Fernandez</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267314">Gustav Munkby</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267319">Mauricio Fernandez (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267401">Eugene Kalenkovich</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267437">Eric Mahurin (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267467">Eugene Kalenkovich (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267695">Carl Porth (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267834">Eugene Kalenkovich (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267842">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267867">Ari Brown</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/267987">Ari Brown (2)</a></li>
			</ol>
			<p><a href="quiz137_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
