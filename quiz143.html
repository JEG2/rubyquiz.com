<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Reverse the Polarity (#143)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Reverse the Polarity (#143)</span>
			<p>by Benjohn Barnes</p>
			<p>Usually, you write a regular expression and then search for it in a text string. How about doing the opposite? Given a regular expression, generate all of the strings that it will match.</p>
			<p>Rather amazingly, this has independently come up a couple of times in conversations with friends, so perhaps it's actually useful. I wanted to use it to specify possible domain names for a potential new company...</p>
			<p class="example">/(lovely|delicious|splendid)(food|snacks|munchies)/.generate<br />=&gt; [lovelyfood, deliciousfood, splendidfood,<br />    lovelysnacks, delicioussnacks, splendidsnacks,<br />    lovelymunchies, deliciousmunchies, splendidmunchies]</p>
			<p>The full regular expression grammar is pretty complex, so maybe you'll want to just go with a small subset. :-)</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I was glad to see this problem submitted.  I worked on it a ways back when I was translating examples from Higher-Order Perl.  It shows up in the book during the discussion of infinite streams.</p>
			<p>Watching others solve it was great fun because I realized that Ruby Quiz fans are crazy.  A couple of you implemented an almost scary amount of the regular expression syntax.</p>
			<p>Probably the craziest solution comes from Jesús who even shoehorned in backreferences.  Let's take a look at parts of that lengthy solution below.</p>
			<p>First, some limitations:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Number of times to repeat for Star and Plus repeaters</span><br />    TIMES = 2<br /><br />    <span class="comment"># Set of chars for Dot and negated [^] char groups</span><br />    <span class="comment">#CHARS = [("a".."z").to_a, ("A".."Z").to_a, ".", ",", ";"].flatten</span><br />    CHARS = <span class="string">%w{a b c d e}</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Many regular expressions can match an infinite number of Strings.  Consider the trivial expression /a+/.  It matches "a", "aa", "aaa", etc.  There are two ways to handle this practically:  limit the repetition or provide an infinite series of matches user code can explore and stop as needed.  Jesús did the former.</p>
			<p>These variables control how much repetition is done and what character set is used for constructs that match any character or any character not included in a listed subset.</p>
			<p>If your are curious to see the infinite streams approach, I wrote about it as part of this blog post:</p>
			<p><a href="http://blog.grayproductions.net/articles/infinite_streams">Infinite Streams</a></p>
			<p>That solution doesn't include the regular expression parsing code though.</p>
			<p>Getting back to Jesús's code, the next section defines several classes in the categories of repeaters and groups.  Groups are pieces of a matched String that can be generated and repeaters control how many times those groups appear.  Let's begin with a trivial repeater that doesn't really repeat:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> OneTimeRepeater<br />      <span class="keyword">def</span> initialize(group)<br />        <span class="variable">@group</span> = group<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> result<br />        <span class="variable">@group</span>.result<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>As, you can see, this repeater just wraps some group.  The result() of this repeater is the result of that group, one time.  Obviously this is used for things that don't repeat.</p>
			<p>The next repeater should be plenty familiar to regular expression fans though:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> StarRepeater<br />      <span class="keyword">def</span> initialize(group)<br />        <span class="variable">@group</span> = group<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> result<br />        r = []<br />        group_res = <span class="variable">@group</span>.result<br />        group_res.unshift(<span class="string">""</span>)<br />        TIMES.times <span class="keyword">do</span><br />          r &lt;&lt; group_res<br />        <span class="keyword">end</span><br />        combine(r).uniq<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This would be the repeater used to handle expressions like /a*/.  The result of this repeater is zero or more occurrences of the group it was passed.  Practically speaking here that means between one and TIMES copies of the group or the empty String to represent zero.  We see this collected into an Array here and passed on to combine() for generation.</p>
			<p>The PlusRepeater, QuestionMarkRepeater and RangeRepeater classes are constructed similarly.  In the interests of space and time, I'm not going to show those here.</p>
			<p>Now we are ready for the groups.  Again we begin with the trivial cases:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> SingleChar<br />      <span class="keyword">def</span> initialize(c)<br />        <span class="variable">@c</span> = c<br />      <span class="keyword">end</span><br />      <span class="keyword">def</span> result<br />        [<span class="variable">@c</span>]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Dot<br />      <span class="keyword">def</span> result<br />        CHARS<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we see groups that echo a character and represent a special range of characters as their results.  Obviously the first is used for literal chunks of an expression, like /a/, and the second is used for the special regular expression character /./.</p>
			<p>Let's examine the group used to represent alternations like /a|b/:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> OrGroup<br />      <span class="keyword">def</span> initialize(first_groupset, second_groupset)<br />        <span class="variable">@first</span> = first_groupset<br />        <span class="variable">@second</span> = second_groupset<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> result<br />        strings = <span class="variable">@first</span>.map {|x| x.result}<br />        s = combine(strings)<br />        strings = <span class="variable">@second</span>.map {|x| x.result}<br />        s.concat(combine(strings))<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Since the result()s of a group are just the possible generations of that group, alternation can be represented as the left choices plus the right choices.  That's what we see here.</p>
			<p>Jesús's code includes other groups:  CharGroup for character classes, MultiGroup for nesting groups and managing reference counts, and BackReference for supporting the regular expression feature of the same name.  I'm going to skip over these too, to keep the size of this summary reasonable.</p>
			<p>Now let's have a look at the combine() method I've glossed over twice now:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># Combines arrays, concatenating each string</span><br />    <span class="comment"># merging the possible groups they have</span><br />    <span class="comment"># Starts combining the first two arrays, then goes on</span><br />    <span class="comment"># combining each other array to the result of the</span><br />    <span class="comment"># previous combination</span><br />    <span class="keyword">def</span> combine(arrays)<br />     string = arrays.inject <span class="keyword">do</span> |r, rep|<br />       temp = []<br />       r.each {|aa| rep.each {|bb| temp &lt;&lt; (aa.concat_and_merge_groups(bb))}}<br />       temp<br />     <span class="keyword">end</span><br />     string<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> String<br />      attr_accessor :filled_groups<br /><br />      <span class="keyword">def</span> add_filled_group(num, group)<br />        <span class="variable">@filled_groups</span> ||= {}<br />        <span class="variable">@filled_groups</span>[num] = group<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> concat_and_merge_groups(other)<br />        temp = <span class="keyword">self</span> + other<br />        groups = {}<br />        groups.merge!(<span class="keyword">self</span>.filled_groups) <span class="keyword">if</span> <span class="keyword">self</span>.filled_groups<br />        groups.merge!(other.filled_groups) <span class="keyword">if</span> other.filled_groups<br />        temp.filled_groups = groups<br />        temp<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The combine() method just turns an Array of group result()s into the actual combinations of Strings.  So given [%w[a b], %w[c d]] it outputs %w[ac ad bc bd].</p>
			<p>The String additions here that are tracking groups were added to support backreferences.  This was a challenging feature to support and it required hooking into the code at many levels.  I don't want to focus on it too much though since it wasn't a critical part of the quiz so much as an impressive extra Jesús managed to include.</p>
			<p>The next method we need to look at is the parser.  I'm going to trim some of it because it's quite long, but you should still get to see how it's put together:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Regexp<br />      attr_reader :num_groups<br />      <span class="keyword">def</span> parse(s, i = 0)<br />        repeaters = []<br />        group = <span class="keyword">nil</span><br />        <span class="keyword">while</span> i &lt; s.length<br />          char = s[i].chr<br />          <span class="keyword">case</span> char<br />          <span class="comment"># ...</span><br />          <span class="keyword">when</span> <span class="string">'.'</span><br />            group = Dot.new<br />          <span class="keyword">when</span> <span class="string">'|'</span><br />            groups, i = parse(s, i + 1)<br />            group = OrGroup.new(repeaters, groups)<br />            <span class="keyword">return</span> [group], i<br />          <span class="comment"># ...</span><br />          <span class="keyword">else</span><br />            group = SingleChar.new(char)<br />          <span class="keyword">end</span><br /><br />          repeater = <span class="keyword">nil</span><br />          i += 1<br />          <span class="keyword">if</span> i &lt; s.length<br />            <span class="keyword">case</span> s[i].chr<br />            <span class="keyword">when</span> <span class="string">'*'</span><br />              repeater = StarRepeater.new(group)<br />            <span class="comment"># ...</span><br />            <span class="keyword">else</span><br />              repeater = OneTimeRepeater.new(group)<br />              i -= 1<br />            <span class="keyword">end</span><br />            i += 1<br />          <span class="keyword">else</span><br />            repeater = OneTimeRepeater.new(group)<br />          <span class="keyword">end</span><br />          repeaters &lt;&lt; repeater<br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> repeaters, i<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>As you can see, this is a recursive character by character parser.  It reads through the expression finding groups and wrapping those in repeaters, with whatever level of nesting is required.  This builds up an Abstract Syntax Tree for the expression.</p>
			<p>Let's see how this gets put to use to create the quiz solution method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> generate<br />        <span class="variable">@num_groups</span> = 0<br />        r = <span class="keyword">self</span>.inspect[1..-2]<br />        repeaters, _ = <span class="keyword">self</span>.parse(r)<br />        strings = repeaters.map {|x| x.result}<br />        s = combine(strings)<br />        <span class="comment"># Makes a pass for the backreferences</span><br />        s.each <span class="keyword">do</span> |string|<br />          string.gsub!(<span class="string">/__(\d+)__/</span>) <span class="keyword">do</span> |match|<br />            string.filled_groups[<span class="global">$1</span>.to_i]<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        s<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The process here is very simple:  pull the source of the expression, parse it into the AST, generate the result() of the AST, and combine() those Strings into the needed Array of matches.  Again, the rest of the code here is used to substitute backreferences back into the end results.</p>
			<p>Jesús also included another method that pretty-printed and verified results, but I won't go into that here.</p>
			<p>As usual I don't want you to miss out on the other solutions.  James Koppel used currying to build up an AST of functions.  Vasil Vangelovski sent in a slow but unique approach that works on all regular expressions without even parsing them.  Do take the time to inspect the solutions.  It's worth it.</p>
			<p>My thanks to all who poured so much effort into this quiz.  You are all fearless.</p>
			<p>Tomorrow we will take a stab at slicing up time...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274068">Justin Ethier</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274071">Evan Moseman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274072">Vasil Vangelovski</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274082">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274202">Jes&uacute;s Gabriel y Gal&aacute;n</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274323">James Koppel (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274326">Pusztai Tibor</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274332">Phrogz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/274375">Jes&uacute;s Gabriel y Gal&aacute;n (2)</a></li>
			</ol>
			<p><a href="quiz143_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
