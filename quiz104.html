<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Turtle Graphics (#104)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Turtle Graphics (#104)</span>
			<p>by Morton Goldberg</p>
			<p>[Editor's Note:  You can download the files for this quiz at:</p>
			<p><a href="http://rubyquiz.com/turtle.zip">Turtle Graphics Quiz Files</a></p>
			<p>--JEG2]</p>
			<p class="example">Turtle Graphics<br />===============</p>
			<p>Turtle graphics is a form of computer graphics based on the ideas of turtle geometry, a formulation of local (coordinate-free) geometry. As a brief introduction to turtle graphics, I quote from [1]:</p>
			<p class="example">Imagine that you have control of a little creature called a turtle<br />that exists in a mathematical plane or, better yet, on a computer<br />display screen. The turtle can respond to a few simple commands:<br />FORWARD moves the turtle in the direction it is facing some<br />number of units. RIGHT rotates it clockwise in its place some<br />number of degrees. BACK and LEFT cause the opposite movements. ...<br />The turtle can leave a trace of the places it has been: [its <br />movements] can cause lines to appear on the screen. This is<br />controlled by the commands PENUP and PENDOWN. When the pen is<br />down, the turtle draws lines.</p>
			<p>For example, the turtle commands to draw a square, 100 units on a side, can be written (in a Ruby-ized form) as:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    pen_down<br />    4.times { forward 100; right 90 }<br /><br /></div></div>
			<p>For more information, see [2] and [3].</p>
			<p>This quiz is a bit different from most. If the usual Ruby quiz can be likened to an essay exam, this one is a fill-in-the-blanks test. I'm supplying you with a complete turtle graphics package, except -- to give you something to do -- I've removed the method bodies from the key file, lib/turtle.rb. Your job is to repair the damage I've done and make the package work again.</p>
			<p class="example">Turtle Commands<br />===============</p>
			<p>There are quite a few turtle commands, but that doesn't mean you have to write a lot of code to solve this quiz. Most of the commands can be implemented in a couple of lines. It took me a lot longer to write a description of the commands than it did for me to implement and test all of them.</p>
			<p>I use the following format to describe turtle commands:</p>
			<p class="example">long_name | short_name &lt;arg&gt;<br />   description ...<br />   Example: ...</p>
			<p>All turtle commands take either one argument or none, and not all turtle commands have both a long name and a short name.</p>
			<p class="example">Required Commands<br />-----------------</p>
			<p>These commands are required in the sense that they are needed to reproduce the sample designs. Actually, you could get away without implementing 'back' and 'left', but implementing them is far easier than trying to write turtle code without them.</p>
			<p class="example">pen_up | pu<br />   Raises the turtle's pen. The turtle doesn't draw (lay down a visible<br />   track) when its pen is up.<br /><br />pen_down | pd<br />   Lowers the turtle's pen. The turtle draws (lays down a visible track)<br />   when its pen is down.<br /> <br />forward | fd &lt;distance&gt;<br />   Moves the turtle forwards in the direction it is facing.<br />   Example: forward(100) advances the turtle by 100 steps.<br /><br />back | bk &lt;distance&gt;<br />   Moves the turtle backwards along its line of motion.<br />   back &lt;distance&gt; == forward -&lt;distance&gt;<br />   Example: back(100) backs up the turtle by 100 steps.<br /><br />right | rt &lt;angle&gt;<br />   Turns the turtle clockwise by &lt;angle&gt; degrees.<br />   Example: right(90) turns the turtle clockwise by a right angle.<br /><br />left | lt &lt;angle&gt;<br />   Turns the turtle counterclockwise by &lt;angle&gt; degrees.<br />   left  &lt;angle&gt; == right -&lt;angle&gt;<br />   Example: left(45) turns the turtle counterclockwise by 45 degrees.</p>
			<p class="example">Traditional Commands<br />--------------------</p>
			<p>These commands are not needed to reproduce any of the sample designs, but they are found in all implementations of turtle graphics that I know of.</p>
			<p class="example">home<br />   Places the turtle at the origin, facing north, with its pen up. The<br />   turtle does not draw when it goes home.<br /><br />clear<br />   Homes the turtle and empties out it's track. Sending a turtle a clear<br />   message essentially reinitializes it.<br /><br />xy<br />   Reports the turtle's location.<br />   Example: Suppose the turtle is 10 turtle steps north and 15 turtle steps<br />   west of the origin, then xy will return [-15.0, 10.0].<br /><br />set_xy | xy= &lt;point&gt;<br />   Places the turtle at &lt;point&gt;. The turtle does not draw when this command<br />   is executed, not even if its pen is down. Returns &lt;point&gt;.<br />   Example: Suppose the turtle is at [10.0, 20.0], then self.xy = [50, 80]<br />   moves the turtle to [50.0, 80.0], but no line will drawn between the [10,<br />   20] and [50, 80].<br /><br />heading<br />   Reports the direction in which the turtle is facing. Heading is measured<br />   in degrees, clockwise from north.<br />   Example: Suppose the turtle is at the origin facing the point [100, 200],<br />   then heading will return 26.565 (approximately).<br /><br />heading= | set_h &lt;angle&gt;<br />   Sets the turtle's heading to &lt;angle&gt;. &lt;angle&gt; should be given in degrees,<br />   measured clockwise from north. Returns &lt;angle&gt;.<br />   Example: After self.heading = 135 (or set_h(135) which is easier to<br />   write), the turtle will be facing southeast. <br /><br />pen_up? | pu?<br />   Reports true if the turtle's pen is up and false otherwise.<br /><br />pen_down? | pd?<br />   Reports true if the turtle's pen is down and false otherwise.</p>
			<p class="example">Optional Commands<br />-----------------</p>
			<p>These commands are only found in some implementations of turtle graphics. When they are implemented, they make the turtle capable of doing global (coordinate) geometry in addition to local (coordinate-free) geometry.</p>
			<p>I used one of these commands, go, to draw the mandala design (see designs/mandala.tiff and samples/mandala.rb). If you choose not to implement the optional commands, you might try writing a turtle program for drawing the mandala design without using go. But, believe me, it is much easier to implement go than to write such a program.</p>
			<p class="example">go &lt;point&gt;<br />   Moves the turtle to &lt;point&gt;.<br />   Example: Suppose the turtle is home (at the origin facing north). After<br />   go([100, 200]), the turtle will be located at [100.0, 200.0] but will<br />   still be facing north. If its pen was down, it will have drawn a line<br />   from [0, 0] to [100, 200].<br /><br />toward | face &lt;point&gt;<br />   Turns the turtle to face &lt;point&gt;.<br />   Example: Suppose the turtle is at the origin. After toward([100, 200]),<br />   its heading will be 26.565 (approximately).<br /><br />distance | dist &lt;point&gt;<br />   Reports the distance between the turtle and &lt;point&gt;.<br />   Example: Suppose the turtle is at the origin, then distance([400, 300])<br />   will return 500.0 (approximately).</p>
			<p class="example">Interfacing to the Turtle Graphics Viewer<br />=========================================</p>
			<p>Implementing turtle graphics without being able to view what the turtle draws isn't much fun, so I'm providing a simple turtle graphics viewer. To interface with the viewer, turtle instances must respond to the message track by returning an array which the viewer can use to generate a line drawing. </p>
			<p>The viewer expects the array returned by track to take the following form:</p>
			<p class="example">track   ::= [segment, segment, ...]  # drawing data<br />segment ::= [point, point, ...]      # points to be joined by line segments<br />point   ::= [x, y]                   # pair of floats<br /><br />Example: [[[0.0, 0.0], [200.0, 200.0]], [[200.0, 0.0], [0.0, 200.0]]]</p>
			<p>This represents an X located in the upper-right quadrant of the viewer; i.e., two line segments, one running from the center of the viewer up to its upper-right corner and the other running from the center of the top edge down to the center of the right edge.</p>
			<p>[Editor's Note:  I added a script to dump your turtle graphics output to PPM image files, for those that don't have TK up and running.  It works identically to Morton's turtle_viewer.rb, save that it writes output to a PPM image file in the current directory.  For example, to output the included tree image, use `ruby turtle_ppm_writer.rb samples/tree.rb`.  --JEG2]</p>
			<p class="example">Unit Tests<br />==========</p>
			<p>I'm including the unit tests which I developed to test turtle commands. For the purposes of the quiz, you can ignore tests/turtle_view_test.rb. But I hope you will find the other test suite, tests/turtle_test.rb, helpful. It tests every one of the turtle commands described above as well as argument checking by the commands. Don't hesitate to modify any of the unit tests to meet the needs of your quiz solution.</p>
			<p class="example">References<br />==========</p>
			<p class="example">[1] Abelson, H. &amp; A. diSessa, "Turtle Geometry", MIT Press, 1981.<br />[2] Harvey, B., "Computer Science Logo Style", Chapter 10.<br />    http://www.cs.berkeley.edu/~bh/pdf/v1ch10.pdf<br />[3] Wikipedia, http://en.wikipedia.org/wiki/LOGO_programming_language</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I'm going to move my standard thank you note right to the beginning of this summary, because it's very important this time.  Morton put in a lot of work prepping this problem so it would be Ruby Quiz size and fun at the same time.  He even nursed me through my additions.  Thank you Morton!  More thanks to those who fiddled with the problem, showing Morton how much we appreciate his efforts.</p>
			<p>Alright, let's get to the solutions.</p>
			<p>Solving this problem isn't too tricky.  The main issue is to have the Turtle track its state which consists of where it currently is, which way it is facing, and if the pen is currently up or down.  Then you need to make the methods that alter this state functional.  A surprising number of the methods have trivial implementations, but you do need a little trigonometry for some.</p>
			<p>Let's walk through Pete Yandell's turtle.rb file to see how a solution comes together.  Here's the start of the code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Turtle<br />       include Math <span class="comment"># turtles understand math methods</span><br />       DEG = Math::PI / 180.0<br /><br />       attr_accessor :track<br />       <span class="keyword">alias</span> run instance_eval<br /><br />       <span class="keyword">def</span> initialize<br />         clear<br />       <span class="keyword">end</span><br /><br />       attr_reader :xy, :heading<br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>The only line in there not provided by the quiz is the call to clear() in initialize().  We'll look at what that does in just a moment, but first let's talk a little about what the quiz gave us for free.</p>
			<p>We've already decided a little trig is needed so the functions of the Math Module are included for us.  Now those Math methods expect arguments in radians, but our Turtle is going to work with degrees.  The conversion formula is radians = degrees * (PI / 180) and that's exactly what the DEG constant sets up for us.</p>
			<p>Skipping down, we see that instance_eval() is given a new name, so we can invoke Turtle code more naturally.  This tells us how our object will be used.  Because user code is evaluated in the context of this object, it will have access to all the methods we are about to build and even the methods borrowed from Math.</p>
			<p>The rest of the code provides accessors to the elements of Turtle state we identified earlier.  Since they are there, we might as well take the hint and tuck our instance data away in them.  We still need to figure out how to track the pen's up/down state though.  Finally, The track() method provides access to the Turtle path we are to construct.  The viewer will call this to decide what to render.</p>
			<p>I'll jump ahead in the code now, to show you that clear() method and another method it makes use of:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="comment"># Homes the turtle and empties out it's track.</span><br />       <span class="keyword">def</span> clear<br />         <span class="variable">@track</span> = []<br />         home<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Places the turtle at the origin, facing north, with its pen up.</span><br />       <span class="comment"># The turtle does not draw when it goes home.</span><br />       <span class="keyword">def</span> home<br />         <span class="variable">@heading</span> = 0.0<br />         <span class="variable">@xy</span> = [0.0, 0.0]<br />         <span class="variable">@pen_is_down</span> = <span class="keyword">false</span><br />       <span class="keyword">end</span><br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>As you can see, clear() resets the Turtle to the beginning state (by calling home()) and clears any drawing that has been done.  The constructor called this method to ensure all the state variables would be set before we run() any code.</p>
			<p>We can now see that pen state will be tracked via a boolean instance variable as well.  Here are the methods that expose that to the user:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="comment"># Raise the turtle's pen. If the pen is up, the turtle will not draw;</span><br />       <span class="comment"># i.e., it will cease to lay a track until a pen_down command is given.</span><br />       <span class="keyword">def</span> pen_up<br />         <span class="variable">@pen_is_down</span> = <span class="keyword">false</span><br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Lower the turtle's pen. If the pen is down, the turtle will draw;</span><br />       <span class="comment"># i.e., it will lay a track until a pen_up command is given.</span><br />       <span class="keyword">def</span> pen_down<br />         <span class="variable">@pen_is_down</span> = <span class="keyword">true</span><br />         <span class="variable">@track</span> &lt;&lt; [<span class="variable">@xy</span>]<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Is the pen up?</span><br />       <span class="keyword">def</span> pen_up?<br />         !<span class="variable">@pen_is_down</span><br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Is the pen down?</span><br />       <span class="keyword">def</span> pen_down?<br />         <span class="variable">@pen_is_down</span><br />       <span class="keyword">end</span><br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>Most of those should be obvious implementations.  The surprise, if any, comes from the fact that pen_down() puts a point on the track.  This makes sense though, if you think about it.  If you touch a pen to a piece of paper you have made a mark, even though you have not yet drawn a line.  The Turtle should function the same way.</p>
			<p>Here are the other setters for our Turtle's state:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="comment"># Place the turtle at [x, y]. The turtle does not draw when it changes</span><br />       <span class="comment"># position.</span><br />       <span class="keyword">def</span> xy=(coords)<br />         raise ArgumentError <span class="keyword">unless</span> is_point?(coords)<br />         <span class="variable">@xy</span> = coords<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Set the turtle's heading to &lt;degrees&gt;.</span><br />       <span class="keyword">def</span> heading=(degrees)<br />         raise ArgumentError <span class="keyword">unless</span> degrees.is_a?(Numeric)<br />         <span class="variable">@heading</span> = degrees % 360<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>These should be pretty straight-forward as well.  I haven't shown it yet, but is_point?() just validates that we received sensible parameters.  Beyond the checks, these methods just make assignments, save that heading=() restricts the parameter to a value between 0 and 359.</p>
			<p>We've got the state, so it's time to get the Turtle moving.  Let's start with turns:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="comment"># Turn right through the angle &lt;degrees&gt;.</span><br />       <span class="keyword">def</span> right(degrees)<br />         raise ArgumentError <span class="keyword">unless</span> degrees.is_a?(Numeric)<br />         <span class="variable">@heading</span> += degrees<br />         <span class="variable">@heading</span> %= 360<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Turn left through the angle &lt;degrees&gt;.</span><br />       <span class="keyword">def</span> left(degrees)<br />         right(-degrees)<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>The right() method is the workhorse here.  It validates, adds the requested number of degrees, and trims the heading if we have passed 360.  Pete then wisely reuses the code by defining left() in terms of a negative right() turn.  Two for the price of one.</p>
			<p>We can turn, so it's time to mix in a little motion:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="comment"># Move forward by &lt;steps&gt; turtle steps.</span><br />       <span class="keyword">def</span> forward(steps)<br />         raise ArgumentError <span class="keyword">unless</span> steps.is_a?(Numeric)<br />         <span class="variable">@xy</span> = [ <span class="variable">@xy</span>.first + sin(<span class="variable">@heading</span> * DEG) * steps,<br />                 <span class="variable">@xy</span>.last + cos(<span class="variable">@heading</span> * DEG) * steps ]<br />         <span class="variable">@track</span>.last &lt;&lt; <span class="variable">@xy</span> <span class="keyword">if</span> <span class="variable">@pen_is_down</span><br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Move backward by &lt;steps&gt; turtle steps.</span><br />       <span class="keyword">def</span> back(steps)<br />         forward(-steps)<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>Remember your trig?  We have the angle (@heading) and the length of the hypotenuse of a right triangle (steps).  What we need are the lengths of the other two sides which would be the distance we moved along the X and Y axes.  Note the use of DEG here to convert degrees to into the expected radians.</p>
			<p>Once you accept how forward() calculates the new location, drawing the line is almost a let down.  The point where we were will already be on the track, either from a previous line draw or from a pen_down() call.  Just adding the new point to that segment that contains the last point ensures that a line will be drawn to connect them.</p>
			<p>Again, we see that back() is just a negative forward().</p>
			<p>Here are the rest of the Turtle movement commands:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="comment"># Move to the given point.</span><br />       <span class="keyword">def</span> go(pt)<br />         raise ArgumentError <span class="keyword">unless</span> is_point?(pt)<br />         <span class="variable">@xy</span> = pt<br />         <span class="variable">@track</span>.last &lt;&lt; <span class="variable">@xy</span> <span class="keyword">if</span> <span class="variable">@pen_is_down</span><br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Turn to face the given point.</span><br />       <span class="keyword">def</span> toward(pt)<br />         raise ArgumentError <span class="keyword">unless</span> is_point?(pt)<br />         <span class="variable">@heading</span> = atan2(pt.first - <span class="variable">@xy</span>.first, pt.last  - <span class="variable">@xy</span>.last) /<br />                    DEG % 360<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># Return the distance between the turtle and the given point.</span><br />       <span class="keyword">def</span> distance(pt)<br />         raise ArgumentError <span class="keyword">unless</span> is_point?(pt)<br />         <span class="keyword">return</span> sqrt( (pt.first - <span class="variable">@xy</span>.first) ** 2 +<br />                      (pt.last  - <span class="variable">@xy</span>.last) ** 2 )<br />       <span class="keyword">end</span><br /><br />       <span class="comment"># ...</span><br /><br /></div></div>
			<p>go() is just forward() without needing to calculate the new point.  (In fact, forward() could have called go() with the new point for even more aggregation goodness.)  toward() uses an arc tangent calculation to change headings and distance() uses the Pythagorean theorem to tell you how many steps the given point is from where you are.</p>
			<p>Here's the final bit of code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">       <span class="comment"># ...</span><br /><br />       <span class="comment"># Traditional abbreviations for turtle commands.</span><br />       <span class="keyword">alias</span> fd forward<br />       <span class="keyword">alias</span> bk back<br />       <span class="keyword">alias</span> rt right<br />       <span class="keyword">alias</span> lt left<br />       <span class="keyword">alias</span> pu pen_up<br />       <span class="keyword">alias</span> pd pen_down<br />       <span class="keyword">alias</span> pu? pen_up?<br />       <span class="keyword">alias</span> pd? pen_down?<br />       <span class="keyword">alias</span> set_h heading=<br />       <span class="keyword">alias</span> set_xy xy=<br />       <span class="keyword">alias</span> face toward<br />       <span class="keyword">alias</span> dist distance<br /><br />    private<br /><br />      <span class="keyword">def</span> is_point?(pt)<br />        pt.is_a?(Array) <span class="keyword">and</span> pt.length == 2 <span class="keyword">and</span><br />        pt.first.is_a?(Numeric) <span class="keyword">and</span> pt.last.is_a?(Numeric)<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Those aliases were provided with the quiz and is_point?() is the helper method used to check the passed arguments to xy=(), go(), toward(), and distance().</p>
			<p>If you slot that file into the provided quiz project and start running samples, you should see pretty pictures and I'm a real sucker for pretty pictures.  Thanks again Morton.  Great quiz idea!</p>
			<p>Tomorrow we will tackle a fun algorithmic problem for us tournament players...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/227969">Dema</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228021">Edwin Fine</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228039">Matthew Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228089">Morton Goldberg</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228114">Pete Yandell</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228318">Dema (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228332">Dema (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228506">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228607">David Tran (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/228735">C&eacute;dric Finance</a></li>
			</ol>
			<p><a href="quiz104_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
