<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Tab Player (#79)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Tab Player (#79)</span>
			<p>by Ross Bamford</p>
			<p>One for the music lovers this week - can your computer play guitar? Basically, the aim of this week's quiz is to implement a Ruby program that will 'read' guitar tablature, and generate a rendition of that tablature in some sound format. </p>
			<p>In case you're unfamiliar with tablature, it's a form of written guitar music that's easier to learn and often more convenient than real sheet music. It doesn't carry nearly as much information about a piece, but it provides a good starting point and is an easy way to record key bits you don't want to forget. Also, it's quite amenable to ASCII formatting. It looks like this:</p>
			<p class="example">e|-----------------------------0-1-3-|<br />B|-----------------------0-1-3-------|<br />G|-------------------0-2-------------|<br />D|-------------0-2-3-----------------|<br />A|-------0-2-3-----------------------|<br />E|-0-1-3-----------------------------|<br /><br />e|1-0--------------------------------|<br />B|----3-1-0--------------------------|<br />G|----------2-0----------------------|<br />D|--------------3-2-0----------------|<br />A|--------------------3-2-0----------|<br />E|--------------------------3-1-0----|</p>
			<p>The six horizontal lines represent the six strings of the guitar (the thickest string, the sixth, being the bottom line) with time progressing left to right, top to bottom. The numbers on the strings show the fret at which that string should be held when the string is played.</p>
			<p>You can find a bit more about <a href="http://en.wikipedia.org/wiki/Tablature">tableture at Wikipedia</a>, and a <a href="http://guitar.about.com/library/blhowtoreadtab.htm">tutorial at  guitar.about.com</a>. You'll also find lots of (non-commercial use only) tabs at <a href="http://www.olga.net/dynamic/browse.php?setPrintable=0&amp;local=main">OLGA</a>.</p>
			<p class="example">What you need to do<br />===================</p>
			<p>Firstly, you'll need to select some tabs to work with. You might try OLGA, or google around a bit. Unfortunately, the quality of freely available tabs is very variable, so you might prefer to bug your musician friends for something you can use. Also, a few simple scales and other bits are <a href="http://rubyquiz.com/tab_player.zip">included with the quiz</a>.</p>
			<p>Once that's done, you'll need to choose a guitar. This quiz <a href="http://rubyquiz.com/tab_player.zip">includes a free guitar</a> that supports the bare minimum you need to play simple tabs, with output to MIDI format (thanks to <a href="http://midilib.rubyforge.org/">midilib</a>). To use this guitar, you'll need midilib installed (it's available as a Gem). See guitar.rb for more info.</p>
			<p>The aim is that your program will play the guitar, and then dump the midi. You may accept any commandline parameters you wish, and should output the midi data to stdout.</p>
			<p>If you don't have anything to listen with, check out <a href="http://timidity.sourceforge.net/">TiMidity++</a> [6].</p>
			<p class="example">Oh man, this guitar blows!<br />==========================</p>
			<p>If you're a guitarist, or you surfed a few tabs, you'll notice immediately that the provided guitar is actually pretty useless. Firstly, it only has nine frets (an odd number, I admit). And sure, you can hit the notes, but that's all - there's a world of stuff it can't support: bends, hammer-on/pull-off, letting notes to ring, harmonics, the list goes on.</p>
			<p>A lot of this could be supported by MIDI, if only you had a better guitar. Some people build their own guitars, and for extra credit in this quiz, that's exactly what you should do: extend or rewrite the Guitar class to support a full-size neck, and as many tabbable effects as you can.</p>
			<p class="example">Things to bear in mind<br />======================<br /><br />* As mentioned, tab quality on the 'net is variable - don't expect your<br />  favourite song to sound exactly right. Often, tabs provide more of a <br />  starting point than an accurate transcript.<br />  <br />* Timing is one of the most important qualities in a piece of music, but<br />  tablature sadly lacks any notion of it. For that reason you shouldn't<br />  worry too much about it, though it's nice if you can provide a way<br />  to specify tempo and timing for a given tab on the command line.<br />  <br />* ASCII tabs are often hand-written, and vary slightly in their formatting<br />  and the different characters used. Try to be liberal in what you accept.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>by Ross Bamford</p>
			<p>Putting aside the musical theme for a moment, this quiz boiled down to a text processing problem, complicated slightly by the fact that tab formats are actually quite variable, and often input will contain text mixed with valid tab. This required the solutions to be liberal in what they would accept, and conservative in their output - something that all the solutions achieved in different ways. Let's look first at the Tab class from Anthony Moralez's solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Tab<br />      <span class="keyword">def</span> initialize(tab_file)<br />        <span class="variable">@chords</span> = []<br />        <span class="variable">@file</span> = tab_file<br />        <span class="variable">@tab</span> = extract_tabs(tab_file)<br />      <span class="keyword">end</span><br /><br />      <span class="comment">#select only lines containing tab notation and remove extraneous chars</span><br />      <span class="keyword">def</span> extract_tabs(file)<br />        File.readlines(file).select { |line|<br />          line =~ <span class="string">/[eBGDAE|-][|-]/</span><br />        }.collect { |line|<br />          line.gsub(<span class="string">/[eBGDAE|\s]/</span>, <span class="string">''</span>)<br />        }<br />      <span class="keyword">end</span><br /><br /></div></div>
			<p>We can already see how Anthony is handling plain-text in the tab files - lines are selected from the input using a regular expression, looking for the string note at the start of a tab line, followed by tab characters. Failing that, two consecutive -- are accepted. This is a trade-off on Anthony's part: many tabs omit the string notes on some or all of the tablature, and Anthony's solution will still pick that up. However, it may also pick up some extraneous lines, such as message headers and the like. </p>
			<p>The selected lines are then massaged using gsub, to remove any extraneous characters (those string notes, spaces, and bars).</p>
			<p>Adam Shelly took a different approach. His code is based around a main loop, which loops through the input file looking for runs of six consecutive lines of equal length. Here's the first part of that loop:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">until</span> ARGF.eof <span class="keyword">do</span><br />      lines &lt;&lt; ARGF.gets.chomp.split(<span class="string">''</span>);<br />      <span class="comment">#read until we find 6 lines of same length</span><br />      <span class="keyword">if</span> lastlength <span class="keyword">and</span> lastlength != lines[-1].length<br />        <span class="comment">#throw away nonmatching lines</span><br />        lines.shift <span class="keyword">while</span> lines.size &gt; 1<br />      <span class="keyword">end</span><br />      lastlength = lines[-1].length<br /><br /></div></div>
			<p>This is a clever way to approach the problem, and I think it will reliably find most tabs in a given file. There are still potential false positive matches (an ASCII table over six lines, for example) but those are probably relatively few and far between. Here's the rest of the loop, which converts the notes to the guitar's expected format, and does the actual playing:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="keyword">if</span> lines.size == 6<br />        sig = lines.inject([]){|a,l| a &lt;&lt;l.shift}<br />        <span class="comment">#make sure it has a key signature</span><br />        <span class="keyword">if</span> !sig.find{|e| !e <span class="keyword">or</span> !((<span class="string">"A"</span>..<span class="string">"G"</span>).include?(e.upcase))}<br />          <span class="comment">#create a guitar in the key of the first tab found.</span><br />          g ||= Guitar.new(Guitar::NYLON_ACOUSTIC,<br />                            tuningMap[sig.reverse.join.upcase])<br />          <span class="keyword">until</span> (lines[0].empty?)<br />            note = lines.inject([]){|a,l| a &lt;&lt; l.shift}<br />            <span class="keyword">if</span> (note[0]!=<span class="string">'|'</span>)<br />              p note.join <span class="keyword">if</span> <span class="global">$DEBUG</span><br />              g.play(note.join)<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        lines.clear<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This runs every time the buffer gets to six equal-length lines, and handles both conversion and playing. Firstly, Adam shifts the first character from each tab line and stores them in an array - this will be the string note at the start of the line. These are then checked to make sure they all fall within the valid range of notes (A to G), and if so they are used to select a tuning for the guitar. Adam then steps through the tab lines, using inject to shift the first character from each line, and putting them together to make the notes passed into the guitar.</p>
			<p>(Incidentally, Adam's solution seems to be designed for a left-handed guitar, since it passes the notes to the guitar in reverse order).</p>
			<p>These solutions, and most of the others, used the guitar provided with the quiz, and as such are subject to the limitations mentioned in the quiz. As it turned out, extending the guitar entailed more work than first appeared, but Douglas Seifert had a go, removing that nine-fret limitation and providing the ability to vary the note type that was played. To achieve this, Douglas changed this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    d = <span class="variable">@seq</span>.note_to_delta(<span class="variable">@note</span>)<br />    notes.split(<span class="string">//</span>).each_with_index <span class="keyword">do</span> |fret, channel|<br />      ...<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>to (some whitespace and comments edited):</p>
			<div class="code"><span class="type">ruby</span><div class="body">    md = <span class="string">/(\w):(.+)/</span>.match(notes)<br />    notetype = <span class="variable">@notes</span>[md[1]]<br />    d = <span class="variable">@seq</span>.note_to_delta(notetype)<br />    md[2].split(<span class="string">'|'</span>).each_with_index <span class="keyword">do</span> |fret, channel|<br />      ...<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This changes the guitar's expected input format, but that's probably unavoidable if we want to support more than single digit frets. Douglas kindly explains the new format in his comments:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Play some notes on the guitar. Pass notes in this notation:</span><br />    <span class="comment"># </span><br />    <span class="comment">#   "n:6|5|4|3|2|1"</span><br />    <span class="comment">#   first char is the note type (sixteenth, eighth, quarter, etc) followed</span><br />    <span class="comment">#     by a colon and then the frets for each string (pipe '|' separates</span><br />    <span class="comment">#     fret number for each string)</span><br /><br /></div></div>
			<p>I don't want to get too technical here, but for those with no musical background the different note types represent the duration of the note, as a fraction of a beat. In real music different note values are often mixed, so this addition potentially allows us to play a wider range of music, given the extra information in the original tab.</p>
			<p>Douglas' tab parsing code is very well commented and easy to follow, so I recommend taking a look for the full lowdown, but let's focus here on the section of code that handles those awkward two-digit fret numbers:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">while</span> i &lt; num_eighths - 1<br />      chord = <span class="string">''</span><br />      max_number_length = 1<br />      <span class="comment"># Figure out the chord ... it will be of the form 1|2|3|5|4|3|</span><br />      <span class="comment"># two passes to handle alignment issues with two digit and one</span><br />      <span class="comment"># digit notes... some tabs line them up on the first digit, yet</span><br />      <span class="comment"># others line them up on the last digit.  This algorithm only</span><br />      <span class="comment"># handles up to two consecutive digits for a note.</span><br />      ss.size().downto(1) { |s|<br />        this_max_number_len = 1<br /><br />        <span class="comment"># First case here is trying to deal with two digit numbers</span><br />        <span class="keyword">if</span> ss[s-1][i].chr != <span class="string">"x"</span> &amp;&amp; ss[s-1][i+1].chr != <span class="string">"x"</span><br />          this_max_number_len += 1<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Save the size of the maximum string of numbers for later</span><br />        <span class="keyword">if</span> this_max_number_len &gt; max_number_length<br />          max_number_length = this_max_number_len<br />        <span class="keyword">end</span><br />      }<br /><br />      <span class="comment"># Second pass, we know the max consecutive digits, either 1 or 2</span><br />      ss.size().downto(1) { |s|<br />        <span class="comment"># First case handles single digit lined up on the right</span><br />        <span class="keyword">if</span> max_number_length &gt; 1 &amp;&amp; ss[s-1][i].chr == <span class="string">"x"</span> &amp;&amp;<br />                                    ss[s-1][i+1].chr != <span class="string">"x"</span><br />          chord &lt;&lt; ss[s-1][i+1]<br />        <span class="comment"># Second case handles two digit notes</span><br />        <span class="keyword">elsif</span> ss[s-1][i].chr != <span class="string">"x"</span> &amp;&amp; ss[s-1][i+1].chr != <span class="string">"x"</span><br />          chord &lt;&lt; ss[s-1][i]<br />          chord &lt;&lt; ss[s-1][i+1]<br />        <span class="comment"># single digit notes lined up on left</span><br />        <span class="keyword">else</span><br />          chord &lt;&lt; ss[s-1][i]<br />        <span class="keyword">end</span><br />        chord &lt;&lt; <span class="string">"|"</span><br />      }<br /><br />      <span class="comment"># Keep track of number of consecutive empty chords for poor man's timing</span><br />      <span class="keyword">if</span> chord == empty_chord<br />        <span class="keyword">if</span> delay_index + 1 &lt; <span class="variable">@@notes</span>.length()<br />          delay_index += 1<br />        <span class="keyword">end</span><br />      <span class="keyword">else</span><br />        <span class="keyword">if</span> delay_index == -1<br />          delay_index = 0<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># get rid of the last pipe</span><br />        chord.chomp!(<span class="string">"|"</span>)<br /><br />        <span class="comment"># Modified guitar wants the note in new format.  First char indicates the</span><br />        <span class="comment"># delay that passed before current note.  After colon, we have pipe </span><br />        <span class="comment"># delimited note values for each string</span><br />        axe.play(<span class="string">"#{@@notes[delay_index]}:#{chord}"</span>)<br /><br />        <span class="comment"># reset the consecutive empty chords counter</span><br />        delay_index = -1<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># skip past multiple digit notes</span><br />      i += max_number_length<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The comments tell the story very well here, so I'll just wrap up by drawing your attention to the way Douglas handles the varying tab style used by different authors, with special cases to handle double-digits aligned both left and right with the rest of the notes, and also the way empty chords are tracked and used to select a duration for the following note. This adds an interesting variability to the speed and style with which tabs are played. Coupled with the support for double-digit fret numbers, this gave a very nice sound, especially with the included tab for Metallica's 'Nothing else matters'.  </p>
			<p>This summary could go on forever, with all the submitted solutions providing some interesting points, but I'm aware that this is already running rather long. I would definitely urge you take a look at the solutions in full, and especially to run them and listen to their output - every one of them has it's own sound, and one of the great things about music is that it's never really 'right' or 'wrong'. Thanks everyone who took the time to play with this!</p>
			<p>Before I go, just a quick reminder that there will be no quiz tomorrow, as James is still on Holiday (and hopefully having a fine time), so maybe it'd be a good week to write up those Ruby Quiz suggestions you've been meaning to get around to. Don't forget there's another copy of Best Of Ruby Quiz up for grabs and trust me, it's definitely worth having (mine arrived yesterday :)).</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/192796">Anthony Moralez</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/193054">Shane Emmons</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/193179">Douglas A. Seifert</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/193247">Ross Bamford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/193270">Adam Shelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/193338">Giles Bowkett</a></li>
			</ol>
			<p><a href="quiz79_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
