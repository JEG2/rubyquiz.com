<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Texas Hold'Em (#24)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Texas Hold'Em (#24)</span>
			<p>by Matthew D Moss</p>
			<p>You work for a cable network; specifically, you are the resident hacker for a Texas Hold'Em Championship show.</p>
			<p>The show's producer has come to you for a favor. It seems the play-by-play announcers just can't think very fast. All beauty, no brains. The announcers could certainly flap their jaws well enough, if they just knew what hands the players were holding and which hand won the round. Since this is live TV, they need those answers quick. Time to step up to the plate. Bob, the producer, explains what you need to do.</p>
			<p><b>BOB:</b> Each player's cards for the round will be on a separate line of the input. Each card is a pair of characters, the first character represents the face, the second is the suit. Cards are separated by exactly one space. Here's a sample hand.</p>
			<p class="example">Kc 9s Ks Kd 9d 3c 6d<br />9c Ah Ks Kd 9d 3c 6d<br />Ac Qc Ks Kd 9d 3c<br />9h 5s<br />4d 2d Ks Kd 9d 3c 6d<br />7s Ts Ks Kd 9d</p>
			<p><b>YOU:</b> Okay, I was going ask what character to use for 10, but I guess 'T' is it. And 'c', 'd', 'h' and 's' for the suits, makes sense. Why aren't seven cards listed for every player?</p>
			<p><b>BOB:</b> Well, if a player folds, only his hole cards and the community cards he's seen so far are shown.</p>
			<p><b>YOU:</b> Right. And why did the fifth player play with a 4 and 2? They're suited, but geez, talk about risk...</p>
			<p><b>BOB:</b> Stay on topic. Now, the end result of your code should generate output that looks like this:</p>
			<p class="example">Kc 9s Ks Kd 9d 3c 6d Full House (winner)<br />9c Ah Ks Kd 9d 3c 6d Two Pair<br />Ac Qc Ks Kd 9d 3c <br />9h 5s <br />4d 2d Ks Kd 9d 3c 6d Flush<br />7s Ts Ks Kd 9d </p>
			<p><b>YOU:</b> Okay, so I repeat the cards, list the rank or nothing if the player folded, and the word "winner" in parenthesis next to the winning hand. Do you want the cards rearranged at all?</p>
			<p><b>BOB:</b> Hmmm... we can get by without it, but if you have the time, do it. Don't bother for folded hands, but for ranked hands, move the cards used to the front of the line, sorted by face. Kickers follow that, and the two unused cards go at the end, just before the rank is listed.</p>
			<p><b>YOU:</b> Sounds good. One other thing, I need to brush up on the hand ranks. You have any good references for Texas Hold'Em?</p>
			<p><b>BOB:</b> Yeah, check out these <a href="http://www.thepokerforum.com/pokerhands.htm">Poker Hand Rankings</a>. And if you need it, here are the <a href="http://www.thepokerforum.com/texasholdem.htm">Rules of Texas Hold'Em</a>. While ranking, don't forget the kicker, the next highest card in their hand if player's are tied. And of course, if -- even after the kicker -- player's are still tied, put "(winner)" on each appropriate line of output.</p>
			<p><b>YOU:</b> Ok. I still don't understand one thing...</p>
			<p><b>BOB:</b> What's that?</p>
			<p><b>YOU:</b> Why he stayed in with only the 4 and 2 of diamonds? That's just...</p>
			<p><b>BOB:</b> Hey! Show's on in ten minutes! Get to work!</p>
			<p>[ Editor's Note:</p>
			<p>Matthew included a script for generating test games with his quiz.  Here's that code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby</span><br /><br />    FACES = <span class="string">"AKQJT98765432"</span><br />    SUITS = <span class="string">"cdhs"</span><br /><br />    srand<br /><br />    <span class="comment"># build a deck</span><br />    deck = []<br />    FACES.each_byte <span class="keyword">do</span> |f|<br />        SUITS.each_byte <span class="keyword">do</span> |s|<br />            deck.push(f.chr + s.chr)<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># shuffle deck</span><br />    3.times <span class="keyword">do</span><br />        shuf = []<br />        deck.each <span class="keyword">do</span> |c|<br />            loc = rand(shuf.size + 1)<br />            shuf.insert(loc, c)<br />        <span class="keyword">end</span><br />        deck = shuf.reverse<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># deal common cards</span><br />    common = Array.new(5) { deck.pop }<br /><br />    <span class="comment"># deal player's hole cards</span><br />    hole = Array.new(8) { Array.new(2) { deck.pop } }<br /><br />    <span class="comment"># output hands</span><br />    hands = []<br />    all_fold = <span class="keyword">true</span><br />    <span class="keyword">while</span> all_fold <span class="keyword">do</span><br />        hands = []<br />        hole.each <span class="keyword">do</span> |h|<br />            num_common = [0, 3, 4, 5][rand(4)]<br />            <span class="keyword">if</span> num_common == 5<br />                all_fold = <span class="keyword">false</span><br />            <span class="keyword">end</span><br />            <span class="keyword">if</span> num_common &gt; 0<br />                hand = h + common[0 ... num_common]<br />            <span class="keyword">else</span><br />                hand = h<br />            <span class="keyword">end</span><br />            hands.push(hand.join(<span class="string">' '</span>))<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    hands.each { |h| puts h }<br /><br /></div></div>
			<p>-JEG2 ]</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>People wrote quite a bit of code to solve this quiz.  I don't think it's all that tough, but there are quite a few combinations to check for, which seemed to increase the line count of the solutions.</p>
			<p>There was something interesting in all the solutions though, so I do recommend browsing through them if you haven't already.  I know I'm always saying that.  I guess it's always true.</p>
			<p>I'm going to show Patrick Hurley's solution below.  Patrick resubmitted just to defend against my rant about how programs should stay within an 80 character line limit.  My argument wasn't meant as an attack on any submissions, but I still appreciate Patrick's efforts.  Here's the start of the code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!ruby -w</span><br /><br />    <span class="keyword">class</span> Card<br />      SUITS = <span class="string">"cdhs"</span><br />      FACES = <span class="string">"L23456789TJQKA"</span><br />      SUIT_LOOKUP = {<br />        <span class="string">'c'</span> =&gt; 0,<br />        <span class="string">'d'</span> =&gt; 1,<br />        <span class="string">'h'</span> =&gt; 2,<br />        <span class="string">'s'</span> =&gt; 3,<br />        <span class="string">'C'</span> =&gt; 0,<br />        <span class="string">'D'</span> =&gt; 1,<br />        <span class="string">'H'</span> =&gt; 2,<br />        <span class="string">'S'</span> =&gt; 3,<br />      }<br />      FACE_VALUES = {<br />        <span class="string">'L'</span> =&gt;  1,   <span class="comment"># this is a magic low ace</span><br />        <span class="string">'2'</span> =&gt;  2,<br />        <span class="string">'3'</span> =&gt;  3,<br />        <span class="string">'4'</span> =&gt;  4,<br />        <span class="string">'5'</span> =&gt;  5,<br />        <span class="string">'6'</span> =&gt;  6,<br />        <span class="string">'7'</span> =&gt;  7,<br />        <span class="string">'8'</span> =&gt;  8,<br />        <span class="string">'9'</span> =&gt;  9,<br />        <span class="string">'T'</span> =&gt; 10,<br />        <span class="string">'J'</span> =&gt; 11,<br />        <span class="string">'Q'</span> =&gt; 12,<br />        <span class="string">'K'</span> =&gt; 13,<br />        <span class="string">'A'</span> =&gt; 14,<br />      }<br /><br />      <span class="keyword">def</span> Card.face_value(face)<br />        <span class="keyword">if</span> (face)<br />          FACE_VALUES[face] - 1<br />        <span class="keyword">else</span><br />          <span class="keyword">nil</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> build_from_string(card)<br />        build_from_face_suit(card[0,1], card[1,1])<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> build_from_value(value)<br />        <span class="variable">@value</span> = value<br />        <span class="variable">@suit</span>  = value / FACES.size()<br />        <span class="variable">@face</span>  = (value % FACES.size())<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> build_from_face_suit(face, suit)<br />        <span class="variable">@face</span>  = Card::face_value(face)<br />        <span class="variable">@suit</span>  = SUIT_LOOKUP[suit]<br />        <span class="variable">@value</span> = (<span class="variable">@suit</span> * FACES.size()) + (<span class="variable">@face</span> - 1)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> build_from_face_suit_values(face, suit)<br />        build_from_value((face - 1) + (suit * FACES.size()))<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># got a little carried away with this constructor ;-)</span><br />      <span class="keyword">def</span> initialize(*value)<br />        <span class="keyword">if</span> (value.size == 1)<br />          <span class="keyword">if</span> (value[0].respond_to?(:to_str))<br />            build_from_string(value[0])<br />          <span class="keyword">elsif</span> (value[0].respond_to?(:to_int))<br />            build_from_value(value[0])<br />          <span class="keyword">end</span><br />        <span class="keyword">elsif</span> (value.size == 2)<br />          <span class="keyword">if</span> (value[0].respond_to?(:to_str) &amp;&amp;<br />              value[1].respond_to?(:to_str))<br />            build_from_face_suit(value[0], value[1])<br />          <span class="keyword">elsif</span> (value[0].respond_to?(:to_int) &amp;&amp;<br />                 value[1].respond_to?(:to_int))<br />            build_from_face_suit_values(value[0], value[1])<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      attr_reader :suit, :face, :value<br /><br />      <span class="keyword">def</span> to_s<br />        FACES[<span class="variable">@face</span>].chr + SUITS[<span class="variable">@suit</span>].chr<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>That's the Card class Patrick uses for tracking individual cards.  It looks like a lot of code, but it's mostly a single constructor that accepts many different forms of initialization.  initialize() breaks down the parameters and hands them off to the various build_from_... methods.  Those build methods should probably be private, leaning on initialize() as their interface.  Once you get past construction, you'll see that Card just contains a suit, face, and value.  Glance at build_from_face_suit() to see how those break down.</p>
			<p>You can see it above and a little more below, but this code has a little creeping featurism.  Patrick was clearly building for the future with the card handling classes.  That's probably a safe bet as card quizzes are fairly common.  Dave Burt reused code from his Blackjack solution this time around.  All I'm saying is, don't be surprised if you see a handful of things in here that never get used.  Agile purists bare with us...</p>
			<p>Let's move on to Deck objects:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Deck<br />      <span class="keyword">def</span> shuffle<br />        deck_size = <span class="variable">@cards</span>.size<br />        (deck_size * 2).times <span class="keyword">do</span><br />          pos1, pos2 = rand(deck_size), rand(deck_size)<br />          <span class="variable">@cards</span>[pos1], <span class="variable">@cards</span>[pos2] = <span class="variable">@cards</span>[pos2], <span class="variable">@cards</span>[pos1]<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> initialize<br />        <span class="variable">@cards</span> = []<br />        Card::SUITS.each_byte <span class="keyword">do</span> |suit|<br />          <span class="comment"># careful not to double include the aces...</span><br />          Card::FACES[1..-1].each_byte <span class="keyword">do</span> |face|<br />            <span class="variable">@cards</span>.push(Card.new(face.chr, suit.chr))<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        shuffle()<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> deal<br />        <span class="variable">@cards</span>.pop<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> empty?<br />        <span class="variable">@cards</span>.empty?<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>initialize() just creates and shuffles a deck.  deal() pops a card and empty?() tells you if there are any left.  If you read shuffle(), you'll see that it's just a bunch of random swaps.  Not sure why Patrick went this way.  I believe the standard Ruby shuffling idiom is:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="variable">@cards</span>.sort_by { rand }<br /><br /></div></div>
			<p>On to the Hand class, but let's take this one in slices:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Hand<br />      <span class="keyword">def</span> initialize(cards = [])<br />        <span class="keyword">if</span> (cards.respond_to?(:to_str))<br />          <span class="variable">@hand</span> = cards.scan(<span class="string">/\S\S/</span>).map { |str| Card.new(str) }<br />        <span class="keyword">else</span><br />          <span class="variable">@hand</span> = cards<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      attr_reader :hand<br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>initialize() just builds new Hand objects from the lines of input in the quiz by scan()ing for the two character format.  You can also build a Hand from an Array of Card objects.  Then there's the accessor to get them back.</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> face_values<br />        <span class="variable">@hand</span>.map { |c| c.face }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> by_suit<br />        Hand.new(<span class="variable">@hand</span>.sort_by { |c| [c.suit, c.face] }.reverse)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> by_face<br />        Hand.new(<span class="variable">@hand</span>.sort_by { |c| [c.face, c.suit] }.reverse)<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>You can use the above methods to request hands by face_values(), by_suit(), or by_face(). Note that both of the by_... sorts also sort by the other value, as a secondary condition.</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> =~ (re)<br />        re.match(<span class="variable">@hand</span>.join(<span class="string">' '</span>))<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> arrange_hand(md)<br />          hand = <span class="keyword">if</span> (md.respond_to?(:to_str))<br />            md<br />          <span class="keyword">else</span><br />            md[0] + <span class="string">' '</span> + md.pre_match + md.post_match<br />          <span class="keyword">end</span><br />          hand.gsub!(<span class="string">/\s+/</span>, <span class="string">' '</span>)<br />          hand.gsub(<span class="string">/\s+$/</span>,<span class="string">''</span>)<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The first method here is an operator overload to allow using regular expressions on Hand objects.  The second method returns a hand string in an order specified by a MatchData object (the else clause).  Whatever cards were matched are put first, follow by cards preceding the match, and finally trailing cards.  This floats a matched "hand" to the front of the string while keeping the ordering for any non-matched cards.  arrange_hand() can also be called with a string order (the if clause), but it doesn't do much in these cases except clean up spacing issues.</p>
			<p>From here, we start to get into hand matching code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># .. </span><br /><br />      <span class="keyword">def</span> royal_flush?<br />        <span class="keyword">if</span> (md = (by_suit =~ <span class="string">/A(.) K\1 Q\1 J\1 T\1/</span>))<br />          [[10], arrange_hand(md)]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method looks for the coveted royal flush.  First it calls by_suit() to order the cards.  Remember that will order suits first, then faces.  That makes it trivial to spot the pattern with a Regexp.  When found, royal_flush?() returns a hand ranking number and the properly arranged hand in an Array, which is of course a true value in Ruby.  false is used when no match is found.</p>
			<p>The code then pauses to define a couple more helper methods for spotting the other hands:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> delta_transform(use_suit = <span class="keyword">false</span>)<br />        aces = <span class="variable">@hand</span>.select { |c| c.face == Card::face_value(<span class="string">'A'</span>) }<br />        aces.map! { |c| Card.new(1,c.suit) }<br /><br />        base = <span class="keyword">if</span> (use_suit)<br />          (<span class="variable">@hand</span> + aces).sort_by { |c| [c.suit, c.face] }.reverse<br />        <span class="keyword">else</span><br />          (<span class="variable">@hand</span> + aces).sort_by { |c| [c.face, c.suit] }.reverse<br />        <span class="keyword">end</span><br /><br />        result = base.inject([<span class="string">''</span>,<span class="keyword">nil</span>]) <span class="keyword">do</span> |(delta_hand, prev_card), card|<br />          <span class="keyword">if</span> (prev_card)<br />            delta = prev_card - card.face<br />          <span class="keyword">else</span><br />            delta = 0<br />          <span class="keyword">end</span><br />          <span class="comment"># does not really matter for my needs</span><br />          delta = <span class="string">'x'</span> <span class="keyword">if</span> (delta &gt; 9 || delta &lt; 0)<br />          delta_hand += delta.to_s + card.to_s + <span class="string">' '</span><br />          [delta_hand, card.face]<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># we just want the delta transform, not the last cards face too</span><br />        result[0].chop<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Dave Burt asked on Ruby Talk what delta_transform() does.  Here's the author's own response:</p>
			<p class="example">The delta transform creates a version of the cards where the delta<br />between card values is in the string, so a regexp can then match a<br />straight and/or straight flush - I used regexp to match all my cases<br />with appropriate sort and/or transforms.</p>
			<p>Because that's probably easier to understand when you see it, here's a typical return value from delta_tranform():</p>
			<p class="example">"0Jh 38h xJd 38d 44d 13d x8c"</p>
			<p>The extra character preceding each card shows the drop from the previous card rank.  The jack is the first card, so it shows a 0 drop.  The eight is then down 3, as shown.  Tracking increases isn't needed in the solution, so the code just punts with an x character, as seen with the next jack.  All this is just building up a handy string for pattern matching.</p>
			<p>Note that the first couple of lines of delta_transform() add a "low ace" to the back of the hand for each ace found in the hand.  This is for spotting low straights, but the magic must eventually be undone by:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> fix_low_ace_display(arranged_hand)<br />        <span class="comment"># remove card deltas (this routine is only used for straights)</span><br />        arranged_hand.gsub!(<span class="string">/\S(\S\S)\s*/</span>, <span class="string">"\\1 "</span>)<br /><br />        <span class="comment"># Fix "low aces"</span><br />        arranged_hand.gsub!(<span class="string">/L(\S)/</span>, <span class="string">"A\\1"</span>)<br /><br />        <span class="comment"># Remove duplicate aces (this will not work if you have</span><br />        <span class="comment"># multiple decks or wild cards)</span><br />        arranged_hand.gsub!(<span class="string">/((A\S).*)\2/</span>, <span class="string">"\\1"</span>)<br /><br />        <span class="comment"># cleanup white space</span><br />        arranged_hand.gsub!(<span class="string">/\s+/</span>, <span class="string">' '</span>)<br />        <span class="comment"># careful to use gsub as gsub! can return nil here</span><br />        arranged_hand.gsub(<span class="string">/\s+$/</span>, <span class="string">''</span>)<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This just restores the ace back to its usual display.</p>
			<p>Now we can see both of those methods put to good use:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> straight_flush?<br />        <span class="keyword">if</span> (md = (<span class="string">/.(.)(.)(?: 1.\2){4}/</span>.match(delta_transform(<span class="keyword">true</span>))))<br />          high_card = Card::face_value(md[1])<br />          arranged_hand = fix_low_ace_display(md[0] + <span class="string">' '</span> +<br />              md.pre_match + <span class="string">' '</span> + md.post_match)<br />          [[9, high_card], arranged_hand]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is similar in function to royal_flush?(), but you can see that it uses delta_transform() to make it easy to match a straight.  fix_low_ace_display() is called on the result, before the method returns.</p>
			<p>The rest of the hand methods are very similar.  Sort the cards, match a pattern, return rank and hand or false.  Here they are, without further explanation:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> four_of_a_kind?<br />        <span class="keyword">if</span> (md = (by_face =~ <span class="string">/(.). \1. \1. \1./</span>))<br />          <span class="comment"># get kicker</span><br />          (md.pre_match + md.post_match).match(<span class="string">/(\S)/</span>)<br />          [<br />            [8, Card::face_value(md[1]), Card::face_value(<span class="global">$1</span>)],<br />            arrange_hand(md)<br />          ]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> full_house?<br />        <span class="keyword">if</span> (md = (by_face =~ <span class="string">/(.). \1. \1. (.*)(.). \3./</span>))<br />          arranged_hand = arrange_hand(md[0] + <span class="string">' '</span> +<br />              md.pre_match + <span class="string">' '</span> + md[2] + <span class="string">' '</span> + md.post_match)<br />          [<br />            [7, Card::face_value(md[1]), Card::face_value(md[3])],<br />            arranged_hand<br />          ]<br />        <span class="keyword">elsif</span> (md = (by_face =~ <span class="string">/((.). \2.) (.*)((.). \5. \5.)/</span>))<br />          arranged_hand = arrange_hand(md[4] + <span class="string">' '</span>  + md[1] + <span class="string">' '</span> +<br />              md.pre_match + <span class="string">' '</span> + md[3] + <span class="string">' '</span> + md.post_match)<br />          [<br />            [7, Card::face_value(md[5]), Card::face_value(md[2])],<br />            arranged_hand<br />          ]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> flush?<br />        <span class="keyword">if</span> (md = (by_suit =~ <span class="string">/(.)(.) (.)\2 (.)\2 (.)\2 (.)\2/</span>))<br />          [<br />            [<br />              6,<br />              Card::face_value(md[1]),<br />              *(md[3..6].map { |f| Card::face_value(f) })<br />            ],<br />            arrange_hand(md)<br />          ]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> straight?<br />        result = <span class="keyword">false</span><br />        <span class="keyword">if</span> hand.size &gt; 5<br />          transform = delta_transform<br />          <span class="comment"># note we can have more than one delta 0 that we</span><br />          <span class="comment"># need to shuffle to the back of the hand</span><br />          <span class="keyword">until</span> transform.match(<span class="string">/^\S{3}( [1-9x]\S\S)+( 0\S\S)*$/</span>) <span class="keyword">do</span><br />            transform.gsub!(<span class="string">/(\s0\S\S)(.*)/</span>, <span class="string">"\\2\\1"</span>)<br />          <span class="keyword">end</span><br />          <span class="keyword">if</span> (md = (<span class="string">/.(.). 1.. 1.. 1.. 1../</span>.match(transform)))<br />            high_card = Card::face_value(md[1])<br />            arranged_hand = fix_low_ace_display(md[0] + <span class="string">' '</span> +<br />                md.pre_match + <span class="string">' '</span> + md.post_match)<br />            result = [[5, high_card], arranged_hand]<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> three_of_a_kind?<br />        <span class="keyword">if</span> (md = (by_face =~ <span class="string">/(.). \1. \1./</span>))<br />          <span class="comment"># get kicker</span><br />          arranged_hand = arrange_hand(md)<br />          arranged_hand.match(<span class="string">/(?:\S\S ){3}(\S)\S (\S)/</span>)<br />          [<br />            [<br />              4,<br />              Card::face_value(md[1]),<br />              Card::face_value(<span class="global">$1</span>),<br />              Card::face_value(<span class="global">$2</span>)<br />            ],<br />            arranged_hand<br />          ]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> two_pair?<br />        <span class="keyword">if</span> (md = (by_face =~ <span class="string">/(.). \1.(.*) (.). \3./</span>))<br />          <span class="comment"># get kicker</span><br />          arranged_hand = arrange_hand(md[0] + <span class="string">' '</span> +<br />              md.pre_match + <span class="string">' '</span> + md[2] + <span class="string">' '</span> + md.post_match)<br />          arranged_hand.match(<span class="string">/(?:\S\S ){4}(\S)/</span>)<br />          [<br />            [<br />              3,<br />              Card::face_value(md[1]),<br />              Card::face_value(md[3]),<br />              Card::face_value(<span class="global">$1</span>)<br />            ],<br />            arranged_hand<br />          ]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> pair?<br />        <span class="keyword">if</span> (md = (by_face =~ <span class="string">/(.). \1./</span>))<br />          <span class="comment"># get kicker</span><br />          arranged_hand = arrange_hand(md)<br />          arranged_hand.match(<span class="string">/(?:\S\S ){2}(\S)\S\s+(\S)\S\s+(\S)/</span>)<br />          [<br />            [<br />              2,<br />              Card::face_value(md[1]),<br />              Card::face_value(<span class="global">$1</span>),<br />              Card::face_value(<span class="global">$2</span>),<br />              Card::face_value(<span class="global">$3</span>)<br />            ],<br />            arranged_hand<br />          ]<br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> highest_card?<br />        result = by_face<br />        [[1, *result.face_values[0..4]], result.hand.join(<span class="string">' '</span>)]<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Now what we really need to know is which one of those hands was found.  The code for that isn't overly complex:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      OPS = [<br />        [<span class="string">'Royal Flush'</span>,     :royal_flush? ],<br />        [<span class="string">'Straight Flush'</span>,  :straight_flush? ],<br />        [<span class="string">'Four of a kind'</span>,  :four_of_a_kind? ],<br />        [<span class="string">'Full house'</span>,      :full_house? ],<br />        [<span class="string">'Flush'</span>,           :flush? ],<br />        [<span class="string">'Straight'</span>,        :straight? ],<br />        [<span class="string">'Three of a kind'</span>, :three_of_a_kind?],<br />        [<span class="string">'Two pair'</span>,        :two_pair? ],<br />        [<span class="string">'Pair'</span>,            :pair? ],<br />        [<span class="string">'Highest Card'</span>,    :highest_card? ],<br />      ]<br /><br />      <span class="keyword">def</span> hand_rating<br />        OPS.map { |op|<br />          (method(op[1]).call()) ? op[0] : <span class="keyword">false</span><br />        }.find { |v| v }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> score<br />        OPS.map { |op|<br />          method(op[1]).call()<br />        }.find([0]) { |score| score }<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The OPS Array maps hand names to the method that will spot them.  With that, you call call either hand_rating() or score() which will walk the whole list of tests, then return the first one that was true.  hand_rating() returns the name while score() returns the rank and hand Array from the hand method call.</p>
			<p>Finally, Hand has a few more very basic helper methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> take_card(card)<br />        <span class="variable">@hand</span>.push(card)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> arranged_hand<br />        score[1] + <span class="string">" (#{hand_rating})"</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> just_cards<br />        <span class="variable">@hand</span>.join(<span class="string">" "</span>)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_s<br />        just_cards + <span class="string">" ("</span> + hand_rating + <span class="string">")"</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The only thing to notice there is the arranged_hand() is just a shell over score() and hand_rating() and to_s() is a shell over just_cards() and hand_rating().</p>
			<p>The rest of Patrick's code goes on to build a complete game of Texas Hold'Em that plays itself out round by round and displays results as it goes.  This is very interesting stuff, but it doesn't solve the quiz, the way I read it.  Luckily, a solution is easy to finish off from here.  Here's my solution to the quiz, using Partick's classes:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment">### code by JEG2 ###</span><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />        best = <span class="keyword">nil</span><br />        results = []<br /><br />        ARGF.each_line <span class="keyword">do</span> |line|<br />            <span class="keyword">if</span> line.length &lt; 20                                <span class="comment"># they folded</span><br />                results &lt;&lt; line.chomp<br />            <span class="keyword">else</span><br />                hand            = Hand.new(line)               <span class="comment"># rank hand</span><br />                name            = hand.hand_rating<br />                score, arranged = hand.score<br /><br />                <span class="keyword">if</span> best.nil? <span class="keyword">or</span> (score[0] &lt;=&gt; best[0]) == 1    <span class="comment"># track best</span><br />                    best = [score[0], results.size]<br />                <span class="keyword">end</span><br /><br />                results &lt;&lt; <span class="string">"#{arranged} #{name}"</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># show results</span><br />        results.each_with_index <span class="keyword">do</span> |e, index|<br />            puts(<span class="keyword">if</span> index == best[1] <span class="keyword">then</span> <span class="string">"#{e} (winner)"</span> <span class="keyword">else</span> e <span class="keyword">end</span>)<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That should be pretty straight forward by this point.  I setup variables to track the best hand and the complete results, parse input, handle folds, score each hand, remembering to track the best so far, and finally out the results.  That funny compare, (score[0] &lt;=&gt; best[0]) == 1, is because the grade returned by score is actually an Array of values and Array implements &lt;=&gt; but not &gt;; go figure.  That gets me the following output for the quiz example:</p>
			<p class="example">Ks Kd Kc 9s 9d 6d 3c Full house (winner)<br />Ks Kd 9d 9c Ah 6d 3c Two pair<br />Ac Qc Ks Kd 9d 3c<br />9h 5s<br />Kd 9d 6d 4d 2d Ks 3c Flush<br />7s Ts Ks Kd 9d</p>
			<p>While I'm showing output, check out this neat variation by Derek Wyatt:</p>
			<p class="example">9d 9s Kd Ks Kc 3c 6d  Full House (Kings over Nines) (winner)<br />9d 9c Kd Ks Ah 3c 6d  Two Pair (Kings and Nines)<br />Ac Qc Ks Kd 9d 3c     <br />9h 5s                 <br />Ks Kd 2d 4d 3c 6d 9d  Pair (Kings)<br />7s Ts Ks Kd 9d        </p>
			<p>I love the way it gives you extra details about the hand, but as you can see we don't agree on hand number four.  Don't sweat that though, seems everyone had a good round of bug hunting for this one.</p>
			<p>My thanks to all the card sharks out there.  I also want to thank Patrick for writing code I could figure out how to hijack.  This summary was definitely a team effort.</p>
			<p>Tomorrow, Tymothy Byrd will hit you with a brain bender you and Ruby can work together to solve...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134340">Derek Wyatt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134369">Glenn Parker</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134409">Matthew D Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134507">Patrick Hurley</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134533">Carlos</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134782">Patrick Hurley (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134815">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134836">Dave Burt (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134850">Patrick Hurley</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134870">Carlos (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134891">Carlos (3)</a></li>
			</ol>
			<p><a href="quiz24_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
