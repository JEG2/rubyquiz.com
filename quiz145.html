<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Editing Text (#145)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Editing Text (#145)</span>
			<p>by Eric Mahurin</p>
			<p>Have you ever wondered how a text buffer might be represented in a text editor or word processor? A simple string to represent text buffer isn't efficient enough because inserting (i.e. typing) and deleting (backspace) in the middle would result in moving all of the text to the end for each operation. A data structure that can efficiently insert and delete in the middle is needed.</p>
			<p>The task is to implement data structures for efficiently editing text. One common data structure is a gap buffer:</p>
			<p><a href="http://en.wikipedia.org/wiki/Gap_buffer">Gap buffer</a></p>
			<p>Other options to consider include: ropes (see quiz #137), linked lists, simple strings, or a multi-level combination of data structures (i.e. for lines vs. characters in a line). There are many data structures that may work efficiently with simple editing operations, but not all of those data structures will work well for more complex functionality.</p>
			<p>All of the basic operations occur around a text cursor. The minimal operations on/at the cursor should be:</p>
			<p class="example">* Insert a character before or after the cursor.<br />* Delete a character before or after the cursor and return the<br />  deleted character.<br />* Move the cursor left or right (crossing line boundaries if<br />  necessary) and return the character or nil at the beginning<br />  or end of the buffer.<br />* Move the cursor up or down a line and return nil/false only if a<br />  line boundary could not be crossed.  The cursor may be placed in<br />  the most natural column for the data structure.</p>
			<p>Additional useful operations that you might find in a typical text editor can also be added:</p>
			<p class="example">* Get current line and column numbers<br />* Copy some amount of text before or after the cursor and return  <br />  this buffer.<br />* Display some context around the cursor.<br />* Cut some amount of text before or after the cursor and return<br />  this buffer.<br />* Paste a copy/cut buffer before or after the cursor.<br />* Insert a file.<br />* Write to a file.<br />* Goto a specific line or column.<br />* Goto the begin/end of the line/buffer.<br />* Copy or cut to a specific line/column.<br />* Filter some text through a ruby block.<br />* Search (and possibly replace) using a regular expression.<br />* Undo/redo.</p>
			<p>Major bonus points for the following where gap buffers probably won't work:</p>
			<p class="example">* Only store changes to a file.<br />* Handle multiple efficient cursors in a text buffer.</p>
			<p>Although the focus is on data structures and making the ruby DSL equivalent to unix "ed" or DOS "edlin", a GUI could be added to make a full-screen/window text editor.</p>
			<p>Here is a benchmark for testing that needs the minimal implementation (#insert_before, #insert_after, #delete_before, #delete_after, #left, #right, #up, #down):</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># edit_test.rb</span><br />    <span class="comment"># usage: ruby -r klass.rb edit_test.rb &lt;iter&gt; \</span><br />    <span class="comment">#        [&lt;constructor&gt; [&lt;lines&gt; &lt;columns&gt;] ...]</span><br /><br />    require <span class="string">'benchmark'</span><br />    require <span class="string">'test/unit/assertions'</span><br />    include Test::Unit::Assertions<br /><br />    <span class="comment"># char = byte pre 1.9, each_char already defined in 1.9</span><br />    <span class="keyword">unless</span> <span class="string">""</span>.respond_to?(:each_char)<br />      <span class="keyword">class</span> String;alias_method(:each_char, :each_byte);<span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    iterations = ARGV.shift.to_i<br /><br />    <span class="keyword">while</span> cursor = ARGV.shift<br />      nlines = (ARGV.shift || 10000).to_i<br />      ncolumns = (ARGV.shift || 100).to_i<br />      n = nlines*ncolumns<br />      chars = (?a..?z).to_a<br />      line = (0...ncolumns).inject(<span class="string">""</span>) { |line, i|<br />        line &lt;&lt; chars[i%chars.length]<br />      }<br />      line[-1] = ?\n<br /><br />      iterations.times { eval(cursor).instance_eval {<br />        Benchmark.benchmark(<br />          <span class="string">"#{cursor}: #{nlines}x#{ncolumns}\n"</span>,16,<span class="keyword">nil</span>,<span class="string">"total"</span><br />        ) { |b|<br /><br />          total = b.report(<span class="string">"insert_before"</span>) {<br />            nlines.times { line.each_char { |ch| insert_before(ch) } }<br />          }<br />          i = 0<br />          total += b.report(<span class="string">"left"</span>) { i += 1 <span class="keyword">while</span> left }<br />          assert_equal(n, i)<br />          i = 0<br />          total += b.report(<span class="string">"right"</span>) { i += 1 <span class="keyword">while</span> right }<br />          assert_equal(n, i)<br />          i = 0<br />          total += b.report(<span class="string">"up"</span>) { i += 1 <span class="keyword">while</span> up }<br />          assert_equal(nlines, i)<br />          i = 0<br />          total += b.report(<span class="string">"down"</span>) { i += 1 <span class="keyword">while</span> down }<br />          assert_equal(nlines, i)<br />          total += b.report(<span class="string">"insert_after"</span>) {<br />            nlines.times { line.each_char { |ch| insert_after(ch) } }<br />          }<br />          i = 0<br />          total += b.report(<span class="string">"delete_before"</span>) {<br />            i += 1 <span class="keyword">while</span> delete_before<br />          }<br />          assert_equal(n, i)<br />          i = 0<br />          total += b.report(<span class="string">"delete_after"</span>) {<br />            i += 1 <span class="keyword">while</span> delete_after<br />          }<br />          assert_equal(n, i)<br /><br />          [total]<br /><br />        }<br />      } }<br />    <span class="keyword">end</span><br /></div></div>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Implementing an efficient data structure for this problem can be tricky.  A couple of the solutions turned out to have a higher complexity than it first appeared.  That doesn't mean they aren't valuable to examine though.</p>
			<p>Let's have a look at Holger's code below.  It's an implementation of the quiz-recommended gap buffer data structure.  It's a very clean implementation of the idea that helped me understand what a gap buffer really is.  Here's the constructor:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> GapBuffer<br />      <span class="keyword">def</span> initialize(data=<span class="string">""</span>, i=0)<br />        <span class="variable">@data</span> = data<br />        <span class="variable">@gap_start</span> = i<br />        <span class="variable">@gap_len</span> = 0<br />        <span class="variable">@GAP</span> = <span class="string">" "</span>*64<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The actual content of our text editing session will be kept in @data.  However, that data may contain some extra material called a "gap," which will begin at the index @gap_start and be @gap_len characters long.  @GAP is just a constant used to insert new gaps when that last one is exhausted.</p>
			<p>How this interacts in usage is well shown by the insert methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> insert_before(ch)<br />        <span class="keyword">if</span> <span class="variable">@gap_len</span>.zero?<br />          <span class="variable">@data</span>[<span class="variable">@gap_start</span>, 0] = <span class="variable">@GAP</span><br />          <span class="variable">@gap_len</span> = <span class="variable">@GAP</span>.length<br />        <span class="keyword">end</span><br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span>] = ch<br />        <span class="variable">@gap_start</span> += 1<br />        <span class="variable">@gap_len</span> -= 1<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> insert_after(ch)<br />        <span class="keyword">if</span> <span class="variable">@gap_len</span>.zero?<br />          <span class="variable">@data</span>[<span class="variable">@gap_start</span>, 0] = <span class="variable">@GAP</span><br />          <span class="variable">@gap_len</span> = <span class="variable">@GAP</span>.length<br />        <span class="keyword">end</span><br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span>+<span class="variable">@gap_len</span>-1] = ch<br />        <span class="variable">@gap_len</span> -= 1<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The idea for both of these methods is simple.  To add content, we place it in either end of the gap, shrinking the space available there.  To insert a character before the caret we must add the character to the beginning of the gap, bump the gap start index beyond the new character, and decrease our count of available space in the gap.  Adding after the caret just means placing the character at the end and decreasing the length counter.</p>
			<p>The if statement at the beginning of both of these methods watches for the gap to be exhausted.  When we run out of space, a new gap is inserted and our length counter is reset.</p>
			<p>Deleting characters is just the opposite operation:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> delete_before<br />        <span class="keyword">return</span> <span class="keyword">if</span> <span class="variable">@gap_start</span>.zero?<br />        <span class="variable">@gap_start</span> -= 1<br />        <span class="variable">@gap_len</span> += 1<br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span>]<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> delete_after<br />        <span class="keyword">return</span> <span class="keyword">if</span> <span class="variable">@gap_start</span>+<span class="variable">@gap_len</span> &gt;= <span class="variable">@data</span>.length<br />        <span class="variable">@gap_len</span> += 1<br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span>+<span class="variable">@gap_len</span>-1]<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>To remove something all we really have to do is to manipulate our index and/or length to put the discarded character back into the gap.  Once there, later operations can overwrite it normally.</p>
			<p>Note that the last lines of these methods return the "deleted" character and the first lines skip the operations when there are no characters beyond the gap.</p>
			<p>Now the harder operations of a gap buffer are moving the caret.  We'll start with left() and right(), which are the easier moves:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> left<br />        <span class="keyword">return</span> <span class="keyword">if</span> <span class="variable">@gap_start</span>.zero?<br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span>+<span class="variable">@gap_len</span>-1] = <span class="variable">@data</span>[<span class="variable">@gap_start</span>-1]<br />        <span class="variable">@gap_start</span> -= 1<br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span>]<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> right<br />        <span class="keyword">return</span> <span class="keyword">if</span> <span class="variable">@gap_start</span>+<span class="variable">@gap_len</span>&gt;=<span class="variable">@data</span>.length<br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span>] = <span class="variable">@data</span>[<span class="variable">@gap_start</span> + <span class="variable">@gap_len</span>]<br />        <span class="variable">@gap_start</span> += 1<br />        <span class="variable">@data</span>[<span class="variable">@gap_start</span> - 1]<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Moving the caret to either side means transferring a character from one end of the buffer to the other.  Then we can just expand the gap to include the moved character's previous location, so future editing operations will swallow in up.  For example, given the following data:</p>
			<p class="example">The gap buffer[     ], or our caret, is shown here with brackets.</p>
			<p>A move to the left() is gives us:</p>
			<p class="example">The gap buffe[r     ]r, or our caret, is shown here with brackets.</p>
			<p>The moved character is on the right of the buffer while the original is inside.  Characters inside the buffer don't really exist in the content so we don't have any duplication here.</p>
			<p>Now for the hard moves:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> up<br />        col = column<br />        cursor = <span class="variable">@gap_start</span>-col<br />        <span class="keyword">return</span> <span class="keyword">if</span> cursor.zero?<br />        cursor_line = <span class="variable">@data</span>.rindex(?\n, cursor-2)<br />        cursor_line = 0 <span class="keyword">if</span> cursor_line.nil?<br />        cursor_line += col+1<br />        <span class="keyword">if</span> cursor_line &gt; cursor-1<br />          cursor_line = cursor-1<br />        <span class="keyword">end</span><br />        left <span class="keyword">while</span> <span class="variable">@gap_start</span> &gt; cursor_line<br />        <span class="keyword">true</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> down<br />        col = column<br />        cursor = <span class="variable">@data</span>.index(?\n, <span class="variable">@gap_start</span> + <span class="variable">@gap_len</span>)<br />        <span class="keyword">return</span> <span class="keyword">if</span> cursor.nil?<br />        cursor_line = cursor+1+col<br />        cursor = <span class="variable">@data</span>.index(?\n, cursor+1)<br />        cursor = <span class="variable">@data</span>.length <span class="keyword">if</span> cursor.nil?<br />        cursor_line = cursor <span class="keyword">if</span> cursor_line &gt; cursor<br />        right <span class="keyword">while</span> <span class="variable">@gap_start</span> + <span class="variable">@gap_len</span> &lt; cursor_line<br />        <span class="keyword">true</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>While this looks like a lot of code, the procedure is simple.</p>
			<p>The column() helper method, which we will see shortly, figures out where we are in the current line.  For the down() method, that's really all we need to mark our current location.  When moving up() though, we want to reach the line before ours, or somewhere between one and two newlines back.  To make that easier, up() first backs up by the column count to start the search from the beginning of the line.</p>
			<p>Then we have a terrific use index()/rindex() with the optional minimum index parameter to find the next newline past the end of the gap buffer.  When that search fails, the caret is moved to the beginning or end of the data which must be the last line we needed to cross.  Having found the desired line, the current column is added on, and trimmed to match the data if it exceeds the line.</p>
			<p>Together, these operations give us a where we are and where we need to get to.  The actual move is performed with repeated calls to left()/right(), one for each character we need to travel.</p>
			<p>Here are a couple of location methods, one of which we just saw in use:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> position<br />        <span class="variable">@gap_start</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> column<br />        lbreak = <span class="variable">@data</span>.rindex(?\n, <span class="variable">@gap_start</span>-1)<br />        lbreak.nil? ? <span class="variable">@gap_start</span> : (<span class="variable">@gap_start</span>-(lbreak+1))<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>As you can see, position() is just an alias for @gap_start.  The column() method though is just more clever use of the rindex() method.  It really works just like we saw in up(), save that it doesn't need to skip over a newline.</p>
			<p>The last operation supported by this solution is to stringify the data:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> to_s<br />        <span class="keyword">return</span> <span class="variable">@data</span>[0, <span class="variable">@gap_start</span>] +<br />               <span class="variable">@data</span>[<span class="variable">@gap_start</span>+<span class="variable">@gap_len</span>, <span class="variable">@data</span>.length-<span class="variable">@gap_start</span>-<span class="variable">@gap_len</span>]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The actual data is just the concatenation of what's on both sides of the gap.  The code above assembles that with simple indexing.</p>
			<p>Holger had hoped the solution was O(n), but unfortunately it turns out to be O(n**2).  Eric explains why this is and provides tips for how to get it to O(n) in this email:</p>
			<p><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/277308">Eric's Analysis of Holger's Algorithm</a></p>
			<p>While the code does need the mentioned changes to reduce its complexity, I still felt it was a very clean implementation of the gap buffer and quite easy to follow.  This should make fixing it up a snap.</p>
			<p>My thanks to those who did manage to find the time for the quiz.  It was a tricky problem to do well and all of the solutions showed off neat approaches.</p>
			<p>Tomorrow we will do some vehicle counting, programmer style...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/276426">Eric Mahurin</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/276731">Holger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/276856">Eric Mahurin (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/277598">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/277640">Matthew Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/277747">Eric Mahurin (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/278082">Sean Surname</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/278132">Sean Surname (2)</a></li>
			</ol>
			<p><a href="quiz145_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
