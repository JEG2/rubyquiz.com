<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Madlibs (#28)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Madlibs (#28)</span>
			<p>This week's Ruby Quiz is to write a program that presents the user with Madlibs.  The script should ask the user for a series of words, then fill in the proper places in the story using the user's answers.</p>
			<p>We'll keep our story format very simple, using a ((...)) notation for placeholders.  Here's an example:</p>
			<p class="example">Our favorite language is ((a gemstone)).</p>
			<p>If your program is fed that template, it should ask you to enter "a gemstone" and then display your version of the story:</p>
			<p class="example">Our favorite language is Ruby.</p>
			<p>That covers the simple cases, but in some instances we may want to reuse an answer.  For that, we'll introduce a way to name them:</p>
			<p class="example">Our favorite language is ((gem:a gemstone)).  We think ((gem)) is better<br />than ((a gemstone)).</p>
			<p>With the above story, your program should ask for two gemstones, then substitute the one designated by ((gem:...)) at ((gem)).  That would give results like:</p>
			<p class="example">Our favorite language is Ruby.  We think Ruby is better than Emerald.</p>
			<p>You can choose any interface you like, as long as person can interact with the end result.  You can play around with my solution here:</p>
			<p><a href="http://rubyquiz.com/cgi-bin/madlib.cgi">Ruby Quiz Madlibs</a></p>
			<p>And here are the two Madlib files I'm using, to get you started:</p>
			<p><a href="http://rubyquiz.com/madlibs/Lunch_Hungers.madlib">Lunch Hungers</a></p>
			<p><a href="http://rubyquiz.com/madlibs/Gift_Giving.madlib">Gift Giving</a></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Well, if nothing else these are a fun little distraction, eh?  Actually, I was surprised to discover (when writing the quiz), how practical this challenge is.  Madlibs are really just a templating problem and that comes up in many aspects of programming.  Have a look at the "views" in Rails, for a strong real-world example.</p>
			<p>Looking at the problem that way got me to thinking, doesn't Ruby ship with a templating engine?  Yes, it does.  We could use that to build our solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby -w</span><br /><br />    <span class="comment"># use Ruby's standard template engine</span><br />    require <span class="string">"erb"</span><br /><br />    <span class="comment"># storage for keyed question reuse</span><br />    <span class="global">$answers</span> = Hash.new<br /><br />    <span class="comment"># asks a madlib question and returns an answer</span><br />    <span class="keyword">def</span> q_to_a( question )<br />        question.gsub!(<span class="string">/\s+/</span>, <span class="string">" "</span>)       <span class="comment"># noramlize spacing</span><br /><br />        <span class="keyword">if</span> <span class="global">$answers</span>.include? question    <span class="comment"># keyed question</span><br />            <span class="global">$answers</span>[question]<br />        <span class="keyword">else</span>                             <span class="comment"># new question</span><br />            key = <span class="keyword">if</span> question.sub!(<span class="string">/^\s*(.+?)\s*:\s*/</span>, <span class="string">""</span>) <span class="keyword">then</span> <span class="global">$1</span> <span class="keyword">else</span> <span class="keyword">nil</span> <span class="keyword">end</span><br /><br />            print <span class="string">"Give me #{question}:  "</span><br />            answer = <span class="global">$stdin</span>.gets.chomp<br /><br />            <span class="global">$answers</span>[key] = answer <span class="keyword">unless</span> key.nil?<br /><br />            answer<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># usage</span><br />    <span class="keyword">unless</span> ARGV.size == 1 <span class="keyword">and</span> test(?e, ARGV[0])<br />        puts <span class="string">"Usage:  #{File.basename(__FILE__)} MADLIB_FILE"</span><br />        exit<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># load Madlib, with title</span><br />    madlib = <span class="string">"\n#{File.basename(ARGV[0], '.madlib').tr('_', ' ')}\n\n"</span> +<br />             File.read(ARGV[0])<br />    <span class="comment"># convert ((...)) to &lt;%= q_to_a('...') %&gt;</span><br />    madlib.gsub!(<span class="string">/\(\(\s*(.+?)\s*\)\)/</span>, <span class="string">"&lt;%= q_to_a('\\1') %&gt;"</span>)<br />    <span class="comment"># run template</span><br />    ERB.new(madlib).run<br /><br /></div></div>
			<p>The main principal here is to convert ((...)) to &lt;%= ... %&gt;, so we can use Ruby's own template engine.  Of course, &lt;%= a noun %&gt; isn't going to be valid Ruby code, so a helper method is needed.  That's where q_to_a() comes in.  It takes the Madlib replacements as an argument and returns the user's answer.  To use that we actually need to convert ((...)) to &lt;%= q_to_a('...') %&gt;.  From there, ERb does the rest of the work for us.</p>
			<p>Now for simple Madlibs, you don't really need something as robust as ERb.  It's easy to roll your own solution and most people did just that.  Let's examine Sean E. McCardell's code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Madlib<br /><br />      <span class="comment"># Given the madlib text as a string, builds a list of questions and</span><br />      <span class="comment"># a map of questions to "blanks"</span><br />      <span class="keyword">def</span> initialize(txt)<br />        <span class="variable">@questions</span> = []<br />        <span class="variable">@story_parts</span> = []<br />        <span class="variable">@answer_list</span> = []<br />        <span class="variable">@answers</span> = []<br /><br />        stored = {}<br /><br />        txt.split(<span class="string">/\((\([^)]*\))\)/</span>).each <span class="keyword">do</span> |item|<br />          <span class="keyword">if</span> item[0] == ?(<br />            item = item[1..-2].gsub(<span class="string">"\n"</span>, <span class="string">' '</span>)<br />            <span class="keyword">if</span> item.index(<span class="string">':'</span>)<br />              name, question = item.split(<span class="string">':'</span>)<br />              stored[name] = <span class="variable">@questions</span>.length<br />              <span class="variable">@questions</span> &lt;&lt; question<br />            <span class="keyword">else</span><br />              name, question = item, item<br />            <span class="keyword">end</span><br />            <span class="variable">@answer_list</span> &lt;&lt; (stored[name] || <span class="variable">@questions</span>.length)<br />            <span class="variable">@questions</span> &lt;&lt; question <span class="keyword">unless</span> stored[name]<br />          <span class="keyword">else</span><br />            <span class="variable">@story_parts</span> &lt;&lt; item<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Calls a block with the index and text of each question</span><br />      <span class="keyword">def</span> list_questions(&amp;block)<br />        <span class="variable">@questions</span>.each_index <span class="keyword">do</span> |i|<br />          <span class="keyword">yield</span>(i, <span class="variable">@questions</span>[i])<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Stores the answer for a given question index</span><br />      <span class="keyword">def</span> answer_question(i, answer)<br />        <span class="variable">@answers</span>[i] = answer<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Returns a string with the answers filled-in to their respective blanks</span><br />      <span class="keyword">def</span> show_result<br />        real_answers = <span class="variable">@answer_list</span>.collect {|i| <span class="variable">@answers</span>[i]}<br />        <span class="variable">@story_parts</span>.zip(real_answers).flatten.compact.join<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># Example that reads the madlib text from a file specified on the</span><br />    <span class="comment"># command line</span><br /><br />    madlib = Madlib.new(IO.read(ARGV.shift))<br />    answers = []<br />    madlib.list_questions <span class="keyword">do</span> |i, q|<br />      print <span class="string">"Give me "</span> + q + <span class="string">": "</span><br />      answers[i] = gets.strip<br />    <span class="keyword">end</span><br />    answers.each_index {|i| madlib.answer_question(i, answers[i]) }<br />    puts madlib.show_result<br /><br /></div></div>
			<p>The Madlib object handles the heavy lifting here.  initialize() really does a lot of the work.  It breaks the story down into an internal format which is primarily a list of @story_parts, @questions, and @answers.  Since the answer to a question may be used in more than one place, an @answer_list is also built as a mapping between the actual answers and all their replacements.</p>
			<p>You can see this chunking process in the bottom half of initialize().  It basically split()s the story around ((...)) replacement sections.  The split() Regexp uses capturing parentheses to ensure that the replacements themselves are returned, in addition to the story parts.</p>
			<p>Inside the iterator, the outer if branches to handle either questions (starting with a "(" character) or story parts.  Each item is added to the correct list.  Questions are also examined for the extra label and the stored Hash resolves these repeats as they occur.</p>
			<p>The next method, list_questions(), provides iteration over the list of questions.  (Note that the &amp;block parameter isn't used in the method and could be removed.)  The block is yielded an index and the current question.  The index can be used to feed an answer to the sister method, answer_question(), which just stores answers.</p>
			<p>The final method of the class, show_result(), uses the @answer_list map to construct a list of real_answers.  That list is zip()ed with @story_parts to produce the final output.</p>
			<p>The final chunk of code just puts the class to work.  An object is constructed from the file passed as a command-line argument.  Next, the code walks the questions, asking each one in turn and collecting answers.  Those answers are passed to answer_question(), and the final results are printed.  I believe you could do away with the extra Array in this section and simplify a little:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    madlib = Madlib.new(IO.read(ARGV.shift))<br />    madlib.list_questions <span class="keyword">do</span> |i, q|<br />      print <span class="string">"Give me "</span> + q + <span class="string">": "</span><br />      madlib.answer_question(i, gets.strip)<br />    <span class="keyword">end</span><br />    puts madlib.show_result<br /><br /></div></div>
			<p>Well, there's a look at a couple of the solutions.  Other solutions involved CGI, PDF output (very cool!), and even a little golf action.  Don't miss looking over them.</p>
			<p>My thanks to all the spongy Madlibers who took the time to fill out my fire-hose.</p>
			<p>Tomorrow we'll use the quiz to start a new library for Ruby that will hopefully ease the ins and outs of common coding...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138552">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138553">Ryan Leavengood</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138604">Javier Fontan</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138608">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138612">Steve Li</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138614">Sean E. McCardell</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138638">Steve Li (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/138647">Lyndon Samson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/139032">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/139051">James Edward Gray II (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/139198">Dave Burt (2)</a></li>
			</ol>
			<p><a href="quiz28_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
