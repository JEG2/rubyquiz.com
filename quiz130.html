<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Hangman (#130)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Hangman (#130)</span>
			<p>by Brian Candler</p>
			<p>Most people are probably familiar with the game of Hangman. The first player picks a word or phrase, and the second player has to guess it a letter at a time. If they make six wrong guesses (i.e. the target word does not contain the guessed letter), they lose. If they guess the entire word before then, they win.</p>
			<p>This quiz is to make a Hangman guessing player in Ruby. Play should proceed as follows:</p>
			<p class="example">1. The program requests a word or phrase pattern, e.g. "-------".<br /><br />2. The program suggests a letter, or may guess the entire word or phrase.<br /><br />3. The user indicates which letter positions, if any, match that letter.<br />   If none match, a life is lost. If six (or configurable) lives are lost,<br />   the program loses.</p>
			<p>The specification is otherwise open-ended to allow you to focus on whatever part of the problem interests you. For example:</p>
			<p class="example">* You may choose the form of user interface (e.g. terminal, GUI toolkit,<br />  web).<br /><br />* You can just show the number of wrong guesses made, or you can actually<br />  draw the hangman.<br /><br />* You may concentrate on improving the play, for example by using a<br />  dictionary to improve the guesses made at each stage. A suitable file<br />  is /usr/share/dict/words on many Linux systems.<br /><br />* A dynamic solution could start with an empty dictionary, and guess the<br />  answer by chance. If it fails, it would prompt the user for the word<br />  or phrase they were thinking of. It would add new words or phrases to<br />  its dictionary so as to become a better player over time.<br /><br />* You could investigate ways of precomputing a hangman decision tree,<br />  optimizing it for the minimum number of wrong guesses along each branch.<br />  The aim is to produce an unbeatable guesser for a given dictionary.<br /><br />* You may wish to consider how best to decouple the UI from the guessing<br />  logic, to enable different UI's to work with the same guessing engine,<br />  or vice versa.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>People wrote quite a bit of code for this quiz.  I'm guessing that's because it can be challenging to see how your code is doing and to refine that.</p>
			<p>I'm going to show my own solution this time, not because it's any better than the others, but because I can talk you through my thinking in building it.</p>
			<p>The first thing in my code is a tiny library that handles dictionary loading for the guessing script and the test script.  I extracted this common functionality when I built my testing script:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby -wKU</span><br /><br />    WORDS_CASH_FILE = <span class="string">"words.cache"</span><br /><br />    <span class="keyword">if</span> File.exist? WORDS_CASH_FILE<br />      WORDS = File.open(WORDS_CASH_FILE) { |file| Marshal.load(file) }<br />    <span class="keyword">else</span><br />      WORDS = File.open( ARGV.find { |arg| arg =~ <span class="string">/\A[^-]/</span> } ||<br />                         <span class="string">"/usr/share/dict/words"</span> ) <span class="keyword">do</span> |dict|<br />        dict.inject(Hash.new) <span class="keyword">do</span> |all, word|<br />          all.update(word.delete(<span class="string">"^A-Za-z"</span>).downcase =&gt; <span class="keyword">true</span>)<br />        <span class="keyword">end</span>.keys.sort_by { |w| [w.length, w] }<br />      <span class="keyword">end</span><br />      File.open(WORDS_CASH_FILE, <span class="string">"w"</span>) { |file| Marshal.dump(WORDS, file) }<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>There's nothing too fancy here.  Originally I just reread the dictionary every time, but that slowed down testing too much and I found caching it with Marshal helped.  I also started sorting the dictionary, eventually, to make it easier to see where my testing was, "I've tried everything beneath four letters and I'm in the K's on those."</p>
			<p>On to the guessing script.  Here's how that begins:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby -wKU</span><br /><br />    puts <span class="string">"One moment..."</span><br />    puts<br />    require <span class="string">"words"</span><br /><br />    <span class="keyword">def</span> frequency(words)<br />      freq = Hash.new(0)<br />      words.each <span class="keyword">do</span> |word|<br />        word.split(<span class="string">""</span>).each { |letter| freq[letter] += word.count(letter) }<br />      <span class="keyword">end</span><br />      freq<br />    <span class="keyword">end</span><br />    FREQ = frequency(WORDS).sort_by { |_, count| -count }.<br />                            map { |letter, _| letter }<br /><br />    choices = WORDS<br />    guesses = Array.new<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This code prints a warning that loading the dictionary might take a moment, then requires the mini-library I just showed.  Once loaded, it defines a method for counting letter frequencies and runs it on the dictionary.</p>
			<p>After that it initializes some state variables for the guessing.  The script decreases the word list as it works, so that is copied into a variable to reflect that it will change.  We then setup a way to keep track of our guesses.</p>
			<p>The next bit of code begins the main event loop:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    loop <span class="keyword">do</span><br />      puts guesses.empty?                                       ?<br />           <span class="string">"Please enter a word pattern (_ _ _ _ for example):"</span> :<br />           <span class="string">"Please update your pattern according to my guess "</span>  +<br />           <span class="string">"(_ i _ _ for example):"</span><br />      <span class="global">$stdout</span>.flush<br />      pattern = <span class="global">$stdin</span>.gets.to_s.delete(<span class="string">"^A-Za-z_"</span>)<br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This code just asks the user for a pattern and retrieves what they give us.  The call to flush() is to support the test script, which we will see in a bit.</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      bad_guesses = guesses - pattern.delete(<span class="string">"_"</span>).split(<span class="string">""</span>)<br />      <span class="keyword">if</span> bad_guesses.size &gt; 5 <span class="keyword">and</span> pattern.include? <span class="string">"_"</span><br />        puts <span class="string">"I'm out of guesses.  You win."</span><br />      <span class="keyword">elsif</span> <span class="keyword">not</span> pattern.include? <span class="string">"_"</span><br />        puts <span class="string">"I guessed your word.  Pretty smart, huh?"</span><br />      <span class="keyword">else</span><br />        choices = choices.grep(<br />                    bad_guesses.empty?             ?<br />                    <span class="string">/\A#{pattern.tr("_", ".")}\Z/</span>i :<br />                    <span class="string">/\A(?!.*[#{bad_guesses.join}])#{pattern.tr("_", ".")}\Z/</span>i<br />                  )<br />        guess = frequency(choices).<br />                  reject { |letter, _| guesses.include? letter }.<br />                  sort_by { |letter, count| [-count, FREQ.index(letter)] }.<br />                  first.first <span class="keyword">rescue</span> <span class="keyword">nil</span><br /><br />        guesses &lt;&lt; guess<br />        puts <span class="string">"I guess the letter '#{guess}'."</span><br />        puts<br />        <span class="keyword">next</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is the main body of this guessing script.  The first two branches just check for win and loss conditions, but the else branch is where the logic is.</p>
			<p>Before a selection is made, the dictionary is reduced by all words that couldn't possibly match.  After that, a frequency count is made for all remaining possibilities.  Those possible letters are then sorted by that count and how common they are in this dictionary.  The letter that bubbles to the top is our choice.</p>
			<p>This selection process works decently on larger words.  It really starts to show decent success rates at words four letters and longer.  Sadly, it fairs poorly with smaller words.</p>
			<p>Once chosen a guess is printed for the user and the loop cycles to the next iteration.</p>
			<p>When we fall through the above code we have reached an end condition.  The following code sorts that out:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      puts<br />      <span class="keyword">if</span> ARGV.include? <span class="string">"--loop"</span><br />        choices = WORDS<br />        guesses = Array.new<br />      <span class="keyword">else</span><br />        <span class="keyword">break</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Here I watch for a special command-line switch that puts the program into a continuous loop for testing.  This avoids reloading the dictionary and thus is faster.</p>
			<p>I landed on my word choice strategy mainly by trial and error.  That was made possible by being able to run the algorithm over some words and watching how accurately it could pick them.  I did that by writing a simple script that pretend to be me.  It runs the game, feeds it words, and keeps score of its progress.  Here's the start of that code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby -wKU</span><br /><br />    require <span class="string">"words"</span><br /><br />    results = Hash.new(0)<br />    at_exit <span class="keyword">do</span><br />      results[:total] = results[:right] + results[:wrong]<br />      puts<br />      puts   <span class="string">"Words:     #{results[:total]}"</span><br />      puts   <span class="string">"Guessed:   #{results[:right]}"</span><br />      puts   <span class="string">"Missed:    #{results[:wrong]}"</span><br />      printf <span class="string">"Accuracy:  %.2f%%\n"</span>, <br />             results[:right] / results[:total].to_f * 100<br />      puts<br />    <span class="keyword">end</span><br />    trap(<span class="string">"INT"</span>) { exit }<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here I load the dictionary using the same code the guesser relies on.  Then I build a Hash to hold guess counts and setup result printing for when the program exits.  This allows me to cancel test runs at anytime, but still see results thus far.  That was nice for spot checking results.  Sometimes I could tell right away that a change was better or worse.</p>
			<p>Here's the actual testing code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    IO.popen( File.join(File.dirname(<span class="keyword">__FILE__</span>), <span class="string">"hangman.rb --loop"</span>),<br />              <span class="string">"r+"</span> ) <span class="keyword">do</span> |hangman|<br />      WORDS.each <span class="keyword">do</span> |word|<br />        pattern = word.tr(<span class="string">"a-z"</span>, <span class="string">"_"</span>)<br />        loop <span class="keyword">do</span><br />          input = String.new<br />          hangman.each <span class="keyword">do</span> |line|<br />            input &lt;&lt; line<br />            <span class="keyword">break</span> <span class="keyword">if</span> input =~ <span class="string">/^(?:I'm out|I guessed)|:\Z/</span><br />          <span class="keyword">end</span><br /><br />          <span class="keyword">if</span> input =~ <span class="string">/^I'm out/</span><br />            puts <span class="string">"It missed '#{word}'."</span><br />            results[:wrong] += 1<br />            <span class="keyword">break</span><br />          <span class="keyword">elsif</span> input =~ <span class="string">/^I guessed/</span><br />            puts <span class="string">"It guessed '#{word}'."</span><br />            results[:right] += 1<br />            <span class="keyword">break</span><br />          <span class="keyword">elsif</span> input =~ <span class="string">/^I guess the letter '(.)'/</span><br />            guess = <span class="global">$1</span><br />            word.split(<span class="string">""</span>).each_with_index <span class="keyword">do</span> |letter, i|<br />              pattern[i, 1] = letter <span class="keyword">if</span> letter == guess<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br /><br />          hangman.puts pattern<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This code just runs the guessing script just as a human would do.  It feeds the script words and watches the responses to see what happens.  You can think of this process as a poor man's expect.</p>
			<p>Many of the other solutions achieved better results than my own, so be sure to look through them.  Some were quite long but most had decent documentation about their process.</p>
			<p>My thanks to all who found the time to dig into this problem.</p>
			<p>Tomorrow we have a classic computer science exercise and it's an easy one, so warm up your impress-people-with-a-concise-solution skills...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258372">Jesse Merriman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258405">Andreas Launila</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258489">Christopher Winslett</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258720">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258794">Paul Prestidge</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258797">Pascal Van Cauwenberghe</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258906">Yossef Mendelssohn</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258909">James Edward Gray II (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258912">Thomas Wieczorek</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258915">James Edward Gray II (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258926">James Edward Gray II (4)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258932">James Edward Gray II (5)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258938">Thomas Wieczorek (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/258948">James Koppel</a></li>
			</ol>
			<p><a href="quiz130_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
