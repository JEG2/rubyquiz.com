<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Solving Tactics (#18)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Solving Tactics (#18)</span>
			<p>by Bob Sidebotham</p>
			<p>There's a little pencil and paper game, Tactics, played on a 4x4 grid.
The play starts with an empty grid. On each turn, a player can fill in
one to four adjacent squares, either horizontally or vertically. The
player who fills in the last square loses.</p>
			<p>Here's a sample game to help clarify the above rules. The board
position at the end of each play is shown (best viewed in a
fixed-width font):</p>
			<p class="example">First player   Second player<br /><br />  X X X X        X X X X       (Turn 1)<br />  _ _ _ _        _ _ _ _<br />  _ _ _ _        _ _ X _<br />  _ _ _ _        _ _ X _<br /><br />  X X X X        X X X X       (Turn 2)<br />  X X _ _        X X _ X<br />  _ _ X _        _ _ X X<br />  _ _ X _        _ _ X _<br /><br />  X X X X        X X X X       (Turn 3)<br />  X X _ X        X X X X<br />  _ _ X X        _ _ X X<br />  _ _ X X        _ _ X X<br /><br />  X X X X        X X X X       (Turn 4)<br />  X X X X        X X X X<br />  X X X X        X X X X<br />  _ _ X X        X _ X X<br /><br />  X X X X                      (Turn 5<br />  X X X X                       Second<br />  X X X X                       player<br />  X X X X                       wins!)</p>
			<p>Your task, should you choose to accept it, is to write a Ruby program
which, given only these rules, determines whether the first or second
player is bound to be the winner, assuming perfect play. It should do
this in a "reasonable" amount of time and memory--it should definitely
take under a minute on any processor less than 5 years old. Bonus
points if you can make the case that your program actually gets the
right answer for the right reason!</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Tactics is a strange game to us chess players.  I'm so use to considering going first to be an advantage that I was just sure it would be true here too.  Wrong again.  In Tactics, the second player can always force a win.</p>
			<p>Though "why" this is true was part of the quiz, it hasn't really been answered to my satisfaction.  I suspect it has to do with the moves remaining.  The first player starts with the lead.  The second player can always choose to respond with moves that keep the first player in the lead.  If you're in the lead at the end of the game, you lose.  Put another way, the second player can always add to the first player's move just the right amount of squares to keep the number of remaining moves optimal.</p>
			<p>What does that have to do with the quiz?  Not much.  It's just a good example of the kinds of things I lose sleep over.</p>
			<p>This quiz turned out to be a little tougher than I expected, though it really shouldn't be.  A couple of people, including myself, posted about our failed attempts to build the entire move tree.  You need to be a bit move clever than that.</p>
			<p>Sea&amp;Gull shaved the move tree in half and even came up with the right answer.  I haven't been able to convince myself it's for the right reasons yet though, so I'm not going to look into that here.</p>
			<p>The key optimization hit on by both solutions is simple:  All squares are either on or off, thus ideal bit representation material.  An empty board is just 0b0000_0000_0000_0000 and the final board is 0b1111_1111_1111_1111.  To make a move, just "or" (|) it to the board.  To see if a move is possible "and" (&amp;) it to the board and check for a result of zero.</p>
			<p>As Bob Sidebotham said in the README of his solution, there are only 2**16 (65536) possible positions and bit math is as fast as a computer gets.  My machine needs about 4 seconds to get the answer with Bob's code.  Let's look at that code now:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Tactics<br />      <span class="comment"># The tactics board is represented as a 16-bit integer,</span><br />      <span class="comment"># 0's representing empty square; 1's representing filled squares.</span><br />      EMPTY, FULL = 0, 0xFFFF<br /><br />      <span class="comment"># Record a WIN or LOSS for potentially each of the 2**16 possible</span><br />      <span class="comment"># board positions. A position is recorded as a WIN (or LOSS) if</span><br />      <span class="comment"># that position represents a WIN (or LOSS) to a player prior to</span><br />      <span class="comment"># moving from that position.</span><br />      WIN, LOSS = 1, 0<br />      (<span class="variable">@@position</span> = Array.new(0x10000))[FULL] = WIN<br /><br />      <span class="comment"># Create a new Tactics game, starting at the specified position.</span><br />      <span class="keyword">def</span> initialize( board = EMPTY,<br />                      possible_moves = Tactics.all_possible_moves )<br />        <span class="variable">@board</span> = board<br />        <span class="variable">@possible_moves</span> = prune_possible_moves(board, possible_moves)<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Play from the current position. If *any* move guarantees a win,</span><br />      <span class="comment"># then mark this position as a WIN and return it. Otherwise this</span><br />      <span class="comment"># position loses.</span><br />      <span class="keyword">def</span> play<br />        <span class="variable">@possible_moves</span>.each <span class="keyword">do</span> |move|<br />          new_board = <span class="variable">@board</span> | move<br />          <span class="keyword">if</span> ( <span class="variable">@@position</span>[new_board] ||<br />               Tactics.new(new_board, <span class="variable">@possible_moves</span>).play) == LOSS <span class="keyword">then</span><br />            <span class="keyword">return</span> <span class="variable">@@position</span>[<span class="variable">@board</span>] = WIN<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="variable">@@position</span>[<span class="variable">@board</span>] = LOSS<br />      <span class="keyword">end</span><br /><br />      private<br /><br />      <span class="comment"># Reduce the set of possible moves provided to the actual moves</span><br />      <span class="comment"># that are possible from the specified starting position.</span><br />      <span class="keyword">def</span> prune_possible_moves(board, possible_moves)<br />        possible_moves.reject { |move| (board &amp; move) != 0 }<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Compute all possible moves from an empty board.</span><br />      <span class="keyword">def</span> <span class="keyword">self</span>.all_possible_moves<br />        <span class="comment"># Replicate the possibilities for a single row over each row and</span><br />        <span class="comment"># column of the grid.</span><br />        (0..3).inject([]) <span class="keyword">do</span> |moves, row|<br />          [ 0b1000, 0b0100, 0b0010, 0b0001, 0b1100,<br />            0b0110, 0b0011, 0b1110, 0b0111, 0b1111 ].each <span class="keyword">do</span> |bits|<br />            move = bits &lt;&lt; 4 * row<br />            moves &lt;&lt; move &lt;&lt; transpose(move)<br />          <span class="keyword">end</span><br />          moves<br />        <span class="keyword">end</span>.uniq<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Return the transposed board (horizontal to vertical, or vice-versa)</span><br />      <span class="keyword">def</span> <span class="keyword">self</span>.transpose(board)<br />        (0..15).inject(0) { |xboard, i|<br />            q,r = i.divmod(4); xboard |= board[i] &lt;&lt; q + r*4<br />        }<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I'm not going to insult everyone's intelligence by breaking down well commented code, but I do want to point out a few things.  Note toward the top that FULL is set to 0xFFFF.  0xFFFF is just another way to say 0b1111_1111_1111_1111, which I mentioned earlier.  Then on the second line of play(), you can see moves being made with |.  prune_possible_moves() uses &amp; and the check for zero to see what's possible at a given position.</p>
			<p>The other point of interest is all_possible_moves().  This method builds up a list of all the moves that can be made, from the moves that can be made over a single row.  That row of moves is bit shifted to cover the other rows and, with help from transpose(), rotated to cover the columns too.  That's scary cool, isn't it?</p>
			<p>Bob's actual solution, using the above library:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'tactics'</span><br /><br />    puts <span class="string">%(#{ Tactics.new.play == Tactics::WIN ? "First" :<br />                                                 "Second" } player wins.)</span><br /><br /></div></div>
			<p>I'm assuming that speaks for itself.  I'm not done showing off Bob yet though.  Have a look at this beautiful set of unit tests:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'test/unit'</span><br />    require <span class="string">'tactics.rb'</span><br /><br />    <span class="keyword">class</span> TestTactics &lt; Test::Unit::TestCase<br />      <span class="comment"># Test the play engine by trying various board positions that we</span><br />      <span class="comment"># know are winning or losing positions. Each of these is justified</span><br />      <span class="comment"># (no point in using ones that are just hunches on our part--'cause</span><br />      <span class="comment"># then what would we be verifying?).</span><br />      <span class="keyword">def</span> test_play<br />        <span class="comment"># Each position description is the position you're faced with</span><br />        <span class="comment"># just before playing. So "1 square loses" means that if it's</span><br />        <span class="comment"># your turn to play, and there's only one square available,</span><br />        <span class="comment"># you lose.</span><br /><br />        <span class="comment"># 1 square loses (obviously)</span><br />        assert_equal(Tactics::LOSS, Tactics.new(0b0111_1111_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1011_1111_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1101_1111_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1110_1111_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_0111_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1011_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1101_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1110_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_0111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1011_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1101_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1110_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1111_0111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1111_1011).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1111_1101).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1111_1110).play)<br /><br />        <span class="comment"># 2 squares in a row wins (because you can reduce to one square) </span><br />        assert_equal(Tactics::WIN, Tactics.new(0b0011_1111_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1001_1111_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1100_1111_1111_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0011_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1001_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1100_1111_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_0011_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1001_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1100_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1111_0011).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1111_1001).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1111_1100).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b0111_0111_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0111_0111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_0111_0111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1011_1011_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1011_1011_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1011_1011).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1101_1101_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1101_1101_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1101_1101).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1110_1110_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1110_1110_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1110_1110).play)<br /><br />        <span class="comment"># 3 squares in a row wins (because you can reduce to one square)</span><br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b0001_1111_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1000_1111_1111_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0001_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1000_1111_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_0001_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1000_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1111_0001).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1111_1000).play)<br /><br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b0111_0111_0111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0111_0111_0111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1011_1011_1011_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1011_1011_1011).play)<br /><br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1101_1101_1101_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1101_1101_1101).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1110_1110_1110_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1110_1110_1110).play)<br /><br />        <span class="comment"># 4 squares in a row wins (because you can reduce to one square)</span><br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b0000_1111_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0000_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_0000_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1111_0000).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b0111_0111_0111_0111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1011_1011_1011_1011).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1101_1101_1101_1101).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1110_1110_1110_1110).play)<br /><br />        <span class="comment"># 2x2 square loses (because your opponent can always reduce it to one</span><br />        <span class="comment"># square immediately after your move)</span><br />        assert_equal(Tactics::LOSS, Tactics.new(0b0011_0011_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_0011_0011_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_0011_0011).play)<br /><br />        assert_equal(Tactics::LOSS, Tactics.new(0b1001_1001_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1001_1001_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1001_1001).play)<br /><br />        assert_equal(Tactics::LOSS, Tactics.new(0b1100_1100_1111_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1100_1100_1111).play)<br />        assert_equal(Tactics::LOSS, Tactics.new(0b1111_1111_1100_1100).play)<br /><br />        <span class="comment"># 2x3 (or 3x2) rectangle wins (because you can reduce it to a 2x2)</span><br />        assert_equal(Tactics::WIN, Tactics.new(0b0011_0011_0011_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1001_1001_1001_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1100_1100_1100_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0011_0011_0011).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1001_1001_1001).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1100_1100_1100).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b0001_0001_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1000_1000_1111_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0001_0001_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1000_1000_1111).play)<br /><br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_0001_0001).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1111_1000_1000).play)<br /><br />        <span class="comment"># Now we'll play from an empty board. The purpose of this assertion</span><br />        <span class="comment"># is just to verify that we get the same answer that we get when</span><br />        <span class="comment"># the engine is started from scratch. In this case, we have done all</span><br />        <span class="comment"># the preceding plays--the results of which are stored in the engine.</span><br />        assert_equal(Tactics::LOSS, Tactics.new(0b0000_0000_0000_0000).play)<br /><br />        <span class="comment"># Also check that it works the same with the defaulted empty board.</span><br />        assert_equal(Tactics::LOSS, Tactics.new.play)<br /><br />        <span class="comment"># Continue with a few random assertions. No attempt to be exhaustive</span><br />        <span class="comment"># this time. This is deliberately located below the full play, above,</span><br />        <span class="comment"># to see that intermediate board positions that have been stored</span><br />        <span class="comment"># are accurate. Of course, this doesn't test very many of them.</span><br /><br />        <span class="comment"># A 2x2 L shape. Trivially reducible to 1 square.</span><br />        assert_equal(Tactics::WIN, Tactics.new(0b0011_0111_1111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1011_1001_1111).play)<br /><br />        <span class="comment"># A 2x3 L shape. Trivially reducible to 1 square.</span><br />        assert_equal(Tactics::WIN, Tactics.new(0b0011_0111_0111_1111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_1011_1000_1111).play)<br /><br />        <span class="comment"># A 2x4 L shape. Trivially reducible to 1 square.</span><br />        assert_equal(Tactics::WIN, Tactics.new(0b0011_0111_0111_0111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1111_0111_0000_1111).play)<br /><br />        <span class="comment"># A 3x4 L shape. Reducible to two lengths of two.</span><br />        assert_equal(Tactics::WIN, Tactics.new(0b0001_0111_0111_0111).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b0000_0111_0111_1111).play)<br /><br />        <span class="comment"># A checkerboard. Wins as long as the number of open squares is even.</span><br />        assert_equal(Tactics::WIN, Tactics.new(0b0101_1010_0101_1010).play)<br />        assert_equal(Tactics::WIN, Tactics.new(0b1010_0101_1010_0101).play)<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That's a flawless combination of code and comment logic, if you ask me.  Very nice.</p>
			<p>My thanks to Bob Sidebotham for sending in a thought provoking quiz and then showing us how it's done.  Thanks for the free lessons, Bob.</p>
			<p>Tomorrow's quiz is a choose your own difficulty problem so I expect to see all of you submitting solutions!  :)</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/129926">Sea&amp;Gull</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/130160">Bob Sidebotham</a></li>
			</ol>
			<p><a href="quiz18_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
