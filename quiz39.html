<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Sampling (#39)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Sampling (#39)</span>
			<p>This week's Ruby quiz is a classic sampling problem that I've seen many interesting solutions for in the past.</p>
			<p>The challenge is to implement a program called "sample" that takes exactly two integer inputs.  The first of those should be the number of members chosen at random you would like included in the sample.  The second is the upper boundary (exclusive) of the range of integers members can be selected from.  The lower boundary is zero (inclusive).</p>
			<p>Your program should output exactly the requested number of members from the defined range to STDOUT, one number per line.  Each member must be unique and they should appear in sorted order.</p>
			<p>Here are some sample runs of my solution to illustrate the task:</p>
			<p class="example">$ ./sample <br />Usage:  sample MEMBERS LIMIT<br /><br />MEMBERS:  The number of members you want in the sample.  (Integer)<br />  LIMIT:  The upper limit for the sample range.  All     (Integer)<br />          members will between 0 and LIMIT - 1.<br /><br />Note that MEMBERS must be less than LIMIT.<br />$ ./sample 3 10<br />0<br />1<br />5<br />$ ./sample 3 10<br />1<br />2<br />8<br />$ ./sample 3 10<br />2<br />3<br />9<br />$ ./sample 9 10<br />0<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />$ ./sample 20 400<br />1<br />3<br />4<br />25<br />32<br />36<br />42<br />56<br />93<br />111<br />137<br />139<br />153<br />213<br />222<br />226<br />263<br />289<br />293<br />314</p>
			<p>Now for all the algorithm junkies out there that enjoy a little friendly competition, here's the time to beat:</p>
			<p class="example">$ time ./sample 5_000_000 1_000_000_000 &gt; big_sample.txt<br /><br />real    30m10.593s<br />user    29m54.544s<br />sys     0m4.736s<br />$ ls -l big_sample.txt <br />-rw-r--r--   1 james  staff  49011436 Jul 11 15:26 big_sample.txt<br />$ head big_sample.txt <br />112<br />221<br />450<br />655<br />900<br />1216<br />1399<br />1469<br />1494<br />1628<br />$ tail big_sample.txt <br />999995325<br />999996330<br />999996552<br />999996682<br />999997426<br />999997676<br />999998253<br />999999153<br />999999658<br />999999693</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>To me, the solutions to this week's quiz are a fascinating combination of the various degrees of correct, dangerous, and fast.  Let's examine a few different solutions and I'll try to show you why I think that.</p>
			<p>The fast characteristic seemed to be in abundant supply.  Ezra Zygmuntowicz started scaring people with time readouts before solutions were even posted.  Let's start with that code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby</span><br />    members, limit, index = ARGV[0].to_i, ARGV[1].to_i, 0<br />    member_range = limit / members<br />    0.upto(members-1) <span class="keyword">do</span><br />      res = rand member_range<br />      puts res + index<br />      index += member_range<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>How does this work?</p>
			<p>We can see that it reads in the two settings and initializes an index to zero.  Next if calculates a member_range by dividing limit by members.  That line is when this code started to smell fishy to me.</p>
			<p>The upto() iterator does all the work.  It generates a random number in the member_range, adds that to the index and spits it out, then bumps index by member_range.  This happens members times.</p>
			<p>I think it's important to think about how this works.  Let's assume we want two members with a limit of ten.  That's going to give us a member_range of five.  So we'll chose a random number between zero and four, add zero to it (index), and spit that out.  Then bump index by five and repeat.  Put another way, we'll choose a random member of the first half of the range and then a random member from the second half of the range.  We may get one and nine or even four and five, but we'll never see seven and eight since they're both in the same half of the range.</p>
			<p>That's a lightning quick solution.  It solves the quiz example in 26 seconds on my box.  However, the real question is, is it correct?  Obviously, that's subjective.  My opinion is that I can find combinations of the range that it will not choose and I don't consider that to be meeting the requirement of randomly selecting members from the (amended) quiz.  Many of us are probably familiar with the famous quote:</p>
			<p class="example">"Anyone who considers arithmetical methods of producing random digits is,<br />of course, in a state of sin." --Von Neumann</p>
			<p>I think that's probably more applicable to the above code than it is to random number generation in general.</p>
			<p>Let's look at another solution.  This one is from Dominik Bathon:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby</span><br /><br />    <span class="keyword">if</span> <span class="global">$DEBUG</span><br />        <span class="keyword">def</span> ptime(evt)<br />            <span class="global">$ptimeg</span> ||= Time.now.to_f<br />            STDERR.puts <span class="string">"#{evt} at #{Time.now.to_f - $ptimeg}"</span><br />        <span class="keyword">end</span><br />    <span class="keyword">else</span><br />        <span class="keyword">def</span> ptime(evt)<br />            <span class="comment"># noop</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># the actuall sampling, just store the seen values in a hash and return the</span><br />    <span class="comment"># sorted hash keys</span><br />    <span class="keyword">def</span> sample(cnt, lim)<br />        x = {}<br />        tmp = <span class="keyword">nil</span><br /><br />        <span class="keyword">for</span> i <span class="keyword">in</span> 0...cnt<br />            <span class="keyword">while</span> x.has_key?(tmp = rand(lim))<br />            <span class="keyword">end</span><br />            x[tmp] = <span class="keyword">true</span><br />        <span class="keyword">end</span><br />        ptime <span class="string">"rand"</span><br /><br />        x = x.keys.sort<br />        ptime <span class="string">"sort"</span><br />        x<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># this is the key to success, but needs lots of ram</span><br />    GC.disable<br /><br />    ptime <span class="string">"start"</span><br /><br />    x = sample(cnt=ARGV[0].to_i, ARGV[1].to_i)<br /><br />    <span class="comment"># creating the newline string only once saves 5s</span><br />    nl = <span class="string">"\n"</span><br />    i = 0<br />    <span class="keyword">while</span> i+10 &lt;= cnt<br />        <span class="comment"># this is saves about 1s</span><br />        print x[i], nl, x[i+1], nl, x[i+2], nl, x[i+3], nl, x[i+4],<br />        nl, x[i+5], nl, x[i+6], nl, x[i+7], nl, x[i+8], nl, x[i+9], nl<br />        i += 10<br />    <span class="keyword">end</span><br />    <span class="keyword">for</span> j <span class="keyword">in</span> i...cnt<br />        print x[j], nl<br />    <span class="keyword">end</span><br />    ptime <span class="string">"print"</span><br /><br /></div></div>
			<p>I don't want to focus too much on the details here.  The first chunk of code just defines a timing helper method and the last chunk it some heavily optimized printing.  The actual solution is the sample() method in the middle.  The comment before the method tells you exactly how it works, so I'm not going to insult your intelligence by repeating it.  This is a great time to bring up an interesting question that came up on Ruby Talk though:</p>
			<p class="example">"How would someone not being aware of the advantages a Hash-lookup gives<br />(compared to Array-lookup) choose to implement the problem with a Hash?<br />It is not obvious for inexperienced programmers." --Stefan Mahlitz</p>
			<p>I think the keyword in what we're trying to find here is "unique".  Whenever I think unique, I start thinking about a Hash.  The keys of a Hash are unique, by definition.  In order to find out if something is unique in an Array, you've got to walk it.  In order to find out if something if something exists in a Hash, you just need to check for that one key.  That's slower than a single Array lookup, but much faster than five million Array lookups.  Get into the habit of making that quick mental translation:  Unique (almost always) means Hash.</p>
			<p>Back to Dominik's code.</p>
			<p>Again, this code is fast.  It solves the quiz example in 40 seconds for me.  My main concern is what Dominik reported in the submission message:</p>
			<p class="example">"But the "real solution" is GC.disable. That has a downside of course. The  <br />above run of sample.rb needs approx. 400MB of RAM. So, don't try this at  <br />home if you have less than 512MB ;-)" --Dominik Bathon</p>
			<p>I'm probably a little old school, but that warning scares me.  What if we add a zero to both numbers in the quiz example?  If I looked into some code and saw that it was using a lot of memory, I don't think I would try untying the memory safety net with GC.disable().  Clearly this solution works and is very fast for certain samples on certain hardware, but I think it needs some caution tape warning users and apparently Dominik does too.</p>
			<p>If you like the Hash idea, here's the cleanest version I saw from Jim Menard with a slight syntax change suggested by Daniel Brockman:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby</span><br /><br />    require <span class="string">'set'</span><br /><br />    <span class="keyword">def</span> sample(members, range)<br />      selected = Set.new<br />      members.times {<br />        <span class="keyword">begin</span><br />          val = rand(range)<br />        <span class="keyword">end</span> <span class="keyword">until</span> selected.add?(val)<br />      }<br />      selected.to_a.sort<br />    <span class="keyword">end</span><br /><br />    puts sample(ARGV[0].to_i, ARGV[1].to_i).join(<span class="string">"\n"</span>)<br /><br /></div></div>
			<p>This solution uses the Ruby set library.  (Sets are implemented using Hashes, because of the aforementioned unique behavior.)  This version just adds a random choice to the selected set, member times.  The add?() method ensures that it was a new member for the set, causing the code to loop until it returns true.  The results are then converted to an Array, sorted, and printed.</p>
			<p>This solution took two minutes and ten seconds with the quiz example on my box.  It still allocates a good sized chunk of memory, but significantly less than Dominik's code (around 150 MB).</p>
			<p>The other issue with these kinds of solutions is collisions.  In the quiz example the members requested are much less than the limit.  However, as those two numbers get closer together, random selections will be repeats a lot more often.  That can reverse the nice runtimes of these solutions.  Here's a simple script to demonstrate collisions:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby -w</span><br /><br />    members, limit = ARGV.map { |n| Integer(n) }<br /><br />    choices    = Hash.new<br />    collisions = 0<br /><br />    <span class="keyword">until</span> choices.size == members<br />        choice = rand(limit)<br />        <span class="keyword">if</span> choices.include? choice<br />            collisions += 1<br />        <span class="keyword">else</span><br />            choices[rand(limit)] = <span class="keyword">true</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    warn <span class="string">"#{collisions} collisions"</span><br /><br /></div></div>
			<p>Now watch a few runs of that script</p>
			<p class="example">$ ruby collisions.rb 2 10<br />0 collisions<br />$ ruby collisions.rb 2 10<br />1 collisions<br />$ ruby collisions.rb 2 10<br />0 collisions<br />$ ruby collisions.rb 2 10<br />0 collisions<br />$ ruby collisions.rb 9 10<br />25 collisions<br />$ ruby collisions.rb 9 10<br />21 collisions<br />$ ruby collisions.rb 9 10<br />50 collisions<br />$ ruby collisions.rb 9_999 10_000<br />39205236 collisions<br />$ time ruby collisions.rb 9_999 10_000<br />35249691 collisions<br /><br />real    1m13.996s<br />user    1m13.876s<br />sys     0m0.084s</p>
			<p>As you can see the number of collisions can climb very fast and the runtime is quickly dropping off.  Joost Diepenmaat suggested that it might be a good idea to switch algorithms when members &gt; limit / 2.  Joost's idea was simply to reverse the above algorithm, looking for what not to include, but here's a different option from Matthew D Moss:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby</span><br /><br />    (k, n) = ARGV.map { |s| s.to_i }<br />    n.times <span class="keyword">do</span> |i|<br />       r = rand * (n - i)<br />       <span class="keyword">unless</span> (k &lt; r)<br />          puts i<br />          k -= 1<br />       <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This solution does not use memory to store the numbers or even need to call sort() at any point.  It works by walking the entire range and randomly selecting which numbers to include.  You can see that it selects a random number in what's left of the range on each iteration.  When the number of members needed is less than that choice, the code just moves on to the next number.  However, when members is equal to that choice, the number is selected (printed) and the remaining members count is dropped.  The behavior ensure that we get enough numbers, with each number having an equal chance at selection.</p>
			<p>The minus with this one is speed.  Walking all those numbers takes time.  This algorithm is very similar to my own, used to make the quiz.  You saw how high that runtime got.  However, the code's not gobbling up memory and it is going to find a proper sample, eventually.</p>
			<p>That concludes our tour of the solutions.  As you can see, there are many trade-offs to be made over this problem.  If you want super speed and can spare the memory, a Hash based solution is a good answer.  Otherwise, something like Matthew's solution is probably the best choice.  It's fast enough on smaller inputs, it doesn't keep eating memory, and it gives a good random sample.</p>
			<p>Many, many thanks to all who decided to jump in on this problem.  The solutions and discussion were all vary insightful.</p>
			<p>Tomorrow we will find out if heaps grow on trees...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148464">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148485">Joost Diepenmaat</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148486">Reto Schuettel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148495">Bill Kelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148499">Stefan Mahlitz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148507">Matthew D Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148508">Ezra Zygmuntowicz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148509">Adam Sanderson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148575">Jim Menard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148605">Wybo Dekker</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148613">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148648">Paolo Capriotti</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148682">hp gobelli</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148819">Stefan Mahlitz (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/150276">Simon Kroeger</a></li>
			</ol>
			<p><a href="quiz39_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
