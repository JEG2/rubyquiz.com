<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Dungeon Generation (#80)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Dungeon Generation (#80)</span>
			<p>by Kev Jackson</p>
			<p>This week's task is a dark and dangerous one.  Since the late 1970's, a particular type of game has appealed to a particular type of person.  Games?  From the 70's?  Yep, there can only be one type of (computer) game with that lineage that's still going strong (ish) after all these years - the Rogue-like game!</p>
			<p>For those not in the know, a typical Rogue-like game uses ascii characters (and sometimes extra/non-ascii characters) to represent the (Tolkienish) game world.  The object of each of the games is subtly different, some require you to retrieve the Amulet of Yendor, some require you to kill the Serpent of Chaos.  In common, they all require you to descend into a (randomly generated) dungeon.</p>
			<p>Here's the task for this week.  To write a dungeon creation program that will generate and display a typical Rogue-like dungeon</p>
			<p>A sample of which could look something like:</p>
			<p class="example">depth 50ft (lvl 1) (pretty much the most trivial dungeon possible)<br />stairs back to surface ( &lt; ) and stairs down to 100 ft/lvl 2 ( &gt; )<br /><br />##########<br />#   &lt;   &gt;#<br />##########<br /><br />depth 100ft (lvl2)<br />stairs back up to 50ft and stairs down to 150 ft<br /><br />             ###<br />########     #&gt;#<br />#      #     # #<br />#####  ##    # #<br />   # &lt;####### #<br />   #          #<br />   ##+#+#######<br /><br />depth 150ft (lvl3) (example of an 'arena' style level, includes a  <br />                    'vault' style room)<br />stairs back up to 100 ft and down to 200ft<br /><br />#################################<br />#                               #<br />#                               #<br />#   #####         #######       #<br />#   #   +         # # #&gt;#       #<br />#########         ## # ##       #<br />#       #         # # # #       #<br />#       #         ###+###       #<br />#       #                       #<br /># &lt;     +                       #<br />#################################</p>
			<p>Each ascii character represents terrain, an object (dungeon furniture) or a monster.</p>
			<p>Each dungeon must have an &lt; (up stairs) and one &gt; (down stairs) and they must be connected in some way (ie the player must be able to move from the &lt; (start) to the &gt; (down to the next level). The simplest dungeon is simply a single room with both an up stairs and a down stairs.</p>
			<p class="example">~ = liquid (water =&gt; blue, lava =&gt; red, acid =&gt; green)<br /># = wall<br />+ = door<br />&lt; = up stairs (back to the town)<br />&gt; = down stairs (deeper into the dungeon)</p>
			<p>To actually create an entire game would take far far too long (some of these games have been in development for years), but feel free to add as much or as little of the Rogue-like attributes as you feel like, for instance:</p>
			<p class="example">% = vegetation<br />[a-zA-Z0-9] = monsters (ie =&gt; o = Orc, U = Demon, d = little dragon,  <br />                        D = Greater Hell Wyrm)<br />@ = player<br />, = slime mold (yummy)<br />^ = trap<br />* = gold (found in walls, ie ##*##)</p>
			<p>For those that can parse C source, the source files from Zangband (my personal favourite Rogue-like) are freely available (you have to extract them from a tar.gz bundle):</p>
			<p><a href="http://www.zangband.org">Zangband</a></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>This is a fun problem, probably hindered by the holiday weekend.  Luckily, we did get a great solution from Benjohn Barnes.  (We got another great one from Elliot Temple after I wrote this.  Sorry Elliot!)  Let's dig into how that works.</p>
			<p>First, it's good to see what we are building.  When you execute Benjohn's program you get one level of a dungeon.  Here's a small section of one of the levels it generated:</p>
			<p class="example">###########               ######## ##################################<br />###########               ######## ##################################<br />###################### ########### ##################################<br />###################### ########### ##################################<br />###################### #####            #############################<br />###################### #####            #############################<br />##############     ### #####            #############################<br />##########     ### ##                   #############################<br />##########     ### ##                   #############################<br />##########                              #############################<br />##########     ######                       #########################<br />##########     #####                        #########################<br />##########     #####                        #########################<br />##########     #####                        #########################<br />##########     #####                        #########################<br />##########     #####                        #########################<br />##########     #####                          #######################<br />##########     ##                       #####       #################<br />##########     #  ##                    ########### #################<br />##########     # ###      &gt;            ############ #################<br />##########     # ###                   ############ #################<br />##########       #####                 ############ #################<br />########### ##  ######                 ############ #################<br />########### #  #                       ############ #################<br />########### # ##               #################### #################<br />###########   ##               #################### #################<br />#####                          ################     #################<br />#####                          ################     #################<br />#####                          ################     #################<br />#####                          ################     #################<br />#####                          ################     #################<br />###############                ################     #################<br />###############    #### # #####################    ##################<br />################## #### #  ####################    ##################<br />################## #### ##      ###############    ##################<br />################## #### #######  #############     ##################<br />################## ####   ######        ######     ##################<br />################## ###### #######       ######     ##################</p>
			<p>I love the "catacombey" feel of this.  Let's see how it comes together.  Here's the main executable:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'walker.rb'</span><br />    require <span class="string">'arena.rb'</span><br /><br />    <span class="keyword">def</span> create_dungeon( arena, walk_length, have_stairs = <span class="keyword">true</span>,<br />                                            walker = Walker.new )<br />      <span class="keyword">while</span>(walk_length&gt;0)<br />        walk_length -=1<br /><br />        <span class="comment"># Cut out a bit of tunnel where I am.</span><br />        arena[*walker.position] = <span class="string">' '</span><br />        walker.wander<br /><br />        <span class="comment"># Bosh down a room occasionally.</span><br />        <span class="keyword">if</span>(walk_length%80==0)<br />          create_room(arena, walker)<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Spawn off a child now and then. Split the remaining walk_length</span><br />        <span class="comment"># with it. Only one of us gets the stairs though.</span><br />        <span class="keyword">if</span>(walk_length%40==0)<br />          child_walk_length = rand(walk_length)<br />          walk_length -= child_walk_length<br />          <span class="keyword">if</span> child_walk_length &gt; walk_length<br />            create_dungeon( arena, child_walk_length, have_stairs,<br />                                                      walker.create_child )<br />            have_stairs = <span class="keyword">false</span><br />          <span class="keyword">else</span><br />            create_dungeon( arena, child_walk_length, <span class="keyword">false</span>,<br />                                                      walker.create_child )<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Put in the down stairs, if I have them.</span><br />      <span class="keyword">if</span>(have_stairs)<br />        arena[*(walker.position)] = <span class="string">'&gt;'</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> create_room(arena, walker)<br />      max = 10<br />      width = -rand(max)..rand(max)<br />      height = -rand(max)..rand(max)<br />      height.each <span class="keyword">do</span> |y|<br />        width.each <span class="keyword">do</span> |x|<br />          arena[x+walker.x, y+walker.y] = <span class="string">' '</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># Create an arena, and set of a walker in it.</span><br />    arena = Arena.new<br />    create_dungeon(arena, 400)<br /><br />    <span class="comment"># Put in the up stairs.</span><br />    arena[0,0] = <span class="string">'&lt;'</span><br /><br />    <span class="comment"># Show the dungeon.</span><br />    puts arena<br /><br /></div></div>
			<p>The application code at the end is trivial enough, except, of course, that we don't yet know what an Arena or a Walker are.  We can see the primary work method that gets triggered here though and thus we know where to look next.</p>
			<p>The create_dungeon() method is where all the action is.  The parameters it takes are an Arena, a walk length and Walker, and a boolean involving stairs.  We saw the Arena get printed in the application code, so it's probably safe to assume it is the canvas we intend to paint a dungeon onto at this point.</p>
			<p>Ignoring the stair parameter for now, it's clear we need to know more about this Walker and what it does.  If you browse through this method reading the comments and noticing calls like walker.position and walker.wander, you should get the idea pretty quickly.</p>
			<p>Benjohn just turns a digital spelunker loose in the dungeon and carves out tunnels where ever it walks.  Every so often, the code even carves out a room right around where our explorer is standing.  That's what create_room() does.  Because these rooms can overlap, the end result doesn't end up being all rectangles, which gives us the nice dungeon feel we saw earlier.</p>
			<p>You can also see that the Walker sometimes splits and goes forward in two directions (via recursion).  This is what the stairs parameter is for.  Only one Walker is allowed to have them and the one that does will drop them just before the method exits.</p>
			<p>Now that we have an idea of the process, we need to see the other pieces.  Here's the Arena object:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Arena<br />      attr_reader :left, :right, :top, :bottom<br />      <span class="keyword">def</span> initialize<br />        <span class="variable">@arena</span> = Hash.new {|h,k| h[k]=Hash.new(<span class="string">'#'</span>)}<br />        <span class="variable">@left</span> = <span class="variable">@right</span> = <span class="variable">@top</span> = <span class="variable">@bottom</span> = 0<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> [](x,y)<br />        <span class="variable">@arena</span>[y][x]<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> []=(x,y,v)<br />        <span class="comment"># I originally worked out the width and height at the end by scanning</span><br />        <span class="comment"># the map. I was also using a single map, rather than the 'map in a</span><br />        <span class="comment"># map' now used. I found that dungeon creation  was slow, but almost</span><br />        <span class="comment"># all of it was the final rendering stage, so switched over to the </span><br />        <span class="comment"># current approach.</span><br />        <span class="variable">@arena</span>[y][x]=v<br />        <span class="variable">@left</span> = [<span class="variable">@left</span>, x].min<br />        <span class="variable">@right</span> = [<span class="variable">@right</span>, x].max<br />        <span class="variable">@top</span> = [<span class="variable">@top</span>, y].min<br />        <span class="variable">@bottom</span> = [<span class="variable">@bottom</span>, y].max<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_s<br />        to_array.collect {|row| row.join}.join(<span class="string">"\n"</span>)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_array<br />        (top-1..bottom+1).collect <span class="keyword">do</span> |y|<br />          (left-1..right+1).collect <span class="keyword">do</span> |x|<br />            <span class="keyword">self</span>[x,y]<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This is just what we expected.  A Hash of Hashes (indexed by x and y coordinates) is used to hold the final rendering.  A Hash is used here, instead of an Array, so the Walker can literally wander() anywhere he chooses, expanding the world as he goes.  The code tracks the boundaries of the map as the Walker moves and sets new areas and those boundaries are used to print the end result.  Anything not set by the dungeon creation code is a wall.</p>
			<p>One more piece left.  Time to examine the Walker:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># This class basically implements a random walk. I remember</span><br />    <span class="comment"># my direction, and it's this that I randomly adjust, rather</span><br />    <span class="comment"># than simply jittering my position.</span><br />    <span class="keyword">class</span> Walker<br />      attr_accessor :x, :y, :direction<br /><br />      <span class="keyword">def</span> initialize(x=0, y=0, direction=0)<br />        <span class="variable">@x</span>, <span class="variable">@y</span>, <span class="variable">@direction</span> = x, y, direction<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Handy for testing.</span><br />      <span class="keyword">def</span> position<br />        [x,y]<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Adjust direction, and walk once.</span><br />      <span class="keyword">def</span> wander<br />        perturb_direction<br />        walk<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Make the child pointing of 90 degrees away from me.</span><br />      <span class="keyword">def</span> create_child<br />        Walker.new(x, y, direction + 2*rand(2) - 1)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> perturb_direction<br />        <span class="variable">@direction</span> += rand*wiggle_max - (wiggle_max/2)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> walk(d = direction_with_smoothing_fuzz)<br />        <span class="comment"># Ensure that the direction is correctly wrapped around.</span><br />        d = (d.round)%4<br />        <span class="variable">@x</span> += [1,0,-1,0][d]<br />        <span class="variable">@y</span> += [0,1,0,-1][d]<br />        <span class="keyword">self</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Adding some noise on to the direction "stocastically" samples</span><br />      <span class="comment"># it, smoothing off turns, and making it more catacombey.</span><br />      <span class="keyword">def</span> direction_with_smoothing_fuzz<br />        <span class="variable">@direction</span> + rand*smoothing - smoothing/2<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># How wiggley are the dungeons? Bigger numbers are more wiggly</span><br />      <span class="comment"># and compact.</span><br />      <span class="keyword">def</span> wiggle_max<br />        0.5<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># How smooth are tunnels? Larger numbers give smoother more</span><br />      <span class="comment"># 'catacombe' like tunnels (and smaller dungeons). Smaller</span><br />      <span class="comment"># numbers give more cartesian &amp; straight tunnels.</span><br />      <span class="keyword">def</span> smoothing<br />        0.9<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Though that looks long, they are all very trivial methods and the comments are plenty and good.  The short story is in the comment right at the beginning.  I can't explain it any better than that.</p>
			<p>Do look at the methods at the end of the Walker.  You can get a feel from the comments here how this code was tuned into its current form as Benjohn tested it.  Speaking of tests, did I mention the solution included test cases for Arena and Walker?  I won't show them here since this is already lengthy, but they are good stuff and I recommend looking them over.</p>
			<p>My thanks to Benjohn and Elliot for finding the time when the rest of us were too busy.</p>
			<p>Tomorrow we have a trivial challenge, but one we've probably all thought about...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/195014">Benjohn Barnes</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/195385">Elliot Temple</a></li>
			</ol>
			<p><a href="quiz80_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
