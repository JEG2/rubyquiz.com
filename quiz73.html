<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Testing DiGraph (#73)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Testing DiGraph (#73)</span>
			<p>by Robert Feldt</p>
			<p>In this week's Ruby Quiz you will not only have fun and (hopefully) learn something; you will also contribute to a research project evaluating automated testing techniques. So please read on and then take the quiz!</p>
			<p>The goal of this quiz is to write a good and extensive test suite for a Ruby DiGraph (directed graph) class. The new (hotshot, and annoying ;)) quality manager at your work has challenged all the developers. He is planning major cutbacks since he claims that automated testing tools can do as good or better a job! The focus of the testing is on the following two methods of the DiGraph class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Return the length of the longest simple path (an arc/edge can only</span><br />    <span class="comment"># occur once in the path) that includes &lt;node&gt;.</span><br />    DiGraph<span class="comment">#max_length_of_simple_path_including_node(node)</span><br /><br />    <span class="comment"># Returns the strongly connected component (itself a DirectedGraph) </span><br />    <span class="comment"># that includes &lt;node&gt;.</span><br />    DiGraph<span class="comment">#strongly_connected_component_including_node(node)</span><br /><br /></div></div>
			<p>Any Ruby object can be a node in a graph and you create graphs by giving a number of edges. Each edge is an Array with maximum two nodes where the first node is the source node.</p>
			<p>The quiz has two phases: first a black-box phase and then a white-box phase. In the black-box phase you do not have access to the source code but do your testing over the network via drb. When you are satisfied with your tests for this phase you submit them, get the source code and start the white-box phase. Now you can extend your test suite given the actual code, fix problems and even refactor the code as you see fit (as long as you do not change the interface).</p>
			<p>You need to download the file "rubyquiz73.rb" to participate in the distributed testing:</p>
			<p><a href="http://rubyquiz.com/rubyquiz73.rb">rubyquiz73.rb</a></p>
			<p>After downloading and saving that file, here is how you get a reference to the class under test (CUT):</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'test/unit'</span><br />    require <span class="string">'rubyquiz73'</span><br /><br />    <span class="comment"># You must insert your email address as &lt;youremail&gt; in this method call!</span><br />    DiGraph = RubyQuiz73.class_under_test(<span class="string">"&lt;youremail&gt;"</span>)<br /><br />    <span class="keyword">class</span> TestDiGraph &lt; Test::Unit::TestCase<br />      <span class="keyword">def</span> test_01_digraph_creation<br />        dg1 = DiGraph.new<br />        assert_kind_of(DiGraph, dg1)<br />        assert_equal(0, dg1.size)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> test_02_size<br />        dg2 = DiGraph.new([1,2], [2,3])<br />        assert_equal(3, dg2.size)<br />        assert_equal(2, dg2.num_edges)<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Add/write your own tests here...</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Note that since we use drb for the distributed testing and we had to make some performance trade-offs not every assertion or code might work exactly as it would if run locally. However, most "normal" things will work.</p>
			<p>When you consider yourself ready with the blackbox phase of the testing you should submit your test suite. You do this by issuing the command:</p>
			<p class="example">ruby rubyquiz73.rb submit1 &lt;test_filename.rb&gt;</p>
			<p>and giving the path to your test file. The script will get back the source code for the class being tested and save it. You can now look at the source code and add tests as you see fit. You can also alter and refactor the source code as long as you do not change the interface. When you are done with this, whitebox phase, you submit your test file and source file like so (you can add additional files if you have split your tests over several files):</p>
			<p class="example">ruby rubyquiz73.rb submit2 &lt;test_filename.rb&gt; &lt;src_filename.rb&gt;</p>
			<p>[Editor's Note:  Please also send in your tests to Ruby Talk, after the spoiler period, for use in the summary.  --JEG2]</p>
			<p>You can also get some help information by issuing:</p>
			<p class="example">ruby rubyquiz73.rb help</p>
			<p>You are encouraged to briefly document (in comments or by other means) how and why you arrived at and included the test cases you've chosen and why you think your tests are thorough. You are also encouraged to add tests for additional methods of the DiGraph class as you see fit. Note that the devious Quality Manager has not eliminated all problems with the given code so you are expected to find problems/faults!</p>
			<p>If the specifications in the RDoc comments above are not complete enough then please make additional, sound assumptions and make them clear in your tests / documentation.</p>
			<p><a href="http://www.cs.odu.edu/~toida/nerzic/content/digraph/definition.html">Digraph Definition</a></p>
			<p><a href="http://www.nist.gov/dads/HTML/stronglyConnectedCompo.html">strongly connected component</a></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>The first step to solving this quiz is to come up with some graphs that you can test.  I started by thinking of some trivial patterns I could easily hand figure the answers for.  A good example is the graph:</p>
			<p class="example">A -&gt; B -&gt; C -&gt; D</p>
			<p>Finding the longest simple path for that is not hard, it is always all of the edges.  That's just a straight line basically and it will include all the nodes.  Building these kinds of graphs programatically for any size is also easy:</p>
			<p class="example">&gt;&gt; Array.new(3) { |i| [(?A + i).chr, (?A + i + 1).chr] }<br />=&gt; [["A", "B"], ["B", "C"], ["C", "D"]]</p>
			<p>Himadri ChoudHury took a different approach, generating completely random graphs.  This has the advantage of testing far more cases including isolated nodes and circular paths.  Here's the generation code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># @dg is the generated DiGraph. Store the paths in a hash called @paths</span><br />    <span class="variable">@dg</span><br />    <span class="comment"># @paths is a hash. Each element of the hash is an array that contains</span><br />    <span class="comment"># all the paths from that node</span><br />    <span class="variable">@paths</span><br />    <span class="comment"># @nodes is an array which contains a list of all the nodes</span><br />    <span class="variable">@nodes</span><br /><br />    <span class="comment"># Randomly generate @dg and the corresponding @paths</span><br />    <span class="keyword">def</span> generate_dg<br />        nodes = Array.new<br />        <span class="comment"># 10 nodes total</span><br />        10.times <span class="keyword">do</span><br />            nodes &lt;&lt; rand(10)<br />        <span class="keyword">end</span><br />        nodes.uniq!<br />        <span class="variable">@paths</span> = Hash.new<br />        nodes.each <span class="keyword">do</span> |n|<br />            num_paths_from_each_node = rand(3) + 1<br />            next_nodes = Array.new<br />            num_paths_from_each_node.times <span class="keyword">do</span><br />                next_nodes &lt;&lt; nodes[rand(nodes.length)]<br />            <span class="keyword">end</span><br />            next_nodes.uniq!<br />            <span class="variable">@paths</span>[n] = next_nodes<br />        <span class="keyword">end</span><br />        arr = Array.new<br />        <span class="variable">@paths</span>.each <span class="keyword">do</span> |key,vals|<br />            <span class="variable">@paths</span>[key].each <span class="keyword">do</span> |val|<br />                arr &lt;&lt; [key,val]<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="variable">@dg</span> = DiGraph.new(*arr)<br />        <span class="variable">@nodes</span> = <span class="variable">@paths</span>.keys<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>(Note:  those bare instance variables nixed in with the comments reference variables on the Class object and not the instances themselves.  They read and discard nil values having no effect.)</p>
			<p>The code begins by generating up to ten (uniq!() can reduce the count) random nodes as simple Integers.  After that, each node is randomly connected to between one and three other nodes.  A Hash is created during this process to represent the connections.  This turns out to be very helpful later on.  Finally, the paths are converted into the Array representation DiGraph expects and the graph is created.  The last line also stores the nodes for easy access.</p>
			<p>Here's a random graph (viewed from the paths Hash) created from this code, so you can see how they come out:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    { 5 =&gt; [8, 6],<br />      0 =&gt; [0, 6],<br />      6 =&gt; [1, 7, 6],<br />      1 =&gt; [8],<br />      7 =&gt; [7, 9, 4],<br />      8 =&gt; [6, 1],<br />      9 =&gt; [4, 8, 0],<br />      4 =&gt; [5] }<br /><br /></div></div>
			<p>Now, in order to use these random graphs, we really need code that can tell us the right answer for the data.  Essentially, this means that we require our own implementation of the test methods, to prove that we get the same answers as the DiGraph implementation.  Here is one of those methods, used to test max_length_of_simple_path_including_node():</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Depth first search for the longest simple path starting from 'node'</span><br />    <span class="comment"># Simple path means a path that doesn't contain any duplicate edges</span><br />    <span class="comment"># Note: I'm not using the definition of simply connected based on no</span><br />    <span class="comment"># duplicate nodes</span><br />    <span class="keyword">def</span> search(node)<br />        longest_path = 0<br />        <span class="keyword">if</span> (<span class="variable">@paths</span>[node])<br />            <span class="variable">@paths</span>[node].each_index <span class="keyword">do</span> |next_idx|<br />                next_node = <span class="variable">@paths</span>[node][next_idx]<br />                <span class="variable">@paths</span>[node].delete_at(next_idx)<br />                tmp = 1 + search(next_node)<br />                <span class="variable">@paths</span>[node].insert(next_idx,next_node)<br />                <span class="keyword">if</span> (longest_path &lt; tmp)<br />                    longest_path = tmp<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> longest_path<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This method is a simple depth-first search, as the comment says, counting the steps taken to reach the farthest node without crossing a single edge twice.  The implementation is just a recursive search from each node reachable from the start node.  At each step, the last edge crossed is removed from the paths Hash, the recursive search is performed, and then the edge is restored.  The returned result here is just a count, not the actual path.</p>
			<p>The tests using that are pretty trivial:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> test_03_max_length_of_simple_path_including_node<br />        generate_dg<br />        <span class="variable">@nodes</span>.each <span class="keyword">do</span> |node|<br />            longest_path = search(node)<br />            <span class="comment"># ...</span><br />            assert_equal( longest_path,<br />                          <span class="variable">@dg</span>.max_length_of_simple_path_including_node(node) )<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Unfortunately, this is where we get to execution problems with the quiz.  The above code passes some tests, due to bugs in the DiGraph implementation, but it does not correctly implement the max_length_of_simple_path_including_node() method described in the quiz.</p>
			<p>Here's an example of where it gets wrong answers, using my trivial one-way path described at the beginning of this quiz:</p>
			<p class="example">&gt;&gt; @paths = {"A" =&gt; ["B"], "B" =&gt; ["C"], "C" =&gt; ["D"]}<br />=&gt; {"A"=&gt;["B"], "B"=&gt;["C"], "C"=&gt;["D"]}<br />&gt;&gt; search("A")<br />=&gt; 3<br />&gt;&gt; search("B")<br />=&gt; 2<br />&gt;&gt; search("C")<br />=&gt; 1<br />&gt;&gt; search("D")<br />=&gt; 0</p>
			<p>Those are the longest simple paths *starting* from a given node, but not the longest given paths *including* the given node (which would all be 3).</p>
			<p>These errors made it tricky to correctly evaluate the expected results of the methods and I apologize for this.  I ran into the same issue with my own tests, as anyone following my posts to Ruby Talk saw in painful detail.</p>
			<p>Luckily, it's easy to get to a real solution of the first method from here.  First, we can modify Himadri's search() method to return the path instead of just a count:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> search(node, longest_path = [node])<br />        <span class="keyword">if</span> (<span class="variable">@paths</span>[node])<br />            <span class="variable">@paths</span>[node].each_index <span class="keyword">do</span> |next_idx|<br />                next_node = <span class="variable">@paths</span>[node][next_idx]<br />                <span class="variable">@paths</span>[node].delete_at(next_idx)<br />                tmp = search(next_node, longest_path + [next_node])<br />                <span class="variable">@paths</span>[node].insert(next_idx,next_node)<br />                <span class="keyword">if</span> (longest_path.size &lt; tmp.size)<br />                    longest_path = tmp<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> longest_path<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Then, using that method, we can exhaustively search all the long paths for the biggest one containing our node:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> max_length_of_simple_path_including_node(n)<br />      all_paths = <span class="variable">@paths</span>.keys.map { |node| search(node) }<br />      all_paths = all_paths.select { |path| path.include? n }<br />      all_paths = all_paths.sort_by { |path| -path.size }<br />      all_paths.empty? ? 0 : all_paths.shift.size - 1<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Line by line that makes a list of the longest paths starting from each node, reduces that list to those including the desired node, sorts the remaining paths biggest to smallest, and finally returns an edge count of the largest path or 0 if there aren't any paths left.</p>
			<p>The other method is left as an exercise for the interested reader.</p>
			<p>Many, many thanks to the submitters who braved the waters and came up with some basic tests, right or wrong.</p>
			<p>Tomorrow, we will programatically generate 1,000 monkeys in the hopes that they can recreate the works of Shakespeare...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/187663">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/187738">Himadri Choudhury</a></li>
			</ol>
			<p><a href="quiz73_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
