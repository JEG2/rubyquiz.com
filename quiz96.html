<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Story Generator (#96)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Story Generator (#96)</span>
			<p>by Morton Goldberg</p>
			<p>[ Editor's Note:</p>
			<p>I realize we've done a similar quiz in the past, but read on and give this one a chance.  It has a pretty different spin than Markov Chains.</p>
			<p>--JEG2 ]</p>
			<p>The Dwemthy's Array RPG example in Why's (Poignant) Guide to Ruby[1] was my introduction to Ruby metaprogramming. While it's an excellent introduction to metaprogramming, it's not much of an RPG, so I thought I'd have a go at improving it. But a funny thing happened when I started coding: the RPG turned in a story generator. Here are a couple of stories generated by my current version.</p>
			<p>The first story is fairly typical of the shorter ones. The rabbit gets past the BogusFox only to fall to the Jabberwocky.</p>
			<p class="example">A BogusFox emerges from the gloom and cries out,"Hail, Rabbit, <br />prepare to die!"<br />"I fear you not, BogusFox!"<br />Rabbit [25] and BogusFox [50] fight.<br />Rabbit attacks BogusFox with magick sword.<br />Fighting lowers BogusFox life force by 9.<br />BogusFox suffered a minor wound.<br />BogusFox swings his axe.<br />Fighting lowers Rabbit life force by 7.<br />Rabbit was wounded.<br />Rabbit [18] and BogusFox [41] fight.<br />Rabbit attacks BogusFox with magick sword.<br />Fighting lowers BogusFox life force by 43.<br />BogusFox dies.<br />Eating magick lettuce adds 7 to Rabbit life force.<br />A Jabberwocky emerges from the gloom and cries out,"Ah, a tasty Rabbit!"<br />"I fear you not, Jabberwocky!"<br />Rabbit [25] and Jabberwocky [100] fight.<br />Rabbit attacks Jabberwocky with magick sword.<br />Fighting lowers Jabberwocky life force by 63.<br />Jabberwocky was seriously wounded but carries on.<br />Jabberwocky attacks Rabbit with teeth and claws.<br />Fighting lowers Rabbit life force by 33.<br />Rabbit dies.<br />It's over. It's all over.</p>
			<p>The second story is an example proving that low probability events do occur. The rabbit actually wins! And what's truly amazing is that he kills every monster with a single stroke of his magick sword. Talk about luck!</p>
			<p class="example">A BogusFox emerges from the gloom and cries out,"Hail, Rabbit, <br />prepare to die!"<br />"I fear you not, BogusFox!"<br />Rabbit [25] and BogusFox [50] fight.<br />Rabbit attacks BogusFox with magick sword.<br />Fighting lowers BogusFox life force by 59.<br />BogusFox dies.<br />Eating magick lettuce adds 37 to Rabbit life force.<br />A Jabberwocky emerges from the gloom and cries out,"Ah, a tasty Rabbit!"<br />"I fear you not, Jabberwocky!"<br />Rabbit [62] and Jabberwocky [100] fight.<br />Rabbit attacks Jabberwocky with magick sword.<br />Fighting lowers Jabberwocky life force by 155.<br />Jabberwocky dies.<br />Eating magick lettuce adds 46 to Rabbit life force.<br />A DemonAngel emerges from the gloom and cries out,"Rabbit, I will <br />eat your soul!"<br />"I fear you not, DemonAngel!"<br />Rabbit [108] and DemonAngel [540] fight.<br />Rabbit attacks DemonAngel with magick sword.<br />Fighting lowers DemonAngel life force by 600.<br />DemonAngel dies.<br />Eating magick lettuce adds 20 to Rabbit life force.<br />A ViciousGreenFungus emerges from the gloom and cries out,"No Rabbit <br />has ever left my presence alive."<br />"I fear you not, ViciousGreenFungus!"<br />Rabbit [128] and ViciousGreenFungus [320] fight.<br />Rabbit attacks ViciousGreenFungus with magick sword.<br />Fighting lowers ViciousGreenFungus life force by 390.<br />ViciousGreenFungus dies.<br />Eating magick lettuce adds 35 to Rabbit life force.<br />A Dragon emerges from the gloom and cries out,"A brave Rabbit burns <br />just as well as a timid one."<br />"I fear you not, Dragon!"<br />Rabbit [163] and Dragon [1340] fight.<br />Rabbit attacks Dragon with magick sword.<br />Fighting lowers Dragon life force by 1436.<br />Dragon dies.<br />Eating magick lettuce adds 44 to Rabbit life force.<br />It's over. It's all over.</p>
			<p>The secret of the rabbit's magick sword will be revealed when my story generated is posted.</p>
			<p>"It's hardly literature," you say. I agree. "It's needs more work," you say. Again, I agree. But it does tell a story. Don't you root for the rabbit? Don't you feel just a little sad when he's killed (as he almost always is)? And isn't it wonderful when, once in a hundred runs or so, he actually kills the dragon and completes his quest?</p>
			<p>Story generators can be a lot of fun. Even addictive. It's fascinating to create your own world. And they are completely open-ended. You can always find ways to tweak them, either to improve the readability of the output or to improve the plot.</p>
			<p>In this quiz, I ask you to write your own story generator. You can start with Dwemthy's Array, as I did, or invent your own characters and plot. The only requirement is that the generator must produce a different story each time it is run.</p>
			<p class="example">1:  http://qa.poignantguide.net/chapter-6.html#section3</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>The solutions to this quiz where wildly creative, both in form and output.  I'm still having nightmares about poor Little Red-Cap and Princess Lily.</p>
			<p>The chief element of all the solutions was randomness.  Jim Menard and Morton Goldberg took game engines (already a bit random) and added an autoplay mode to drain stories out of them.  Myself and Jordan randomized sentence construction to varying degrees and slung together a mess of invented lines.  The other solutions narrowed their tale telling focus to a specific genre and randomized the story elements themselves.  The end results were quite varied and certainly entertaining!</p>
			<p>I really wish we could go through all of those solutions and talk about the unique approach of each one.  This week, even more than usual, each idea was quite unique.  Unfortunately time and space demand that I pick one.  Do look the others over though, so you can learn from the clever people who played with the quiz.</p>
			<p>Below I'm going to discuss the code from Boris Prinz.  Boris took the randomized story elements approach and ended up with a pretty flexible system.  On top of that, the code is just plain cool and worth a look.  Before we dive in though, here's a story produced by a sample run of Boris's code:</p>
			<p class="example">Once upon a time little red-cap met the huntsman although the huntsman lived<br />in the village. Then the wolf was delighted. Then he took a piece of cake.<br />Grandmother snored very loud, but little red-cap swallowed up grandmother,<br />and the huntsman saw a bottle of wine. Later he snored very loud. The wolf<br />was not afraid of little red-cap although he got deeper and deeper into<br />grandmother's house. Little red-cap opened the stomach of mother. She ran <br />straight to grandmother's house. Little red-cap saw a bottle of wine. The<br />huntsman ran straight to grandmother's house. Soon the wolf was delighted. <br />The huntsman walked for a short time by the side of grandmother.<br />The End.</p>
			<p>Alright, let's see how the misadventures of Little Red-Cap get constructed.  Here's the beginning of the code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Base<br />      <span class="keyword">def</span> <span class="keyword">self</span>.constructor *args<br />        attr_accessor(*args)<br />        define_method :initialize <span class="keyword">do</span> |*values|<br />          (0...args.size).each <span class="keyword">do</span> |i|<br />            <span class="keyword">self</span>.instance_variable_set(<span class="string">"@#{args[i]}"</span>, values[i])<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      <span class="keyword">def</span> to_s<br />        <span class="variable">@name</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Boris decided to take a metaprogramming approach to the large amount of classes that would need to be built.  The first step was to simplify the building of constructors for the classes, with a class method that rolls an initialize() plus some accessors for you.  This is pretty close to redefining Ruby's Struct class and it may be possible to use that instead, though the addition of the to_s() to pull the name attribute complicates this slightly.</p>
			<p>Let's see how this class method gets used:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Character &lt; Base<br />      constructor :name, :gender<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Action &lt; Base<br />      constructor :name, :objects_or_types<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Item &lt; Base<br />      constructor :name<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Place &lt; Base<br />      constructor :name<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Bridge &lt; Base<br />      constructor :name<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Here we see classes for the story elements being assembled.  All of these examples have the name element used by to_s() and Character and Action define additional elements for those types.</p>
			<p>Remember all the work being done by this simple call.  In the case of Character for example, a constructor is built to accept and set the two parameters and name(), name=(), gender(), and gender=() are defined as instance methods of the class.</p>
			<p>The next class forms a new base type for some sentence construction elements:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> PronounBase &lt; Base<br />      constructor :gender<br />      <span class="keyword">class</span> &lt;&lt; <span class="keyword">self</span><br />        attr_accessor :cases<br />      <span class="keyword">end</span><br />      <span class="keyword">def</span> to_s<br />        cases = <span class="keyword">self</span>.<span class="keyword">class</span>.cases<br />        <span class="variable">@gender</span> == :female ? cases[0] : cases[1]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>With pronouns the code needs to worry about the gender of the referred to Character.  To support this a class level attribute is defined that can hold both cases (female and male) and to_s() is modified to make the right choice based on the assigned gender.</p>
			<p>Now we can examine the extended family of this class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> PossessiveAdjective &lt; PronounBase<br />      <span class="keyword">self</span>.cases = [<span class="string">'her'</span>, <span class="string">'his'</span>]<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Pronoun &lt; PronounBase<br />      <span class="keyword">self</span>.cases = [<span class="string">'she'</span>, <span class="string">'he'</span>]<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> ReflexivePronoun &lt; PronounBase<br />      <span class="keyword">self</span>.cases = [<span class="string">'herself'</span>, <span class="string">'himself'</span>]<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Boris takes another metaprogramming step to help with the construction, storage, and selection of these entities:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Entities<br />      <span class="keyword">def</span> initialize klass<br />        <span class="variable">@entities</span> = []<br />        <span class="variable">@klass</span>  = klass<br />        <span class="keyword">yield</span>(<span class="keyword">self</span>)<br />      <span class="keyword">end</span><br />      <span class="keyword">def</span> create *args<br />        <span class="variable">@entities</span> &lt;&lt; <span class="variable">@klass</span>.new(*args)<br />      <span class="keyword">end</span><br />      <span class="keyword">def</span> pick<br />        <span class="variable">@entities</span>[rand(<span class="variable">@entities</span>.size)]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This class is an object container.  You tell it the kind of objects you will store in it at construction time.  After that, you can use create() to construct an object of the indicated type and add it to the collection.  When needed, pick() returns a random object from the collection.</p>
			<p>Here's the code that populates the containers for the Little Red-Cap story world:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    CAST = Entities.new(Character) <span class="keyword">do</span> |c|<br />      c.create <span class="string">'little red-cap'</span>, :female<br />      c.create <span class="string">'mother'</span>,         :female<br />      c.create <span class="string">'grandmother'</span>,    :female<br />      c.create <span class="string">'the wolf'</span>,       :male<br />      c.create <span class="string">'the huntsman'</span>,   :male<br />    <span class="keyword">end</span><br /><br />    ACTIONS = Entities.new(Action) <span class="keyword">do</span> |a|<br />      a.create <span class="string">'met'</span>, [Character]<br />      a.create <span class="string">'gave'</span>, [Item, <span class="string">'to'</span>, Character]<br />      a.create <span class="string">'took'</span>, [Item]<br />      a.create <span class="string">'ate'</span>, [Item]<br />      a.create <span class="string">'saw'</span>, [Item]<br />      a.create <span class="string">'told'</span>, [Character, <span class="string">'to be careful'</span>]<br />      a.create <span class="string">'lived in'</span>, [Place]<br />      a.create <span class="string">'lied in'</span>, [Place]<br />      a.create <span class="string">'went into'</span>, [Place]<br />      a.create <span class="string">'ran straight to'</span>, [Place]<br />      a.create <span class="string">'raised'</span>, [PossessiveAdjective, <span class="string">'eyes'</span>]<br />      a.create <span class="string">'was on'</span>, [PossessiveAdjective, <span class="string">'guard'</span>]<br />      a.create <span class="string">'thought to'</span>, [ ReflexivePronoun,<br />                               <span class="string">'"what a tender young creature"'</span> ]<br />      a.create <span class="string">'swallowed up'</span>, [Character]<br />      a.create <span class="string">'opened the stomach of'</span>, [Character]<br />      a.create <span class="string">'looked very strange'</span>, []<br />      a.create <span class="string">'was delighted'</span>, []<br />      a.create <span class="string">'fell asleep'</span>, []<br />      a.create <span class="string">'snored very loud'</span>, []<br />      a.create <span class="string">'said: "oh,'</span>, [Character, <span class="string">', what big ears you have"'</span>]<br />      a.create <span class="string">'was not afraid of'</span>, [Character]<br />      a.create <span class="string">'walked for a short time by the side of'</span>, [Character]<br />      a.create <span class="string">'got deeper and deeper into'</span>, [Place]<br />    <span class="keyword">end</span><br /><br />    ITEMS = Entities.new(Item) <span class="keyword">do</span> |i|<br />      i.create <span class="string">'a piece of cake'</span><br />      i.create <span class="string">'a bottle of wine'</span><br />      i.create <span class="string">'pretty flowers'</span><br />      i.create <span class="string">'a pair of scissors'</span><br />    <span class="keyword">end</span><br /><br />    PLACES = Entities.new(Place) <span class="keyword">do</span> |p|<br />      p.create <span class="string">'the wood'</span><br />      p.create <span class="string">'the village'</span><br />      p.create <span class="string">'bed'</span><br />      p.create <span class="string">"grandmother's house"</span><br />      p.create <span class="string">'the room'</span><br />    <span class="keyword">end</span><br /><br />    BRIDGES = Entities.new(Bridge) <span class="keyword">do</span> |b|<br />      5.times{b.create <span class="string">'.'</span>}<br />      b.create <span class="string">', because'</span><br />      b.create <span class="string">', while'</span><br />      b.create <span class="string">'. Later'</span><br />      b.create <span class="string">'. Then'</span><br />      b.create <span class="string">'. The next day'</span><br />      b.create <span class="string">'. And so'</span><br />      b.create <span class="string">', but'</span><br />      b.create <span class="string">'. Soon'</span><br />      b.create <span class="string">', and'</span><br />      b.create <span class="string">' until'</span><br />      b.create <span class="string">' although'</span><br />    <span class="keyword">end</span><br /><br />    ALL = { Character =&gt; CAST,   Action =&gt; ACTIONS,<br />            Place     =&gt; PLACES, Item   =&gt; ITEMS }<br /><br /></div></div>
			<p>I know that's a lot of code, but you can see that it's really just object construction in groups.  There are two points of interest in the above code, however.</p>
			<p>First note that we begin to get hints of sentence structure where the ACTIONS are constructed.  The second parameter for those seems to be a mapping of the elements and joining phrases that come after the action.  We will see how that comes together shortly now.</p>
			<p>Also of interest is the simple but effective first line of BRIDGES construction.  By adding the ordinary period five times, the scale is tilted so that it will randomly be selected more often.  This gives the final text a more natural flow.</p>
			<p>Here's the class that turns all of those simple lists into sentences:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Sentence<br />      attr_accessor :subject<br />      <span class="keyword">def</span> initialize<br />        <span class="variable">@subject</span> = CAST.pick<br />        <span class="variable">@verb</span>    = ACTIONS.pick<br />        <span class="variable">@objects</span> = []<br />        <span class="variable">@verb</span>.objects_or_types.each <span class="keyword">do</span> |obj_or_type|<br />          <span class="keyword">if</span> String === obj_or_type<br />            <span class="variable">@objects</span> &lt;&lt; obj_or_type<br />          <span class="keyword">else</span><br />            <span class="keyword">if</span> obj_or_type == PossessiveAdjective <span class="keyword">or</span><br />               obj_or_type == ReflexivePronoun<br />              <span class="variable">@objects</span> &lt;&lt; obj_or_type.new(<span class="variable">@subject</span>.gender)<br />            <span class="keyword">else</span><br />              thingy = ALL[obj_or_type].pick<br />              <span class="keyword">if</span> thingy == <span class="variable">@subject</span><br />                thingy = ReflexivePronoun.new(thingy.gender)<br />              <span class="keyword">end</span><br />              <span class="variable">@objects</span> &lt;&lt; thingy<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_s<br />        [<span class="variable">@subject</span>, <span class="variable">@verb</span>, <span class="variable">@objects</span>].flatten.map{|e| e.to_s}.join(<span class="string">' '</span>)<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The constructor does the heavy lifting here.  First a subject and verb are selected from the appropriate lists.  The rest of the method turns the sentence patterns we examined earlier into an actual list of objects.  Strings are just added to the list, PossessiveAdjectives and ReflexivePronouns are constructed based on the gender of the subject, and everything else is a random pick from the indicated list but swapped with a pronoun if the subject comes up again.  With the sentence pieces tucked away in instance variables, to_s() can just flatten() and join() the list to produce a final output.  (The call to map() is not needed since join() automatically stringifies the elements.)</p>
			<p>We only need one more class to turn those sentences into a complete story.  Here's the code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'enumerator'</span><br /><br />    <span class="keyword">class</span> Story<br />      <span class="keyword">def</span> initialize<br />        <span class="variable">@sentences</span> = []<br />        1.upto(rand(10)+10) <span class="keyword">do</span><br />          <span class="variable">@sentences</span> &lt;&lt; Sentence.new<br />        <span class="keyword">end</span><br />        combine_subjects<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># When the last sentence had the same subject, replace subject with</span><br />      <span class="comment"># 'he' or 'she':</span><br />      <span class="keyword">def</span> combine_subjects<br />        <span class="variable">@sentences</span>.each_cons(2) <span class="keyword">do</span> |s1, s2|<br />          <span class="keyword">if</span> s1.subject == s2.subject<br />            s2.subject = Pronoun.new(s1.subject.gender)<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Combine sentences to a story:</span><br />      <span class="keyword">def</span> to_s<br />        text = <span class="string">'Once upon a time '</span> + <span class="variable">@sentences</span>[0].to_s<br />        <span class="variable">@sentences</span>[1..-1].each <span class="keyword">do</span> |sentence|<br />          bridge = BRIDGES.pick.to_s<br />          text += bridge + <span class="string">' '</span> +<br />                  ( bridge[-1,1] == <span class="string">'.'</span> ? sentence.to_s.capitalize :<br />                                          sentence.to_s )<br />        <span class="keyword">end</span><br />        text.gsub!(<span class="string">/ ,/</span>, <span class="string">','</span>) <span class="comment"># a little clean-up</span><br />        text.gsub!(<span class="string">/(.{70,80}) /</span>, <span class="string">"\\1\n"</span>)<br />        text + <span class="string">".\nThe End.\n"</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    puts Story.new.to_s<br /><br /></div></div>
			<p>Here the constructor creates a random number of sentences (between 10 and 19) and modifies them if needed with a call to combine_subjects().  The comment gives you the scoop on that one, which just replaces the second of two consecutive subjects with a pronoun.</p>
			<p>Finally, to_s() produces the end result.  The first sentence is combined with the immortal opening "Once upon a time" to get us started.  After that, each sentence is joined to the story using one of the BRIDGES we saw in the entity construction, careful to maintain proper capitalization for the added sentence.  A few Regexps are used to tidy up and and the story closed with "The End."</p>
			<p>You can see in the final line of the program is all it takes to produce a solution.  A Story is constructed, stringified, and printed to the screen.  (Again the call to to_s() is not required, since puts() will handle this for you.)</p>
			<p>Once upon a time a band of seven Rubyists discovered the mysterious Ruby Quiz.  Together they unlocked its mysterious and enlightened the entire realm of programmers.  The quizmaster was eternally grateful for their efforts and shared knowledge.  The end.</p>
			<p>Tomorrow we will continue our word games, but turn our focus to Posix commands instead of using a normal dictionary...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217528">Jim Menard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217530">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217565">Boris Prinz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217569">Vianney Lecroart</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217572">Jordan</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217599">Morton Goldberg</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217621">Morton Goldberg (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/217668">Leslie Viljoen</a></li>
			</ol>
			<p><a href="quiz96_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
