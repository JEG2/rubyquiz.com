<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Countdown (#7)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Countdown (#7)</span>
			<p>by Brian Candler</p>
			<p>One of the longest-running quiz shows on UK TV is called Countdown, and has a "numbers round". There are some cards laid face down in front of the host - the top row contains 'large' numbers (from the set 25, 50, 75, 100), and the rest are 'small' (1 to 10). Six cards are picked and displayed: the choice is made by one of the contestants, who typically will ask for one large number and five small ones.</p>
			<p>Next, a machine called "Cecil" picks a target number between 100 and 999 at random. The contestants then have 30 seconds to find a way of combining the source numbers using the normal arithmetic operators (+, -, *, /) to make the target number, or to get as close as possible.</p>
			<p>Each source card can be used no more than once. The same applies to any intermediate results, although of course you don't have to explicitly show the intermediate results.</p>
			<p class="example">Example:  source 100 5 5 2 6 8, target 522<br /><br />100 * 5 = 500<br />  5 + 6 =  11<br /> 11 * 2 =  22<br />500 + 22 = 522<br /><br />or more succinctly, (5*100)+((5+6)*2) = 522<br /><br />Another solution is (100+6)*5-8 = 522</p>
			<p>Normal arithmetic rules apply, and in particular you are not allowed to use integer rounding. That is, 7 divided by 3 is 2 1/3, not 2.</p>
			<p>The quiz is to write a program which will accept one target number and a list of source numbers, and generate a solution which calculates the target or a number as close to the target as possible.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I think I need to start charging Dennis Ranke by the e-mail!  Seriously, it was interesting being able to follow the late stages of development for a couple of the solutions this time around.</p>
			<p>I found this problem very interesting and made a couple attempts to solve it myself, though these attempts didn't produce anything worth sharing.  I did gain a great appreciation for what's involved, so let me walk you through the highlights.</p>
			<p>At first glance, the search space for this problem looks very large.  The six source numbers can be ordered various ways, and you don't have to use all the numbers.  Beyond that, you can have one of four operators between each pair of numbers.  Finally, consider that 1 * 2 + 3 is different from 1 * (2 + 3).  That's a lot of combinations.</p>
			<p>However, we can prune that large search space significantly.  Let's start with some simple examples and work our way up.  Addition and multiplication are commutative, so:</p>
			<p class="example">1 + 2 = 3 and 2 + 1 = 3<br />1 * 2 = 2 and 2 * 1 = 2</p>
			<p>We don't need to handle it both ways.  One will do.</p>
			<p>Moving on to numbers, the example in the quiz used two 5s as source numbers.  Obviously, these two numbers are interchangeable.  The first 5 plus 2 is 7, just as the second 5 plus 2 is 7.</p>
			<p>What about the possible source number 1?  Anything times 1 is itself, so there is no need to check multiplication of 1.  Similarly, anything divided by 1 is itself.  No need to divide by 1.</p>
			<p>Let's look at 0.  Adding and subtracting 0 is pointless.  Multiplying by 0 takes us back to 0, which is pretty far from a number between 100 and 999 (our goal).  Dividing 0 by anything is the same story and dividing by 0 is illegal, of course.  Conclusion:  0 is useless.  Now you can't get 0 as a source number, but you can safely ignore any operation(s) that result in 0.</p>
			<p>Those are all single number examples, of course.  Time to think bigger.  What about negative numbers?  Our goal is somewhere between 100 to 999.  Negative numbers are going the wrong way.  They don't help, so you can safely ignore any operation(s) that results in a negative number.</p>
			<p>Fractions are debatable.  The quiz clearly allowed for them, but it came up in discussion that the actual game show does not.  Even when you use them, they're of limited help since the goal is always a whole number.  Eventually, you'll need to do something to that fractional value to bring it back to a whole number.  That takes a minimum of half your operands (two to make a fraction and at least one to eliminate the fractional value).  That said, they do increase your options, but leaving them out makes for faster runs and mirrors the game show.</p>
			<p>Finally, consider:</p>
			<p class="example">(5 + 5) / 2 = 5</p>
			<p>The above is just busy work.  We already had a 5; we didn't need to make one.  Any set of operations that result in one of their operands can be ignored.</p>
			<p>Using simplifications like the above, you can get the search space down to something that can be brute-force searched pretty quickly, as long as we're only dealing with six numbers.</p>
			<p>Dennis Ranke submitted the most complete example of pruning.  That solution is very well commented and I encourage all who are interested to look through it.</p>
			<p>If you would like to see a very simple, if slow, solution to the problem, have a look at Junghyun Kim's submission.</p>
			<p>For this summary, I want to take a deeper look at Brian Schr&ouml;der's solution.  Here's the heart of it:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Search all possible terms for the ones that fits best.</span><br /><br />    <span class="comment"># Systematically create all terms over all subsets the set of</span><br />    <span class="comment"># numbers in source, and find the one that is closest to target.</span><br />    <span class="comment">#</span><br />    <span class="comment"># Returns the solution that is closest to the target.</span><br />    <span class="comment">#</span><br />    <span class="comment"># If a block is given, calls the block each time a better or</span><br />    <span class="comment"># equal solution is found.</span><br />    <span class="comment">#</span><br />    <span class="comment"># As a heuristic to guide the search sorts the numbers ascending.</span><br />    <span class="keyword">def</span> solve_countdown(target, source, use_module)<br />      source = source.sort_by{|i|-i}<br />      best = <span class="keyword">nil</span><br />      best_distance = 1.0/0.0<br />      use_module::each_term_over(source) <span class="keyword">do</span> | term |<br />        distance = (term.value - target).abs<br />        <span class="keyword">if</span> distance &lt;= best_distance<br />          best_distance = distance<br />          best = term<br />          <span class="keyword">yield</span> best <span class="keyword">if</span> block_given?<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      <span class="keyword">return</span> best<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This method takes the "target" and "source" numbers in addition to a Module, which I'll come back to in a minute, as parameters.  The first line is the sort mentioned in the comment.  Then "best" and "best_distance" are initialized to nil and Infinity, to track the best solution discovered so far.</p>
			<p>After the setup, the method calls into the each_term_over() method, provided by the Module it was called with.  The Module to use is determined by the interface code (not shown) based on the provided command-line switches.  There are four possible choices.  Two deal with fractions while two are integer only, and there is a recursive and "memoized" version for each number type.  The program switches solving strategies based on the user's requests.  (This is a nice use of the State design pattern.)</p>
			<p>Here is each_term_over() in the Module Recursive::Integral:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Call the given block for each term that can be constructed</span><br />    <span class="comment"># over a set of numbers.</span><br />    <span class="comment">#</span><br />    <span class="comment"># Recursive implementation, that calls a block each time a new</span><br />    <span class="comment"># term has been stitched together.</span><br />    <span class="comment"># Returns each term multiple times.</span><br />    <span class="comment">#</span><br />    <span class="comment"># This version checks, that only integral results may result.</span><br />    <span class="comment">#</span><br />    <span class="comment"># Here I explicitly coded the operators, because there is not</span><br />    <span class="comment"># much redundance.</span><br />    <span class="comment">#</span><br />    <span class="comment"># This may be a bit slow, because it zips up through the whole</span><br />    <span class="comment"># callstack each time a new term is created.</span><br />    <span class="keyword">def</span> Integral.each_term_over(source)<br />      <span class="keyword">if</span> source.length == 1<br />        <span class="keyword">yield</span> source[0]<br />      <span class="keyword">else</span><br />        source.each_partition <span class="keyword">do</span> | p1, p2 |<br />          each_term_over(p1) <span class="keyword">do</span> | op1 |<br />            <span class="keyword">yield</span> op1<br />            each_term_over(p2) <span class="keyword">do</span> | op2 |<br />              <span class="keyword">yield</span> op2<br />              <span class="keyword">if</span> op2.value != 0<br />                <span class="keyword">yield</span> Term.new(op1, op2, :+)<br />                <span class="keyword">yield</span> Term.new(op1, op2, :-)<br />                <span class="keyword">if</span> op2.value != 1 <span class="keyword">and</span> op1.value % op2.value == 0<br />                  <span class="keyword">yield</span> Term.new(op1, op2, :<span class="string">'/'</span>)<br />                <span class="keyword">end</span><br />              <span class="keyword">end</span><br />              <span class="keyword">if</span> op1.value != 0<br />                <span class="keyword">yield</span> Term.new(op2, op1, :-)<br />                <span class="keyword">if</span> op1.value != 1<br />                  <span class="keyword">if</span> op2.value % op1.value == 0<br />                    <span class="keyword">yield</span> Term.new(op2, op1, :<span class="string">'/'</span>)<br />                  <span class="keyword">end</span><br />                  <span class="keyword">if</span> op2.value != 0 <span class="keyword">and</span> op2.value != 1<br />                    <span class="keyword">yield</span> Term.new(op1, op2, :*)<br />                  <span class="keyword">end</span><br />                <span class="keyword">end</span><br />              <span class="keyword">end</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This method recursively generates terms in every possible combination.  This is a key point to a working solution and my own source of failure.  I tried adding a number at a time, which generates solutions looking like:</p>
			<p class="example">(((num op num) op num) op num)...</p>
			<p>The tricky example posted to Ruby Talk by daz (Target:  926, Source:  75, 2, 8, 5, 10, 10) shows off the folly of this approach.  The only answer is:</p>
			<p class="example">(75 - 5 + 8) * (2 + 10) - 10</p>
			<p>As you can see, the 2 + 10 term must be built separately from the 75 - 5 + 8 term and then the two can be combined.</p>
			<p>Getting back to the code above, the each_partition() method it uses was added to Array, in a different section of the code (not shown).  It works as expected, returning "each true partition (containing no empty set) exactly once".  Term objects (not shown), just manage their operands and operator, providing mainly string representation and result evaluation.</p>
			<p>The block we're yielding to in here is the block passed by solve_countdown(), which we examined earlier.  It is simply keeping track of the best solution generated so far.</p>
			<p>As an aside, I'm not convinced the yields to "op1" and "op2" are needed.  I commented them out and was unable to produce a failure, but it's possible I just didn't try the right tests.</p>
			<p>The interesting part of all this is the same method in a different module.  Here's each_term_over() from Memoized::Integral:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> Integral.each_term_over(source, memo = {}, &amp;block)<br />      <span class="keyword">return</span> memo[source] <span class="keyword">if</span> memo[source]<br /><br />      result = []<br />      <span class="keyword">if</span> source.length == 1<br />        result &lt;&lt; source[0]<br />      <span class="keyword">else</span><br />        source.each_partition <span class="keyword">do</span> | p1, p2 |<br />          each_term_over(p1, memo, &amp;block).each <span class="keyword">do</span> | op1 |<br />            each_term_over(p2, memo, &amp;block).each <span class="keyword">do</span> | op2 |<br />              <span class="keyword">if</span> op2.value != 0<br />                result &lt;&lt; Term.new(op1, op2, :+)<br />                result &lt;&lt; Term.new(op1, op2, :-)<br />                <span class="keyword">if</span> op2.value != 1 <span class="keyword">and</span> op1.value % op2.value == 0<br />                  result &lt;&lt; Term.new(op1, op2, :<span class="string">'/'</span>)<br />                <span class="keyword">end</span><br />              <span class="keyword">end</span><br />              <span class="keyword">if</span> op1.value != 0<br />                result &lt;&lt; Term.new(op2, op1, :-)<br />                <span class="keyword">if</span> op1.value != 1<br />                  <span class="keyword">if</span> op2.value % op1.value == 0<br />                    result &lt;&lt; Term.new(op2, op1, :<span class="string">'/'</span>)<br />                  <span class="keyword">end</span><br />                  <span class="keyword">if</span> op2.value != 0 <span class="keyword">and</span> op2.value != 1<br />                    result &lt;&lt; Term.new(op1, op2, :*)<br />                  <span class="keyword">end</span><br />                <span class="keyword">end</span><br />              <span class="keyword">end</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      result.each <span class="keyword">do</span> | term | block.call(term) <span class="keyword">end</span><br />      memo[source] = result<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The result of this method is the same, but it uses a technique called "memoization" to work faster.  When Terms are generated in here, they get added to the hash "memo".  After that, all the magic is in the very first line, which simply skips all the work the next time those source numbers are examined.</p>
			<p>This leans on memory (the hash of stored results) for speed (no repeat work).  That's why the solution provides other options too.  Maybe the target platform won't have the memory to spare.</p>
			<p>This is a handy technique showcased in a nice implementation and thus worth a look, I think.</p>
			<p>David G. Andersen submitted a similar solution with a lot of raw speed, but it was a little harder to follow.  (David the Code Style Police are on their way.  Just hand over the keyboard...  It's for your own good.)</p>
			<p>If you would like to play with an interactive solver without pulling down the Ruby code for these solutions, check out this great link posted by daz:</p>
			<p><a href="http://www.crosswordtools.com/numbers-game/">Numbers Game Solver</a></p>
			<p>As usual, I offer my thanks to the quiz maker and takers.</p>
			<p>We have two more contributed quizzes to come.  (Great News!!!)  Look for Jim Menard's quiz, tomorrow morning...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120261">Dennis Ranke</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120262">Dennis Ranke (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120286">Brian Schr&ouml;der</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120312">David G. Andersen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120345">Dennis Ranke (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120476">David G. Andersen (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120532">Dennis Ranke (4)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120533">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120540">Junghyun Kim</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/120841">daz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/121190">Brian Candler</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/121200">Brian Candler (2)</a></li>
			</ol>
			<p><a href="quiz7_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
