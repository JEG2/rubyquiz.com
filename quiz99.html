<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Fuzzy Time (#99)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Fuzzy Time (#99)</span>
			<p>by Gavin Kistner</p>
			<p class="example">The Background<br />---------------------------------------------------------------------</p>
			<p>Last night I was having trouble falling asleep, and was staring at my digital alarm clock (as I do so often under that circumstance). Something on the bedside table was occluding the minutes digit, however, so all I could tell is that it was "10 4". (Oddly, my alarm clock has no ":" between the hours and minutes.)</p>
			<p>"How nice!" I thought. "An imposed vagueness to keep me from obsessing on exactly what time it is! Should I really be worried about the exact time? Shouldn't I be more relaxed? Shouldn't a 10-minute precision in life be enough to keep me roughly on time, without obsessing on exacting promptitude?"</p>
			<p>I realized that if I kept staring at the clock (as I did), and I were to observe it changing from "10 4" to "10 5", that I would, at that moment, know exactly what time it is.</p>
			<p>"Bah" I thought, "so much for that idea."</p>
			<p>And then I thought some more. I thought of bad ideas: analog watches where the hand erratically swings forward and backward, digital clocks that showed random times near the correct time. And then I dreamed of the watch I wanted to own...</p>
			<p class="example">The Challenge<br />---------------------------------------------------------------------</p>
			<p>Requirement #1: Write a Ruby program that shows the current time, but only the 'tens' part of the minutes. For example, if the time is 10:37, then the program might output "10:3~"</p>
			<p>Requirement #2: The time shown by the clock must randomly vary +/- 5 minutes from reality. For example, if the time is actually 10:37, the program might output "10:3~" or "10:4~" (but not "10:2~" or "10:5~").</p>
			<p>Requirement #3: The time on the clock should continuously increase. If the time shows "10:4~" it must continue to show "10:4~" until it shows "10:5~". (It can't show "10:4~", then "10:3~" for a bit and then come back to "10:4~".)</p>
			<p>Putting the three requirements together, the left column below shows the actual time and the next three columns show the possible outputs from three different runs of the same program:</p>
			<p class="example">10:35    10:3~    10:4~    10:3~<br />10:36    10:3~    10:4~    10:3~<br />10:37    10:3~    10:4~    10:3~<br />10:38    10:3~    10:4~    10:3~<br />10:39    10:4~    10:4~    10:3~<br />10:40    10:4~    10:4~    10:3~<br />10:41    10:4~    10:4~    10:3~<br />10:42    10:4~    10:4~    10:3~<br />10:43    10:4~    10:4~    10:3~<br />10:44    10:4~    10:4~    10:3~<br />10:45    10:4~    10:4~    10:4~<br />10:46    10:4~    10:4~    10:5~<br />10:47    10:4~    10:4~    10:5~<br />10:48    10:4~    10:4~    10:5~<br />10:49    10:4~    10:4~    10:5~<br />10:50    10:4~    10:4~    10:5~<br />10:51    10:4~    10:4~    10:5~<br />10:52    10:5~    10:4~    10:5~<br />10:53    10:5~    10:4~    10:5~<br />10:54    10:5~    10:4~    10:5~<br />10:55    10:5~    10:5~    10:5~<br />10:56    10:5~    10:5~    11:0~<br />10:57    10:5~    10:5~    11:0~<br />10:58    10:5~    10:5~    11:0~<br />10:59    10:5~    10:5~    11:0~<br />11:00    10:5~    10:5~    11:0~<br />11:01    10:5~    10:5~    11:0~</p>
			<p class="example">Testing your Output<br />---------------------------------------------------------------------</p>
			<p>You should supply a FuzzyTime class that supports the following:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    ft = FuzzyTime.new                      <span class="comment"># Start at the current time</span><br />    ft = FuzzyTime.new(Time.at(1161104503)) <span class="comment"># Start at a specific time</span><br /><br />    p ft.to_s                               <span class="comment"># to_s format</span><br />    <span class="comment">#=&gt; "10:5~"</span><br /><br />    p ft.actual, ft.actual.<span class="keyword">class</span>            <span class="comment"># Reports real time as Time</span><br />    <span class="comment">#=&gt; Tue Oct 17 11:01:36 -0600 2006</span><br />    <span class="comment">#=&gt; Time</span><br /><br />    ft.advance( 60 * 10 )                   <span class="comment"># Manually advance time</span><br />    puts ft                                 <span class="comment"># by a specified number of</span><br />    <span class="comment">#=&gt; 11:0~                               # seconds.</span><br /><br />    sleep( 60 * 10 )<br /><br />    ft.update              <span class="comment"># Automatically update the time based on the</span><br />    puts ft                <span class="comment"># time that has passed since the last call</span><br />    <span class="comment">#=&gt; 11:1~              # to #initialize, #advance or #update</span><br /><br /></div></div>
			<p>Your class and output will be tested with code like the following:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> test_output<br />      <span class="comment"># Initialize with a well-known time</span><br />      ft = FuzzyTime.new( Time.at( ... ) )<br /><br />      60.times <span class="keyword">do</span><br />        <span class="variable">@legal</span>  = ...       <span class="comment"># Find the array of legal output strings</span><br />        <span class="variable">@output</span> = ft.to_s<br /><br />        assert_block <span class="string">"#@output not one of #@legal.inspect"</span> <span class="keyword">do</span><br />          <span class="variable">@legal</span>.include?( <span class="variable">@output</span> )<br />        <span class="keyword">end</span><br /><br />        sleep( rand( 30 ) )<br />        ft.update<br />      <span class="keyword">end</span><br /><br />      60.times <span class="keyword">do</span><br />        <span class="variable">@legal</span>  = ...       <span class="comment"># Find the array of legal output strings</span><br />        <span class="variable">@output</span> = ft.to_s<br /><br />        assert_block <span class="string">"#@output not one of #@legal.inspect"</span> <span class="keyword">do</span><br />          <span class="variable">@legal</span>.include?( <span class="variable">@output</span> )<br />        <span class="keyword">end</span><br /><br />        ft.advance( rand( 30 ) )<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p class="example">Extra Credit<br />---------------------------------------------------------------------</p>
			<p class="example">* Provide a self-running application that shows the time somehow.<br />(ASCII in the terminal, some GUI window, etc.)<br /><br />* Allow your class to be customized to display 12- or 24-hour time.<br /><br />* Allow your class to be customized to change how close to reality<br />it must display. (+/- 3 minutes, +/- 12 minutes, etc.)<br /><br />* Allow your class to be customized to change how roughly it displays<br />the time (e.g. 1 minute, 10 minute, 1 hour intervals).<br /><br />* Ensure that the transition from one digit to the next occurs<br />randomly across the range of -5 to +5. (So, while the digit might<br />change 5 minutes before or 5 minutes after the real transition, on<br />average the change should occur around the transition itself.)<br />You might need to assume that your update/advance method will be<br />called with a certain regularity (e.g. once per second, once every<br />7 seconds, once every 30 seconds, etc.)<br /><br />* Come up with your own technique of displaying time that <br />(a) is always 'close' to right, but (b) never allows a <br />watchful person to ever know exactly what time it is.</p>
			<p class="example">Things to Keep in Mind<br />---------------------------------------------------------------------</p>
			<p class="example">* You need to be able to handle the transition across hour/day<br />boundaries. (10:5~ might change to 11:0~ when the real time is still<br />10:58, or might continue to display 10:5~ when the real time is<br />11:04. On a 24-hour click, you also need to be able to wrap from<br />23:5~ to 00:0~)<br /><br />* For testing purposes of the real-time #update advancing, you might<br />find it easier to work with minutes and seconds instead of hours and<br />minutes.<br /><br />* Requirement #3 is, well, a requirement. Repeated #update/#to_s<br />calls to a FuzzyTime instance should never show an earlier time<br />(unless 24 hours occurred between #update calls ;).</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>by Gavin Kistner</p>
			<p>The core requirements for this quiz were somewhat easy. Let's look at what needed to be done, and how some people accomplished it:</p>
			<p class="example">1) How do you represent the internal time?</p>
			<p>While it would be possible to manage the time yourself, everyone (sensibly) chose to use Ruby's built-in Time class to represent the 'real' time behind the fuzz. Everyone gets a pat on the back.</p>
			<p class="example">2) How to you handle the 'overloaded' constructor?</p>
			<p>How do you write one initialize function that allows you to specify a start time or omit it? It seems almost silly to focus on it, and yet it's a common enough need that it's important to know how to do it 'right'.</p>
			<p>There were a few approaches to this. The simplest, I think, is to use Ruby's default values in the method definition. As Daniel Lucraft wrote:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> initialize( time = Time.now )<br />      <span class="variable">@start_time</span> = time<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Not only is this easy to write, but it also documents nicely. "If you don't give me a value for the time parameter, I'm going to use Time.now instead." RDoc handles this case when generating documentation.</p>
			<p>A variation is how Tom Pollard handled it:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> initialize ( actual=<span class="keyword">nil</span> )<br />      <span class="variable">@actual</span> = actual || Time.new()<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The above says to the user, "You may pass me an actual time or not, but what value I use if you don't give it to me is a detail you probably don't need to know about." Under some circumstances, this sort of implementation hiding might be preferable (coupled with good documentation about what it means to not supply the value).</p>
			<p>Less ideal (but functional) variations included:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> initialize(*args)<br />      now = Time.new<br />      <span class="variable">@internal_time</span> = args[0] || now<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> initialize(*args)<br />      <span class="keyword">if</span> args.size == 0<br />        <span class="variable">@timeshift</span>  = 0<br />      <span class="keyword">else</span><br />        <span class="variable">@timeshift</span>  = Time.now.to_i - args[0].to_i<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Writing code like this certainly works, but it makes the code less self-explanatory.</p>
			<p class="example">3) How do you convert to a fuzzy string?</p>
			<p>I was surprised by the variation in this category. The major variations:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> to_s<br />       <span class="variable">@my_time</span>.strftime(<span class="string">"%H:%M"</span>)[0..3] + <span class="string">"~"</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> to_s<br />      s = <span class="variable">@my_time</span>.strftime(<span class="string">"%H:%M"</span>)<br />      s[4] = <span class="string">'~'</span><br />      s<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> to_s<br />      fuzzy_hour, fuzzy_min, fuzzy_sec = get_time<br />      <span class="string">"#{fuzzy_hour}:#{fuzzy_min / 10}~"</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> to_s<br />      sprintf(<span class="string">'%02d:%d~%s'</span>,<br />        <span class="variable">@mode</span> == 24 ? <span class="variable">@my_time</span>.hour : <span class="variable">@my_time</span>.hour % 12,<br />        <span class="variable">@my_time</span>.min / 10,<br />        <span class="variable">@mode</span> != 24 ? <span class="variable">@my_time</span>.hour / 12 == 1 ? <span class="string">' pm'</span> : <span class="string">' am'</span> : <span class="string">''</span><br />      )<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I like the one-line simplicity of the first. It happens to create three strings in the process of creating the final, while the second (annoying-to-type, ugly) technique creates just one. I personally went with the second approach (create a string and then replace a character in-place) in the pointless pursuit of memory savings. Premature optimization at its finest, I think.</p>
			<p class="example">4) How do you keep track of the last displayed time?</p>
			<p>Because the Time class plays well with seconds as a sort of atomic base unit, some people chose to keep the 'fuzzy' time being displayed internally as an offset from the real time maintained internally. Others (including myself) chose to maintain the last displayed time as a separate Time instance. I don't see a major benefit of using one over the other, but wanted to point out the alternative.</p>
			<p class="example">5) How do you ensure no backtracking?</p>
			<p>This was the trickiest part of the quiz (outside of the 'extra credit' options). The requirement was that the time never display a time earlier than the last displayed time. I originally (naively) coded this roughly as:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="variable">@time_to_display</span> = ... <span class="comment">#some Time instance</span><br />    <span class="keyword">if</span> <span class="variable">@time_to_display</span> &lt; <span class="variable">@last_displayed_time</span><br />      <span class="variable">@time_to_display</span> = <span class="variable">@last_displayed_time</span><br />    <span class="keyword">end</span><br />    <span class="comment"># (Display the time here)</span><br />    <span class="variable">@last_displayed_time</span> = <span class="variable">@time_to_display</span><br /><br /></div></div>
			<p>The problem with this approach is that it's overly restrictive. For example, assume that the last time shown by the class was 10:49, which was displayed at "10:4~". If the class then generates a random time to display of 10:45, the above code will say "Nope, that's before 10:49, gotta stick to 10:49". Of course, 10:45 is a perfectly reasonable time to use internally, since it still displays as "10:4~".</p>
			<p>Using any sort of approach that adds or subtracts an offset from a moving 'fuzzy' time, the above approach is like the ratchets on a roller coaster hill. Each step forward you take prevents you from coming backwards. Before you know it, your wandering time is pinned as far forward as it can go.</p>
			<p>The desire, then, is to ensure that the internal time never becomes earlier than the bottom of the *displayed* version of the internal fuzzy time.</p>
			<p>In my test case (because I had no access to the internals of the class), I did this by parsing the string and backing it up manually.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    y,mon,day = t.year, t.mon, t.day<br />    h,m = last_value.scan(<span class="string">/\d+/</span>).map{ |s| s.to_i }<br />    m *= 10<br />    <span class="keyword">if</span> (m -= 10) &lt; 0<br />      m %= 60<br />      <span class="keyword">if</span> (h -= 1) &lt; 0<br />        h %= 24<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br />    illegal_old_value = Time.local( y,mon,day,h,m ).to_fuzzy<br /><br /></div></div>
			<p>Ugh. Time is so messy. In my class, I used the fact that rounding the internal seconds of a time class to a resolution of 600 gives you a time rounded to 10 minutes:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Time<br />      <span class="keyword">def</span> round_to( seconds )<br />        seconds = seconds.round<br />        Time.at( <span class="keyword">self</span>.to_i / seconds * seconds )<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br />    ...<br />    TEN_MINS = 10 * 60<br />    ...<br />    <span class="keyword">if</span> <span class="variable">@fuzzy</span>.round_to( TEN_MINS ) &lt; <span class="variable">@last_fuzzy</span>.round_to( TEN_MINS )<br /><br /></div></div>
			<p>However, Jeremy Hinegardner rounded the minutes down to 10 *before* displaying, and used that to create a new Time:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    min = (<span class="variable">@fuzzed</span>.min / 10) * 10<br />    <span class="variable">@display</span> = Time.mktime( <span class="variable">@fuzzed</span>.year, <span class="variable">@fuzzed</span>.month, <span class="variable">@fuzzed</span>.day,<br />                            <span class="variable">@fuzzed</span>.hour, min, 0, 0)<br /><br /></div></div>
			<p>This is nice, because the same Time instance used to display the time is also the lower limit for the next display. Nice work, Jeremy!</p>
			<p>That's most of the interesting stuff from the quiz...outside of the extra credit. Particularly the bit about trying to get an even distribution of random times. Other extra credit solutions were nice - check out the code for some interesting ways to round time to various degrees. But I wanted to mention this one just a bit.</p>
			<p class="example">6) How do you attempt even distribution?</p>
			<p>I'm not a statistician. For most of this topic, I suggest that you read some of the very interesting discussions[1] that took place on the mailing list.</p>
			<p>At first, I thought I was a statistician. I started writing this out in my code.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># The chance of success after n attempts of something with probability p</span><br />    <span class="comment"># per attempt is: s = 1-(1-p)**n</span><br />    <span class="comment">#</span><br />    <span class="comment"># Solving for p:</span><br />    <span class="comment"># 1-s = (1-p)**n</span><br />    <span class="comment"># (1-s)**(1/n) == 1-p</span><br />    <span class="comment"># p == 1 - (1-s)**(1/n)</span><br />    <span class="comment">#</span><br />    <span class="comment"># I want to have a 50% chance of moving ahead at the exact correct time,</span><br />    <span class="comment"># so if I am going to make n updates between -5 minutes and the correct</span><br />    <span class="comment"># time, I should try for a per attempt chance of p = 1 - 0.5**(1.0/n).</span><br />    <span class="comment">#</span><br />    <span class="comment"># This leaves me with a total chance of success of 75% after 2n</span><br />    <span class="comment"># attempts (+5 minutes), which (I think) means that the algorithm will be</span><br />    <span class="comment"># weighted towards running on the not-too-fast side. That's probably OK,</span><br />    <span class="comment"># given the one-way time valve.</span><br /><br /></div></div>
			<p>Then I went to put this idea into code. I wrote some code that automatically tracked how frequently the advance method was being called (using a simple low-pass filter instead of a running average). I used that number to calculate how many times per minute it was being called, and calculated the ideal probability to use per attempt.</p>
			<p>I wrote:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">if</span> rand &lt; per_advance_probability<br />      <span class="comment"># Uhm...what do I do here?</span><br /><br /></div></div>
			<p>Then I punted and went with a simple even distributation probability instead. (See the solution I submitted.) I just couldn't figure out where to go from there.</p>
			<p>My point, other than sharing my pain, is twofold:</p>
			<p>1) Having a rough, good idea of how to solve a problem is not the same as knowing how to solve it. My advice (to myself) is not to start randomly writing code, HOPING that when I get to the bit I'm not sure of that it will all work out. Time gets wasted that way.</p>
			<p>2) It's amazing how even simple programming problems can require some interesting cross-disciplinary knowledge, like probability and statistics.</p>
			<p>Finally, I wanted to mention how much of a challenge it turned out to be trying to write a test for random distribution. Min/maxes, means and standard deviations can give you an idea of how random some output is...but in this case a big curtain was being held up over half the output. If the time is 10:47 and the program displays "10:4~", I have no idea if internally it's running fast, slow, or on time. The only way I could think to test for randomness (other than peeking at the internals of the class) was to watch for the change from one displayed value to the next and see at that point how fast/slow the class was running.</p>
			<p>Thanks to everyone for contributing to this quiz! Great to see some new contributors. Yet again the requirements that I provided turned out to have some holes in them, which I hope that the test cases I provided helped to clarify my intent. I've decided I won't apologize for that, and instead use it as a life lesson on edge cases and getting clear problem specifications from your boss/client. :)</p>
			<p>Which gives me an interesting idea for a new quiz... Hmmmm...yes...</p>
			<p>See you next time!</p>
			<p><a href="http://rubyurl.com/xST">The Ruby Talk Thread</a></p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222631">Louis J Scoras</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222632">Marcel Ward</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222654">Paolo Negri</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222657">Paolo Negri (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222668">Ben Giddings</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222672">Jeremy Hinegardner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222675">Radoslaw Osmulski</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222677">Robert Conn</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222682">Gavin Kistner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222696">Caleb Powell</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222703">Thomas Mueller</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222758">Cameron Pope</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222784">Tom Pollard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222788">Daniel Lucraft</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222903">Tom Pollard (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/222984">Paolo Negri (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223287">Gavin Kistener (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223289">Gavin Kistener (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223291">Gavin Kistener (4)</a></li>
			</ol>
			<p><a href="quiz99_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
