<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Cellular Automata (#134)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Cellular Automata (#134)</span>
			<p>Most of us have probably heard of Conway's Game of Life, but there are other cellular automata that are equally interesting.  In fact, there is a group of 256 one-dimensional cellular automata that are quite easy to simulate but still fun to observe.</p>
			<p>To simulate these elementary cellular automata, you first need to construct a rule table.  This table is a description of the changes that happen in each discreet step of time.  Here's the table for the "rule 30" automaton:</p>
			<p class="example">+-----------------------------------------------------------------+<br />| Neighborhood    | 111 | 110 | 101 | 100 | 011 | 010 | 001 | 000 |<br />+-----------------------------------------------------------------+<br />| New Center Cell |  0  |  0  |  0  |  1  |  1  |  1  |  1  |  0  |<br />+-----------------------------------------------------------------+</p>
			<p>The first row is the same for this whole family of automata.  It represents the "neighborhood" of the cell currently being examined, which includes the cell itself and one cell to either side of it.  The current values of those cells, ones being on and zeros being off, can be used to determine the new value for this cell in the next discreet step of time.</p>
			<p>That new value comes from the bottom row.  This row is generated by taking the rule number, 30 in this case, in binary form.  11110 is 30 in binary, so we just pad the left side with zeros and we have our table.</p>
			<p>Once you have the rules, you just apply them to a string of cells.  For example, given the cells:</p>
			<p class="example">11001</p>
			<p>The rule 30 table creates:</p>
			<p class="example">1101111</p>
			<p>Note that cells outside of what I had were off (zeros) for the purposes of calculating neighborhoods.</p>
			<p>This week's Ruby Quiz is to write a program that accepts up to three parameters:  the rule as an integer in decimal, the number of steps to simulate, and the starting state of the cells as a String of ones and zeros.  Here's a sample run of my solution using all three options:</p>
			<p class="example">$ ruby cellular_automaton.rb -r 110 -s 20 -c 1<br />                    X                    <br />                   XX                    <br />                  XXX                    <br />                 XX X                    <br />                XXXXX                    <br />               XX   X                    <br />              XXX  XX                    <br />             XX X XXX                    <br />            XXXXXXX X                    <br />           XX     XXX                    <br />          XXX    XX X                    <br />         XX X   XXXXX                    <br />        XXXXX  XX   X                    <br />       XX   X XXX  XX                    <br />      XXX  XXXX X XXX                    <br />     XX X XX  XXXXX X                    <br />    XXXXXXXX XX   XXX                    <br />   XX      XXXX  XX X                    <br />  XXX     XX  X XXXXX                    <br /> XX X    XXX XXXX   X                    <br />XXXXX   XX XXX  X  XX                    </p>
			<p>To impress your friends, try adding in support for graphic output in addition to printing to the terminal.</p>
			<p style="text-align: center"><img src="images/rule_30_steps_200.png" alt="" width="401" height="201" /></p>
			<p style="text-align: center"><img src="images/rule_110_steps_200.png" alt="" width="401" height="201" /></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I chose this quiz because I felt it was easy and interesting.  It seems the jury is still out on the easy aspect though.  I believe there were only two correct solution this week.  Most of them had problems with at least some rules, including my own code.  Let's have a look at what went wrong.</p>
			<p>The issue is that any rule which sets the one's bit, creates a case where 000 activates the middle cell.  Since all cells not on are off and our area of cells is theoretically infinite in width, that means those rules create long strands of active cells on the very first step.</p>
			<p>This is only a problem because many of us tried a shortcut like my own code of:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    options[:steps].times <span class="keyword">do</span><br />      cells &lt;&lt; <span class="string">"00#{cells.last}00"</span>.scan(<span class="string">/./</span>).<br />                                   enum_cons(3).<br />                                   inject(<span class="string">""</span>) { |nc, n| nc + RULE_TABLE[n.join] }<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>However, adding two zeros to either end is not enough to properly display these patterns.</p>
			<p>A better approach is to create a viewing window of the cell space large enough to show the interesting parts of the pattern.  We will get the idea of the infinite spans when we see the cells running off the edges of such a window.</p>
			<p>It was Simon Kr√∂ger who pointed out these issues in the discuss and I believe his solution was the first correct submission, so let's take a peek at that code.  Here's the setup:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'optparse'</span><br /><br />    rule, steps, cells = 145, 20, <span class="string">'1'</span><br /><br />    OptionParser.new <span class="keyword">do</span> |opts|<br />      opts.on(<span class="string">"-r RULE"</span>, Integer) {|rule|}<br />      opts.on(<span class="string">"-s STEPS"</span>, Integer) {|steps|}<br />      opts.on(<span class="string">"-c CELLS"</span>, String) {|cells|}<br />    <span class="keyword">end</span>.parse!<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>You can see Simon require the OptionParser library here and put it to work.  Take a close look at just how the parameters are assigned though, because the code is tricky.</p>
			<p>First, some defaults are setup in normal variables.  Then the OptionParser code gets run, passing the user's settings into blocks that don't seem to do anything with the values.  Note though that those block variables have the same names as the variables where the defaults were placed.  In Ruby 1.8.x this will actually change the value of the outer variable.</p>
			<p>This is probably a good habit to start breaking now, if you catch yourself using it.  A future version of Ruby will change these variable assignment rules and break code like the above.</p>
			<p>Now that the variables are assigned, Simon creates the current row of cells:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    size = steps + cells.size + steps<br />    line = cells.center(size, <span class="string">'0'</span>)<br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is just the starting cells padded with zeros.  The key though is the amount of padding.  There are only two cases for how the cells grow.  We've talked about the infinite growth for rules with the one's bit on already, but all other rules can growth at most one cell in either direction each step.  That's the padding Simon adds, step zeros to either side.</p>
			<p>Now we are ready for the application code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    steps.times <span class="keyword">do</span><br />      puts line.tr(<span class="string">'01'</span>, <span class="string">' X'</span>)<br />      widened = line[0, 1] + line + line[-1, 1]<br />      line = (0...size).map{|i| rule[widened[i, 3].to_i(2)]}.join<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This code loops over the requested number of steps.  At each step, it prints the current row of cells.</p>
			<p>Now the widening step is another clever trick.  Remember, we have two growth rates, one cell at a time and infinite growth.  In the first case, we will have zeros at both ends and beyond that there should be more zeros.  In the latter case, all the cells on the edges will be ones to represent the infinite growth.  Beyond those would be more ones.  By expanding the grid with what is already on each end, both cases are covered.</p>
			<p>The final line of the iterator does the actual change of cells.  It walks the widened row, but takes the cells three at a time.  This will drop the two extra cells at the end back off and give us the proper row length.</p>
			<p>The actual application of the rule is done here with bit indexing.  By treating the three cells as a bit pattern and converting them to an Integer, we get the index for the rule that will fetch the proper zero or one for that pattern.</p>
			<p>You may want to work through this code with a pencil and paper until it all clicks.  I did.  There's a lot going on in that tiny bit of code.</p>
			<p>My thanks to all of the others who submitted as well.  These other solutions were interesting as well, despite my claims that they weren't completely correct.  Most of them worked on all of the rules that didn't expand infinitely and that includes the interesting rules.  Do browse through those.</p>
			<p>Tomorrow we will fiddle with with an Erlang problem I found interesting...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264260">Jesse Merriman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264266">Douglas A. Seifert</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264267">Simon Kr&ouml;ger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264273">Andreas Launila</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264287">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264306">Justin Ethier</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264365">Zed Lopez</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264390">Drew Olson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264391">Drew Olson (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264402">Drew Olson (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264410">alpha.chen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264521">Simon Kr&ouml;ger (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264559">Daniel Martin</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264575">Justin Ethier (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264683">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/264731">Yossef Mendelssohn</a></li>
			</ol>
			<p><a href="quiz134_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
