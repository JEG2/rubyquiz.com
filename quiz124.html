<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Magic Squares (#124)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Magic Squares (#124)</span>
			<p>A magic square of size N is a square with the numbers from 1 to N ** 2 arranged so that each row, column, and the two long diagonals have the same sum.  For example, a magic square for N = 5 could be:</p>
			<p class="example">+------------------------+<br />| 15 |  8 |  1 | 24 | 17 |<br />+------------------------+<br />| 16 | 14 |  7 |  5 | 23 |<br />+------------------------+<br />| 22 | 20 | 13 |  6 |  4 |<br />+------------------------+<br />|  3 | 21 | 19 | 12 | 10 |<br />+------------------------+<br />|  9 |  2 | 25 | 18 | 11 |<br />+------------------------+</p>
			<p>In this case the magic sum is 65.  All rows, columns, and both diagonals add up to that.</p>
			<p>This week's Ruby Quiz is to write a program that builds magic squares.  To keep the problem easy, I will say that your program only needs to work for odd values of N.  Try to keep your runtimes pretty reasonable even for the bigger values of N:</p>
			<p class="example">$ time ruby magic_square.rb 9<br />+--------------------------------------------+<br />| 45 | 34 | 23 | 12 |  1 | 80 | 69 | 58 | 47 |<br />+--------------------------------------------+<br />| 46 | 44 | 33 | 22 | 11 |  9 | 79 | 68 | 57 |<br />+--------------------------------------------+<br />| 56 | 54 | 43 | 32 | 21 | 10 |  8 | 78 | 67 |<br />+--------------------------------------------+<br />| 66 | 55 | 53 | 42 | 31 | 20 | 18 |  7 | 77 |<br />+--------------------------------------------+<br />| 76 | 65 | 63 | 52 | 41 | 30 | 19 | 17 |  6 |<br />+--------------------------------------------+<br />|  5 | 75 | 64 | 62 | 51 | 40 | 29 | 27 | 16 |<br />+--------------------------------------------+<br />| 15 |  4 | 74 | 72 | 61 | 50 | 39 | 28 | 26 |<br />+--------------------------------------------+<br />| 25 | 14 |  3 | 73 | 71 | 60 | 49 | 38 | 36 |<br />+--------------------------------------------+<br />| 35 | 24 | 13 |  2 | 81 | 70 | 59 | 48 | 37 |<br />+--------------------------------------------+<br /><br />real    0m0.012s<br />user    0m0.006s<br />sys     0m0.006s</p>
			<p>For extra credit, support even values of N.  You don't need to worry about N = 2 though as it is impossible.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I was pleasantly surprised by the number of people that tackled the extra credit this time around.  Essentially, there are different algorithms for building magic squares depending on the size of the square.  There are in fact three different algorithms:  one for odd sizes, one for doubly even (divisible by 4) sizes, and another for singly even (divisible by 2 but not 4) sizes.</p>
			<p>One solution that did handle all three cases came from David Tran.  Let's dive right into how David constructs the squares:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> MagicSquare<br /><br />      <span class="keyword">def</span> initialize(size = 3)<br />        raise <span class="string">"Error: size must greater than 2."</span> <span class="keyword">if</span> size &lt; 3<br />        <span class="variable">@magic_square</span> = <span class="keyword">if</span> (size % 2 != 0)<br />          OddMagicSquare.new(size)<br />        <span class="keyword">elsif</span> (size % 4 == 0)<br />          DoublyEvenMagicSquare.new(size)<br />        <span class="keyword">else</span><br />          SinglyEvenMagicSquare.new(size)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we see the initialization deferred to various classes based on the requested square size.  These are just the conditions for the various algorithms I mentioned earlier.</p>
			<p>One point of interest is that this solution won't construct a magic square of size one, though they are legal:</p>
			<p class="example">+---+<br />| 1 |<br />+---+</p>
			<p>Let's see some of the other methods in this class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> size<br />        <span class="variable">@magic_square</span>.size<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> [](i,j)<br />        <span class="variable">@magic_square</span>[i,j]<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>These two methods just delegate to the inner square object.  Nothing tricky there.</p>
			<p>Next we have the pretty printer:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> to_s<br />        digits = (size * size).to_s.size<br />        divider = <span class="string">'+'</span> + <span class="string">'-'</span> * ((digits + 2) * size + (size - 1)) + <span class="string">"+\n"</span><br />        (0...size).inject(divider) <span class="keyword">do</span> |s, i|<br />          (0...size).inject(s + <span class="string">"|"</span>) <span class="keyword">do</span> |s, j|<br />            s + <span class="string">" #{self[i,j].to_s.rjust(digits)} |"</span><br />          <span class="keyword">end</span> + <span class="string">"\n"</span> + divider<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Most solutions included a routine pretty similar to this.  You first have to find the width of the largest number and assemble a properly size border.  Then you can iterate over the rows and cells printing them at the proper width and with borders between.</p>
			<p>David also included a method that verifies his work:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> is_magic_square?<br />        size = <span class="keyword">self</span>.size<br />        n = size * size<br /><br />        array = Array.new(n)<br />        (0...size).each <span class="keyword">do</span> |i|<br />          (0...size).each <span class="keyword">do</span> |j|<br />            index = <span class="keyword">self</span>[i,j] - 1<br />            <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> (index &lt; 0) || (index &gt;= n) || array[index]<br />            array[index] = <span class="keyword">true</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">unless</span> array.all?<br /><br />        sum = size * (size * size + 1) / 2<br />        (0...size).each <span class="keyword">do</span> |i|<br />          <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> sum != (0...size).inject(0) { |s,j| s + <span class="keyword">self</span>[i,j] }<br />          <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> sum != (0...size).inject(0) { |s,j| s + <span class="keyword">self</span>[j,i] }<br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> sum != (0...size).inject(0) { |s,i| s + <span class="keyword">self</span>[i,i] }<br />        <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> sum != (0...size).inject(0) { |s,i|<br />          s + <span class="keyword">self</span>[i, size-1-i]<br />        }<br />        <span class="keyword">true</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method begins by calculating a few sizes.  It then launches into verifying that all the numbers in the expected range were used.  This code works by filling an Array the length of all the numbers with nils.  It then walks all numbers of the square, replacing that index with a true value.  Finally it checks that they are all true.  The rest of the method does the standard magic square validation by row, column, and diagonal.</p>
			<p>We're now ready to examine the three individual algorithms:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      private<br />      <span class="keyword">class</span> OddMagicSquare<br />        attr_reader :size<br /><br />        <span class="keyword">def</span> initialize(size)<br />          <span class="variable">@size</span> = size<br />          n = <span class="variable">@size</span> * <span class="variable">@size</span><br />          <span class="variable">@array</span> = Array.new(n)<br />          i, j = 0, <span class="variable">@size</span>/2<br />          (1..n).each <span class="keyword">do</span> |v|<br />            <span class="variable">@array</span>[get_index(i,j)] = v<br />            a, b = i-1, j+1<br />            i, j = <span class="keyword">self</span>[a,b] ? [i+1, j] : [a, b]<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> [](i, j)<br />          <span class="variable">@array</span>[get_index(i,j)]<br />        <span class="keyword">end</span><br /><br />        private<br />        <span class="keyword">def</span> get_index(i, j)<br />          (i % <span class="variable">@size</span>) * <span class="variable">@size</span> + (j % <span class="variable">@size</span>)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The algorithm for odd size magic squares is pretty straightforward.  You begin by placing a one in the top center of the of the square.  From there you just count, placing each number you come to in the square above and to the right of the last square you filled.  The board "wraps" for these movements, so moving off the top brings you to the bottom and moving off the right side returns you to the left.  If a normal move would take you to a filled square, you drop one square instead.</p>
			<p>The above is a Ruby implementation of this algorithm.  The values are all calculated at the time of object construction and stored in an instance variable.  They can then be accessed at any time via the [] method which uses row major indexing.</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">class</span> DoublyEvenMagicSquare<br />        attr_reader :size<br /><br />        <span class="keyword">def</span> initialize(size)<br />          <span class="variable">@size</span> = size<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> [](i, j)<br />          i, j = i % <span class="variable">@size</span>, j % <span class="variable">@size</span><br />          value = (i * <span class="variable">@size</span>) + j + 1<br />          i, j = i % 4, j % 4<br />          ((i == j) || (i + j == 3)) ? (<span class="variable">@size</span>*<span class="variable">@size</span>+1-value) : value<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Doubly even squares use an easy algorithm that can calculate a given value given just the coordinates.  Because of that, no effort is made to pre-calculate the values here and all the work is done in the []() method.</p>
			<p>This algorithm divides the overall grid into two kinds of squares.  One type is all squares that land on any diagonal created by subdividing the grid into four by four subgrids.  All other squares make up the other type.  Once you know which type of square you are dealing with, simple counting, from left to right and top to bottom, will give you the value of the square.  Diagonal squares count down from the highest number and the other squares count up from one.</p>
			<p>We have one more algorithm to go:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="keyword">class</span> SinglyEvenMagicSquare<br />        attr_reader :size<br /><br />        L = [4, 1, 2, 3]<br />        U = [1, 4, 2, 3]<br />        X = [1, 4, 3, 2]<br /><br />        <span class="keyword">def</span> initialize(size)<br />          <span class="variable">@size</span> = size<br />          <span class="variable">@odd_magic_square</span> = MagicSquare.new(<span class="variable">@size</span>/2)<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> [](i, j)<br />          i, j = i % <span class="variable">@size</span>, j % <span class="variable">@size</span><br />          ii, jj = i <span class="string">/ 2, j /</span> 2<br />          center = <span class="variable">@size</span> <span class="string">/ 2 /</span> 2<br />          value = <span class="variable">@odd_magic_square</span>[ii, jj]<br />          <span class="keyword">case</span><br />            <span class="keyword">when</span> ii &lt; center <span class="keyword">then</span> L<br />            <span class="keyword">when</span> ii == center <span class="keyword">then</span> (jj == center) ? U : L<br />            <span class="keyword">when</span> ii == center+1 <span class="keyword">then</span> (jj == center) ? L : U<br />            <span class="keyword">else</span> X<br />          <span class="keyword">end</span> [i%2*2 + j%2] + 4 * (value - 1)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The final algorithm is the trickiest.  You divide the grid into two by two subgrids.  Each subgrid is assigned a letter:  L, U, or X.  The first (size - 2) / 4 + 1 rows are L's, there's one row of U's, and the rest of the rows are X's.  You also swap the center U with the L just above it.  The letters describe the order you fill subgrids.  You can see these orders defined in constants at the top of David's class.  The only other element you need to know is the order to fill in the subgrids.  That is determined by building a size / 2 magic square using the odd pattern described early.  The order of those numbers dictate the order the subgrids are filled in.</p>
			<p>The final piece of the puzzle is the application code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />      puts MagicSquare.new(ARGV[0].to_i)<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This just builds and prints the correct square object from the choices we have been examining.  Note that to_s() is called implicitly by puts().</p>
			<p>My thanks to all the brave souls who went above and beyond the quiz requirements to show us great solutions.</p>
			<p>Tomorrow we will play with some fractal fun...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252102">Drew Olson</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252267">Harry Kakueki</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252269">Robert Dober</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252276">akbarhome</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252285">Rick DeNatale</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252286">Bryan Weatherly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252296">James Koppel</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252297">Hirotsugu Asari</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252300">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252307">Drew Olson (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252315">Donald Ball</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252328">Dan Manges</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252335">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252336">Christian Roese</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252338">David Tran (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252342">Harry Kakueki (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252363">Nicolas Modrzyk</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252365">David Tran (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252374">Yossef Mendelssohn</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252379">doug meyer</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252443">Ivo Dancet</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252534">G.Durga Prasad</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/252561">Ruben</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/253064">Harry Kakueki (3)</a></li>
			</ol>
			<p><a href="quiz124_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
