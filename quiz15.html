<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Animal Quiz (#15)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Animal Quiz (#15)</span>
			<p>by Jim Weirich</p>
			<p>Here's a program I've had a lot of fun with and might make a good Ruby
Quiz entry.  The program is a animal quiz program.</p>
			<p>It works like this.  The program starts by telling the user to think
of an animal.  It then begins asking a series of yes/no questions
about that animal: does it swim, does it have hair, etc.  Eventually,
it will narrow down the possibilities to a single animal and guess
that (Is it a mouse?).</p>
			<p>If the program has guessed correctly, the game is over and may be
restarted with a new animal.  If the program has guess incorrectly, it
asks the user for the kind of animal they were thinking of and then
asks for the user to provide a question that can distinguish between
its incorrect guess and the correct answer.  It then adds the new
question and animal to its "database" and will guess that animal in
the future (if appropriate).</p>
			<p>[ Editor's Note:  Here's a sample run of my solution, by way of example:</p>
			<p class="example">Think of an animal...<br />Is it an elephant?  (y or n)<br />n<br />You win.  Help me learn from my mistake before you go...<br />What animal were you thinking of?<br />a rabbit<br />Give me a question to distinguish a rabbit from an elephant.<br />Is it a small animal?<br />For a rabbit, what is the answer to your question?  (y or n)<br />y<br />Thanks.<br />Play again?  (y or n)<br />y<br />Think of an animal...<br />Is it a small animal?  (y or n)<br />y<br />Is it a rabbit?  (y or n)<br />n<br />You win.  Help me learn from my mistake before you go...<br />What animal were you thinking of?<br />a Shih Tzu<br />Give me a question to distinguish a Shih Tzu from a rabbit.<br />Is it a kind of dog?<br />For a Shih Tzu, what is the answer to your question?  (y or n)<br />y<br />Thanks.<br />Play again?  (y or n)<br />y<br />Think of an animal...<br />Is it a small animal?  (y or n)<br />y<br />Is it a kind of dog?  (y or n)<br />y<br />Is it a Shih Tzu?  (y or n)<br />y<br />I win.  Pretty smart, aren't I?<br />Play again?  (y or n)<br />n</p>
			<p>-JEG2 ]</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Quiz creator Jim Weirich shared this wonderful little tidbit with me:</p>
			<p class="example">True and slightly off topic story:<br /><br />The first time I wrote a version of this program, it was on a simple<br />single board Z80 computer using a FORTH-like language to program it.<br />I had seeded the program with a single animal (a mouse) and called my<br />wife in to try it out.  I explained the program and she ran the<br />program.  It printed out the words "Think of an animal ...", and then<br />paused for a few seconds.  Then it asked "Is it a mouse?".  My wife<br />turned to me with a look of absolute astonishment and said "HOW did it<br />know that?".<br /><br />Yep, she was thinking of a mouse.</p>
			<p>Unfortunately, none of the submitted solutions were quite that all-knowing.</p>
			<p>Everybody solved this one using pretty much the same technique.  Let's go back to Jim for an explanation of the strategy:</p>
			<p class="example">There is an easy solution that represents the database as a binary<br />tree with questions as interior nodes and possible animals as leaf<br />nodes.  Each interior question node has two children corresponding to<br />a yes or no answer.  The children are either further questions (which<br />will be asked) or an animal (which will be guessed).</p>
			<p>Couldn't have said it better myself.  Let's see Jim's own implementation of said tree:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby</span><br /><br />    require <span class="string">'yaml'</span><br />    require <span class="string">'ui'</span><br /><br />    <span class="keyword">def</span> ui<br />      <span class="global">$ui</span> ||= ConsoleUi.new<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Question<br />      <span class="keyword">def</span> initialize(question, yes, no)<br />        <span class="variable">@question</span> = question<br />        <span class="variable">@yes</span> = yes<br />        <span class="variable">@no</span> = no<br />        <span class="variable">@question</span> &lt;&lt; <span class="string">"?"</span> <span class="keyword">unless</span> <span class="variable">@question</span> =~ <span class="string">/\?$/</span><br />        <span class="variable">@question</span>.sub!(<span class="string">/^([a-z])/</span>) { <span class="global">$1</span>.upcase }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> walk<br />        <span class="keyword">if</span> ui.ask_if <span class="variable">@question</span><br />          <span class="variable">@yes</span> = <span class="variable">@yes</span>.walk<br />        <span class="keyword">else</span><br />          <span class="variable">@no</span> = <span class="variable">@no</span>.walk<br />        <span class="keyword">end</span><br />        <span class="keyword">self</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Animal<br />      attr_reader :name<br />      <span class="keyword">def</span> initialize(name)<br />        <span class="variable">@name</span> = name<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> walk<br />        <span class="keyword">if</span> ui.ask_if <span class="string">"Is it #{an name}?"</span><br />          ui.say <span class="string">"Yea!  I win!\n\n"</span><br />          <span class="keyword">self</span><br />        <span class="keyword">else</span><br />          ui.say <span class="string">"Rats, I lose"</span><br />          ui.say <span class="string">"Help me play better next time."</span><br />          new_animal = ui.ask <span class="string">"What animal were you thinking of?"</span><br />          question = ui.ask <span class="string">"Give me a question "</span> +<br />        <span class="string">"to distinguish a #{an name} from #{an new_animal}."</span><br />          response = ui.ask_if <span class="string">"For #{an new_animal}, "</span> +<br />        <span class="string">"the answer to your question would be?"</span><br />          ui.say <span class="string">"Thank you\n\n"</span><br />          <span class="keyword">if</span> response<br />        Question.new(question, Animal.new(new_animal), <span class="keyword">self</span>)<br />          <span class="keyword">else</span><br />        Question.new(question, <span class="keyword">self</span>, Animal.new(new_animal))<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> an(animal)<br />        ((animal =~ <span class="string">/^[aeiouy]/</span>) ? <span class="string">"an "</span> : <span class="string">"a "</span>) + animal<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">if</span> File.exist? <span class="string">"animals.yaml"</span><br />      current = open(<span class="string">"animals.yaml"</span>) { |f| YAML.load(f.read) }<br />    <span class="keyword">else</span><br />      current = Animal.new(<span class="string">"mouse"</span>)<br />    <span class="keyword">end</span><br /><br />    loop <span class="keyword">do</span><br />      current = current.walk<br />      <span class="keyword">break</span> <span class="keyword">unless</span>  ui.ask_if <span class="string">"Play again?"</span><br />      ui.say <span class="string">"\n\n"</span><br />    <span class="keyword">end</span><br /><br />    open(<span class="string">"animals.yaml"</span>, <span class="string">"w"</span>) <span class="keyword">do</span> |f| f.puts current.to_yaml <span class="keyword">end</span><br /><br /></div></div>
			<p>This is a very straight forward solution.  At the top, you can see that it brings in YAML for storage (many people did this) and a "ui" library to handle interface.  It also defines a helper method for the ui library, making it trivial to change the entire interface just by setting a global variable.</p>
			<p>Skip over the class definitions now and have a look at the "main" section.  The first third loads an existing animal tree, if one is available.  Otherwise, it creates a new tree by magically predicting what Jim's wife would guess.</p>
			<p>The middle third walk()s the tree, saving the result in case a new node is added.  It then asks if the user would like to play again, using the ui() helper method.</p>
			<p>The last third/line, just saves out the tree as it stands at the end of this run.  Isn't YAML handy?</p>
			<p>To make sense of all this talk about a "tree", you need to go back up and examine the two classes.  As described in the strategy quote above, Question objects just hold the question itself, and links to the answer nodes for yes and no.  The real method of interest here is Question#walk.  walk() asks its question through ui(), then recurses into @yes.walk() or @no.walk(), depending on the answer provided.  The trick to note here is that the result of the call is saved back to the node.  That allows nodes to update themselves, when the game learns a new animal.</p>
			<p>That just leaves Animal, which is even easier to grasp.  Again, the method of interest is Animal#walk.  walk() guesses the animal over ui() and declares victory if it's right.  When it's wrong, it asks the clarifying questions to learn and returns itself and the new animal wrapped in a new Question object.  This return ensures that the tree is updated, thanks to the saving behavior of Question#walk.</p>
			<p>That leaves only the mystical ui library.  Here's a look at it:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby</span><br /><br />    <span class="keyword">class</span> ConsoleUi<br />      <span class="keyword">def</span> ask(prompt)<br />        print prompt + <span class="string">" "</span><br />        answer = gets<br />        answer ? answer.chomp : <span class="keyword">nil</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> ask_if(prompt)<br />        answer = ask(prompt)<br />        answer =~ <span class="string">/^\s*[Yy]/</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> say(*msg)<br />        puts msg<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This is just a simple console interface, of course.  ask() handles input, say() output and ask_if() is a helper method that returns true if it looks like the user answered with a yes or false otherwise (handy for "if" conditions, thus the name).  These methods could be replaced with CGI equivalents, GUI routines, or whatever.  Nice abstraction here.</p>
			<p>Now, I did say the tree method was easy, but it's not without its faults.  Once more, I give you the voice of Jim:</p>
			<p class="example">However, the tree solution has some draw backs.  It is very sensitive<br />to the order in which animals are added to the tree and the type of<br />questions used. The tree solution works best when the early questions<br />divide the set of possible animals into more or less equal groups.<br />This keeps the tree nicely balanced and the series of questions<br />leading up to any guess are all equally short.  Unfortunately, in real<br />life the tree tends to become very unbalanced with individual questions<br />targetting a rather specific animal in the yes branch and the no<br />branch becoming a long list of more specific questions.<br /><br />Another small problem with the tree solution is that some questions<br />are ambiguous, or the user doesn't have the knowledge to answer the<br />question properly.  For example, a question might be "Does it live in<br />the water?".  Some people might select a beaver as their animal and<br />think "Oh yes, it loves to swim".  Others might say "No, it lives on<br />land, it just enjoys swimming".  In actual practice, these ambiguities<br />average out and you would get the beaver answer on both yes and no<br />nodes of a question, each branch using different questions to narrow<br />down the choice.  Although not a fatal flaw, it does put redundant<br />answers in the tree and essentially waste a question that could be put<br />to better use.</p>
			<p>I actually did a fair amount of thinking about other approaches to this problem. Unfortunately, every time I broke from the tree structure, it became a lot trickier to add new animals.  I basically had to badger the user for answers to half of all the questions known about their animal and in doing so it seemed I ran into even more irrelevancy issues.  Because of that, I eventually abandoned the approach.  If anybody has or creates another strategy for this, be sure and send it in!</p>
			<p>My thanks to the submitters and Jim, who didn't realize he had already wrote this summary when he told me I could handle it.</p>
			<p>Tomorrow, it's every coder for themselves as we get a little friendly competition going...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126713">Glenn Parker</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126717">Markus Koenig</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126735">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126747">Kero</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126786">Lee Marlow</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126875">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126952">Dick Davies</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126968">Vance A Heron</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/126985">Jim Weirich</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/127445">David Tran</a></li>
			</ol>
			<p><a href="quiz15_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
