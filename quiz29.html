<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - HighLine (#29)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">HighLine (#29)</span>
			<p>When you stop and think about it, methods like gets(), while handy, are still pretty low level.  In running Ruby Quiz I'm always seeing solutions with helper methods similar to this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># by Markus Koenig</span><br /><br />    <span class="keyword">def</span> ask(prompt)<br />        loop <span class="keyword">do</span><br />            print prompt, <span class="string">' '</span><br />            <span class="global">$stdout</span>.flush<br />            s = gets<br />            exit <span class="keyword">if</span> s == <span class="keyword">nil</span><br />            s.chomp!<br />            <span class="keyword">if</span> s == <span class="string">'y'</span> <span class="keyword">or</span> s == <span class="string">'yes'</span><br />                <span class="keyword">return</span> <span class="keyword">true</span><br />            <span class="keyword">elsif</span> s == <span class="string">'n'</span> <span class="keyword">or</span> s == <span class="string">'no'</span><br />                <span class="keyword">return</span> <span class="keyword">false</span><br />            <span class="keyword">else</span><br />                <span class="global">$stderr</span>.puts <span class="string">"Please answer yes or no."</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Surely we can make something like that better!  We don't always need Rails or a GUI framework and there's no reason writing a command-line application can't be equally smooth.</p>
			<p>This week's Ruby Quiz is to start a module called HighLine (for high-level, line-oriented interface).  Ideally this module would eventually cover many aspects of terminal interaction, but for this quiz we'll just focus on getting input.</p>
			<p>What I really think we need here is to take a page out of the optparse book.  Here are some general ideas:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    age = ask(<span class="string">"What is your age?"</span>, Integer, :within =&gt; 0..105)<br />    num = eval <span class="string">"0b#{ ask( 'Enter a binary number.',<br />                          String, :validate =&gt; /\A[01_]+\Z/ ) }"</span><br /><br />    <span class="keyword">if</span> ask_if(<span class="string">"Would you like to continue?"</span>) <span class="comment"># ...</span><br /><br /></div></div>
			<p>None of these ideas are etched in stone.  Feel free to call your input method prompt() or use a set of classes.  Rework the interface any way you like.  Just be sure to tell us how to use your system.</p>
			<p>The goal is to provide an easy-to-use, yet robust method of requesting input.  It should free the programmer of common concerns like calls to chomp() and ensuring valid input.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>There weren't a lot of solutions this week, but they all had interesting elements.  I had a really hard time selecting what to show in the summary, but the interests of time and space demand that I choose one.</p>
			<p>Let's have a look at Mark Sparshatt's solution.  We'll jump right into the ask() method, which was really the main thrust of this quiz:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> HighLine<br />      <span class="comment"># prompt = text to display</span><br />      <span class="comment"># type can be one of :string, :integer, :float, :bool or a proc</span><br />      <span class="comment">#   if it's a proc then it is called with the entered string. If the</span><br />      <span class="comment">#     input cannot be converted then it should throw an exception</span><br />      <span class="comment">#   if type == :bool then y,yes are converted to true. n,no are</span><br />      <span class="comment">#     converted to false. All other values are rejected.</span><br />      <span class="comment">#</span><br />      <span class="comment"># options should be a hash of validation options</span><br />      <span class="comment">#   :validate =&gt; regular expresion or proc</span><br />      <span class="comment">#     if validate is a regular expression then the input is matched</span><br />      <span class="comment">#       against it</span><br />      <span class="comment">#     if it's a proc then the proc is called and the input is accepted</span><br />      <span class="comment">#       if it returns true</span><br />      <span class="comment">#   :between =&gt; range</span><br />      <span class="comment">#     the input is checked if it lies within the range</span><br />      <span class="comment">#   :above =&gt; value</span><br />      <span class="comment">#     the input is checked if it is above the value</span><br />      <span class="comment">#   :below =&gt; value</span><br />      <span class="comment">#     the input is checked if it is less than the value</span><br />      <span class="comment">#   :default =&gt; string</span><br />      <span class="comment">#     if the user doesn't enter a value then the default value </span><br />      <span class="comment">#       is returned</span><br />      <span class="comment">#   :base =&gt; [b, o, d, x]</span><br />      <span class="comment">#     when asking for integers this will take a number in binary,</span><br />      <span class="comment">#       octal, decimal or hexadecimal</span><br />      <span class="keyword">def</span> ask(prompt, type, options=<span class="keyword">nil</span>)<br />        <span class="keyword">begin</span><br />          valid = <span class="keyword">true</span><br /><br />          default = option(options, :default)<br />          <span class="keyword">if</span> default<br />            defaultstr = <span class="string">" |#{default}|"</span><br />          <span class="keyword">else</span><br />            defaultstr = <span class="string">""</span><br />          <span class="keyword">end</span><br /><br />          base = option(options, :base)<br /><br />          print prompt, <span class="string">"#{defaultstr} "</span><br />          <span class="global">$stdout</span>.flush<br />          input = gets.chomp<br /><br />          <span class="keyword">if</span> default &amp;&amp; input == <span class="string">""</span><br />            input = default<br />          <span class="keyword">end</span><br /><br />          <span class="comment">#comvert the input to the correct type</span><br />          input = <span class="keyword">case</span> type<br />                  <span class="keyword">when</span> :string: input<br />                  <span class="keyword">when</span> :integer: convert(input, base) <span class="keyword">rescue</span> valid = <span class="keyword">false</span><br />                  <span class="keyword">when</span> :float: Float(input) <span class="keyword">rescue</span> valid = <span class="keyword">false</span><br />                  <span class="keyword">when</span> :bool<br />                    valid = input =~ <span class="string">/^(y|n|yes|no)$/</span><br />                    input[0] == ?y<br />                  <span class="keyword">when</span> Proc: input = type.call(input) <span class="keyword">rescue</span> valid = <span class="keyword">false</span><br />                  <span class="keyword">end</span><br /><br />          <span class="comment">#validate the input</span><br />          valid &amp;&amp;= validate(options, :validate) <span class="keyword">do</span> |test|<br />            <span class="keyword">case</span> test<br />            <span class="keyword">when</span> Regexp: input =~ test<br />            <span class="keyword">when</span> Proc: test.call(input)<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />          valid &amp;&amp;= validate(options, :within) { |range| range === input}<br />          valid &amp;&amp;= validate(options, :above) { |value| input &gt; value}<br />          valid &amp;&amp;= validate(options, :below) { |value| input &lt; value}<br /><br />          puts <span class="string">"Not a valid value"</span> <span class="keyword">unless</span> valid<br />        <span class="keyword">end</span> <span class="keyword">until</span> valid<br /><br />        <span class="keyword">return</span> input<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The comment above the method explains what it expects to be passed, in nice detail.  You can see that Mark added several options to those suggested in the quiz.  Mark also hit on a fun feature:  Allow the type parameter to be a Proc.  My own solution used this trick and I was surprised at the flexibility it lended to the method.  Let's move on to the code itself.</p>
			<p>The method starts off by calling a helper option() to fetch :default and :base.  We haven't seen the code for that yet, but it's easy to assume what it does at this point and we can mentally translate option(options, :default) to options[:default] for now.  Note that if a :default is given, the code sets up a string to display it to the user.</p>
			<p>The next little chunk of code displays the prompt (with trailing :default string).  flush() is called right after that, to be sure the output is not buffered.  Then a line is read from the keyboard.  If the line of input was empty and a :default was set, the next if statement makes the switch.</p>
			<p>The following case statement reassigns input, based on the type of conversion requested.  :string gets no translation, :integer calls the helper method convert() we'll examine later, :float uses Float(), :bool has a clever check that returns true if the first character is a ?y, and finally if type is a Proc object it is called with the input.</p>
			<p>There are a two other points of interest in this chunk of code.  First there are a lot of colons used in there, thanks to some new Ruby syntax.  when ... : is the same as when ... then, which is the older way to stuff the condition and result on the same line.  This works for if statements now too.</p>
			<p>The other point of interest is that the code is constantly updating the valid variable.  If and exception is thrown or a :bool question was given something other than "y", "n", "yes", or "no", valid is set to false.  If you glance back at the top of the method you'll see that valid started out true, but it may not be when we're done here.  We'll see the effects of that in a bit.</p>
			<p>Next up we have a bunch of calls to another helper called validate().  It seems to take some code and return a true or false response based on how the code executed.  If you reread the initial comment at this point, you'll see that it explains all those blocks and what they are checking for.  The neat trick here is that all of these results are &amp;&amp;=ed with valid.  &amp;&amp; requires two truths each time it is evaluated, so valid will only stay true if it was true when we got here and every single validate() call returns true.  This made for a pretty clean process, I though.</p>
			<p>We now see that we get a warning if we didn't provide valid input (by any required condition).  We also find the end of a begin ... end until valid construct, which is a rare Ruby loop that is similar to do ... until in other languages.  When input is returned outside that loop, we know it must be valid.</p>
			<p>Here's the other quiz suggested method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment">#...</span><br /><br />      <span class="comment">#asks a yes/no question</span><br />      <span class="keyword">def</span> ask_if(prompt)<br />        ask(prompt, :bool)<br />      <span class="keyword">end</span><br /><br />      <span class="comment">#...</span><br /><br /></div></div>
			<p>Obviously, that's just a simplification of ask().</p>
			<p>Let's get to those helper methods now:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment">#...</span><br /><br />      private<br /><br />      <span class="comment">#extracts a key from the options hash</span><br />      <span class="keyword">def</span> option(options, key)<br />        result = <span class="keyword">nil</span><br />        <span class="keyword">if</span> options &amp;&amp; options.key?(key)<br />          result = options[key]<br />        <span class="keyword">end</span><br />        result<br />      <span class="keyword">end</span><br /><br />      <span class="comment">#helper function for validation</span><br />      <span class="keyword">def</span> validate(options, key)<br />        result = <span class="keyword">true</span><br />        <span class="keyword">if</span> options &amp;&amp; options.key?(key)<br />          result = <span class="keyword">yield</span> options[key]<br />        <span class="keyword">end</span><br />        result<br />      <span class="keyword">end</span><br /><br />      <span class="comment">#converts a string to an integer</span><br />      <span class="comment">#input = the value to convert</span><br />      <span class="comment">#base = the numeric base of the value b,o,d,x</span><br />      <span class="keyword">def</span> convert(input, base)<br />        <span class="keyword">if</span> base<br />          <span class="keyword">if</span> [<span class="string">"b"</span>, <span class="string">"o"</span>, <span class="string">"d"</span>, <span class="string">"x"</span>].include?(base)<br />            input = <span class="string">"0#{base}#{input}"</span><br />            value = Integer(input)<br />          <span class="keyword">else</span><br />            value = Integer(input)<br />          <span class="keyword">end</span><br />        <span class="keyword">else</span><br />          value = Integer(input)<br />        <span class="keyword">end</span><br /><br />        value<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>option() simply checks that options were provided and that they included the requested key.  If so, the matching value is returned.  Otherwise, nil is returned.  validate() is nearly identical, save that it yields the value to a provided block and returns the result of that block.  convert() just reality checks the provided base and calls Integer().</p>
			<p>Finally, here are some simple tests showing the method calls:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />      include HighLine<br />      <span class="comment">#string input using a regexp to validate, returns test as the</span><br />      <span class="comment"># default value</span><br />      p ask( <span class="string">"enter a string, (all lower case)"</span>, :string,<br />             :validate =&gt; <span class="string">/^[a-z]*$/</span>, :default =&gt; <span class="string">"test"</span> )<br />      <span class="comment">#string input using a proc to validate</span><br />      p ask( <span class="string">"enter a string, (between 3 and 6 characters)"</span>, :string,<br />             :validate =&gt; proc { |input| (3..6) === input.length} )<br /><br />      <span class="comment">#integer intput using :within</span><br />      p ask(<span class="string">"enter an integer, (0-10)"</span>, :integer, :within =&gt; 0..10)<br />      <span class="comment">#float input using :above</span><br />      p ask(<span class="string">"enter a float, (&gt; 6)"</span>, :float, :above =&gt; 6)<br /><br />      <span class="comment">#getting a binary value</span><br />      p ask(<span class="string">"enter a binary number"</span>, :integer, :base =&gt; <span class="string">"b"</span>)<br /><br />      <span class="comment">#using a proc to convert the a comma seperated list into an array</span><br />      p ask(<span class="string">"enter a comma seperated list"</span>, proc { |x| x.split(<span class="string">/,/</span>)})<br /><br />      p ask_if(<span class="string">"do you want to continue?"</span>)<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Be sure and look over examples two and six, which use Procs for validation and type.  It's crazy how powerful you can make something when you open it up to extension by Ruby code.</p>
			<p>Ryan Leavengood's solution is class based, instead of using a module.  That allows you to assign the input and output streams, for working with sockets perhaps.  That adds an object construction step though.  In my solution, also class based, I solved that by allowing an option to import top level shortcuts for casual usage.</p>
			<p>Ryan used a custom MockIO object and the ability to redirect his streams to create a nice set of unit tests.  I did the same thing using the standard StringIO library.</p>
			<p>Finally, do look over the list() method in Ryan's code, that provides simple menu selection.  Neat stuff.</p>
			<p>My thanks to Ryan, Mark, Sean, and Dave for jumping right in and working yet another wacky idea of mine.</p>
			<p>Tomorrow Gavin Kistner is back with a second submitted quiz topic!  (That makes all of you who haven't submitted even one yet look really bad.)  It's a fun topic too, guaranteed to be a Barrel of Monkeys...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/139633">Ryan Leavengood</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/139640">Mark Sparshatt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/139971">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/140156">Sean E. McCardell</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/140222">Dave Burt</a></li>
			</ol>
			<p><a href="quiz29_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
