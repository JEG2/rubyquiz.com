<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Method Auto Completion (#110)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Method Auto Completion (#110)</span>
			<p>by Robert Dober</p>
			<p>Command Line Interfaces very often support command abbreviations The purpose of this quiz is to automatically dispatch to methods on unambiguous abbreviations, ask the user for clarification in case of ambiguous abbreviations and raise a NoMethodError in case of an abbreviation that cannot be matched to any command.</p>
			<p>Behavior of other methods defined in a class shall not be altered.</p>
			<p>Be creative about the interface and about behavior. I have OTOH defined a small test suite that makes assumptions about the interface and behavior. But the test suite is only there for your convenience.</p>
			<p>What is said below applies to the test suite and shall in no way inhibit any alternative ideas.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Mine<br />      abbrev :step, :<span class="keyword">next</span>, :stop<br />      abbrev :exit<br />    <span class="keyword">end</span><br /><br />    Mine.new.e  <span class="comment"># should resolve to exit</span><br />    Mine.new.st <span class="comment"># should prompt the user </span><br />    Mine.new.a  <span class="comment"># should still raise a NoMethodError</span><br /><br /></div></div>
			<p>Abbreviation targets themselves are not expanded.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Nine<br />      abbrev  :hash<br />      abbrev  :has<br />    <span class="keyword">end</span><br /><br />    Nine.new.ha  <span class="comment"># =&gt; [:hash, :has] </span><br />    Nine.new.has <span class="comment"># =&gt; NoMethodError</span><br /><br />    <span class="keyword">class</span> Nine<br />      <span class="keyword">def</span> has; 42; <span class="keyword">end</span><br />    <span class="keyword">end</span><br />    Nine.new.has <span class="comment"># =&gt; 42</span><br /><br /></div></div>
			<p>In order to allow for automated testing the test code shall not prompt the user in case of an ambiguous abbreviation but return an array containing all (and only all) possible completions as symbols. Note that the test suite sets the global variable $TESTING to a true value for your convenience.</p>
			<p><a href="http://rubyquiz.com/test-abbrev.rb">Test Suite</a></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>by Robert Dober</p>
			<p>First of all I would like to thank all submitters.</p>
			<p>One of the best features of the Ruby Quiz is it tolerance brings up new ideas so often.</p>
			<p>In order to honor this feature I will first present Daniel Finnie's solution. It just abbreviates all defined methods. This very useful a feature which I will demonstrate after discussion of the code.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Object<br />        <span class="keyword">def</span> method_missing(method, *args, &amp;blk)<br />            <span class="comment"># Gather all possible methods it could be. </span><br />            possibleMethods = <span class="keyword">self</span>.methods.select {|x|<br />              x =~ <span class="string">/^#{Regexp.escape(method.to_s)}/</span><br />            }<br />           <br />            <span class="keyword">case</span> possibleMethods.size<br />            <span class="comment"># No matching method.</span><br />            <span class="keyword">when</span> 0<br />                raise NoMethodError.new(<br />                  <span class="string">"undefined method `#{method}' for "</span> +<br />                  <span class="string">"#{self.inspect}:#{self.class.name}"</span><br />                )<br />           <br />            <span class="comment"># One matching method, call it.</span><br />            <span class="keyword">when</span> 1<br />                method = possibleMethods.first<br />                send(method, *args, &amp;blk)<br />           <br />            <span class="comment"># Multiple possibilities, return an array of the possibilities.</span><br />            <span class="keyword">else</span><br />                <span class="string">"Ambigous abbreviation #{method} -&gt;  "</span> +<br />                <span class="string">"#{ possibleMethods.join("</span>, <span class="string">")}"</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Nothing very complicated there, just define method_missing in Object as a catch all for undefined methods in any object. Than he creates an array of all methods which are legal completions of a potential abbreviation. In case there are none an original NoMethodError is mimicked. In case there is exactly one it is executed via send, please note the (method, *args, &amp;blk) syntax, the &amp;blk part has been forgotten in some solutions but is vital in #method_missing. And eventually if there are more Daniel returned an array of all completions for testing. I will discuss this later.</p>
			<p>I have adapted this to return a message explaining what completions exist for the abbreviation. Why?  Well I just fired up my irb and requested Daniel's solution, see what I got, much less typing for free. Here are some excerpts of my irb session.</p>
			<p class="example">irb(main):001:0&gt; require 'sol2'<br />=&gt; true<br />irb(main):002:0&gt; "a".le<br />=&gt; 1<br />irb(main):003:0&gt; "abba".le<br />=&gt; 4<br />irb(main):004:0&gt; "Hello World".spl <br />=&gt; ["Hello", "World"]<br />irb(main):005:0&gt; "Hi there Daniel".sp<br />=&gt; ["Hi", "there", "Daniel"]<br />irb(main):006:0&gt; "Hi there Daniel".s <br />=&gt; "Ambigous abbreviation s -&gt;  select, slice, sub!, squeeze, send, split,<br />size, strip, succ!, squeeze!, sub, slice!, scan, sort, swapcase, swapcase!,<br />sum, singleton_methods, succ, sort_by, strip!" <br />irb(main):007:0&gt; 12.x<br />NoMethodError: undefined method `x' for 12:Fixnum<br />                from ./sol2.rb:9:in `method_missing'<br />                from (irb):7</p>
			<p>Quite nice as a side product, no? </p>
			<p>Let us turn towards solutions which respected the idea of defining certain abbreviations, being interpreted in Command Line Interfaces for example. It was extremely difficult to chose a solution because most of the solutions had their strong parts. I eventually decided to comment on Donald Ball's solution as it was maybe the most readable solution for myself. I had discussed this with James who favored other solutions for other reasons and I will mention these reasons shortly.  As always there is something in every solution so take your time and read them.</p>
			<p>Ok here is Donald's code - slightly modified again.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'set'</span><br /><br />    <span class="keyword">module</span> AutoComplete<br />        <span class="keyword">module</span> ClassMethods<br />            attr_reader :abbrs<br />            <span class="keyword">def</span> abbrev(*args)<br />                <span class="comment"># TODO abbrs might be better implemented as a sorted set</span><br />                <span class="variable">@abbrs</span> ||= Set.new<br />                <span class="variable">@abbrs</span> += args<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">module</span> ObjectMethods<br />            <span class="keyword">def</span> method_missing(id, *args, &amp;blk)<br />                <span class="comment"># if it is an exact match, there is no corresponding method</span><br />                <span class="comment"># or else it would have been called </span><br />                <span class="keyword">if</span> <span class="keyword">self</span>.<span class="keyword">class</span>.abbrs.include?(id)<br />                    <span class="keyword">super</span><br />                <span class="keyword">end</span><br />                s = id.to_s<br />                len = s.length<br />                <span class="comment"># find all abbreviations which begin with id and have</span><br />                <span class="comment"># active methods </span><br />                matches = <span class="keyword">self</span>.<span class="keyword">class</span>.abbrs.select { |abbr|<br />                  abbr.to_s[0,len] == s &amp;&amp; respond_to?(abbr)<br />                }<br />                <span class="keyword">if</span> matches.length == 0<br />                    <span class="keyword">super</span><br />                <span class="keyword">elsif</span> matches.length == 1<br />                    send(matches[0], *args, &amp;blk)<br />                <span class="keyword">else</span><br />                    matches<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Object<br />        extend AutoComplete::ClassMethods<br />        include AutoComplete::ObjectMethods<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Although this can be done more concisely I eventually started to like the explicit way.</p>
			<p>Lots of little details can be changed and they were in other solutions. Not everybody wanted a NoMethodError thrown in case an abbreviation target was an abbreviation of a different method and was not there.</p>
			<p>Ken Bloom was the first to point out that it was a bad idea to return an array of abbreviations in case of ambiguities. I completely agree, that was only for the test code anyway.</p>
			<p>A great majority of the solutions follow this idea which is certainly a must under some circumstances. I imagine a DSL which is not interactive and where the interpreter has no choice than to throw an Exception, good thinking here.</p>
			<p>Ken's solution has three features noteworthy, first he added the list of possible completions as an attribute of the exception he throws, secondly he just used the abbrev Standard Library Module and thirdly he used #super in #method_missing to raise a NoMethodError. super in that case calls Kernel#method_missing. This took me some time to figure out. I guess the road to Ruby mastery is not answering quizzes but submitting quizzes and understanding the solutions. But you will find some of these features in other solutions too.</p>
			<p>Let us finish the summary with his code, another astonishing example of how much can be done with so little code in Ruby.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'abbrev'</span><br /><br />    <span class="keyword">class</span> AmbiguousExpansionError &lt; StandardError<br />      attr_accessor :candidates<br />      <span class="keyword">def</span> initialize(name,possible_methods)<br />        <span class="keyword">super</span>(<span class="string">"Ambiguous abbreviaton: #{name}\n"</span>+<br />              <span class="string">"Candidates: #{possible_methods.join("</span>, <span class="string">")}"</span>)<br />        <span class="variable">@candidates</span>=possible_methods<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">module</span> Abbreviator<br />      <span class="keyword">def</span> method_missing name,*args<br />        abbrevs=methods.abbrev<br />        <span class="keyword">return</span> send(abbrevs[name.to_s],*args) <span class="keyword">if</span> abbrevs[name.to_s]<br />        meths=abbrevs.reject{|key,value| key!~<span class="string">/^#{name}/</span>}.values.uniq<br />        raise AmbiguousExpansionError.new(name, meths) <span class="keyword">if</span> meths.length&gt;1<br />        <span class="keyword">return</span> <span class="keyword">super</span>(name,*args)<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Many thanx to everyone....</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235271">Krishna Dole</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235273">Ken Bloom</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235275">Ma&euml;l Cl&eacute;rambault</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235284">Michael Fellinger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235312">Phil Darnowsky</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235313">Phil Darnowsky (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235369">Daniel Finnie</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235462">Donald Ball</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/235588">Marcus Crafter</a></li>
			</ol>
			<p><a href="quiz110_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
