<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - SerializableProc (#38)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">SerializableProc (#38)</span>
			<p>I'm a Proc addict.  I use them all over the place in my code.  Because of that, whenever I end up needing persistence and I call Marshal.dump() or YAML.dump() on some object hierarchy, I get to watch everything explode (since Procs cannot be serialized).</p>
			<p>This week's Ruby Quiz is to build a Proc that can be serialized.</p>
			<p>I'm not aware of any possible way to add serialization capabilities to Ruby's core Proc, which rules out a complete solution.  However, even if what we build is a hack, at least one person finds it super useful.</p>
			<p>The task then is to build SerializableProc.  It should support being serialized by Marshal, PStore, and YAML and otherwise behave as close to a Proc as possible.  Put another way, make the following code run for your creation:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">"pstore"</span><br />    require <span class="string">"yaml"</span><br /><br />    code = <span class="comment"># Build your SerializableProc here!</span><br /><br />    File.open(<span class="string">"proc.marshalled"</span>, <span class="string">"w"</span>) { |file| Marshal.dump(code, file) }<br />    code = File.open(<span class="string">"proc.marshalled"</span>) { |file| Marshal.load(file) }<br /><br />    code.call<br /><br />    store = PStore.new(<span class="string">"proc.pstore"</span>)<br />    store.transaction <span class="keyword">do</span><br />        store[<span class="string">"proc"</span>] = code<br />    <span class="keyword">end</span><br />    store.transaction <span class="keyword">do</span><br />        code = store[<span class="string">"proc"</span>]<br />    <span class="keyword">end</span><br /><br />    code.call<br /><br />    File.open(<span class="string">"proc.yaml"</span>, <span class="string">"w"</span>) { |file| YAML.dump(code, file) }<br />    code = File.open(<span class="string">"proc.yaml"</span>) { |file| YAML.load(file) }<br /><br />    code.call<br /></div></div>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>The solutions this time show some interesting differences in approach, so I want to walk through a handful of them below.  The very first solution was from Robin Stocker and that's a fine place to start.  Here's the class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> SerializableProc<br /><br />      <span class="keyword">def</span> initialize( block )<br />        <span class="variable">@block</span> = block<br />        <span class="comment"># Test if block is valid.</span><br />        to_proc<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_proc<br />        <span class="comment"># Raises exception if block isn't valid, e.g. SyntaxError.</span><br />        eval <span class="string">"Proc.new{ #{@block} }"</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> method_missing( *args )<br />        to_proc.send( *args )<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>It can't get much simpler than that.  The main idea here, and in all the solutions, is that we need to capture the source of the Proc.  The source is just a String so we can serialize that with ease and we can always create a new Proc if we have the source.  In other words, Robin's main idea is to go (syntactically) from this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    Proc.new {<br />        puts <span class="string">"Hello world!"</span><br />    }<br /><br /></div></div>
			<p>To this:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    SerializableProc.new <span class="string">%q{<br />        puts "Hello world!"<br />    }</span><br /><br /></div></div>
			<p>In the first pure Ruby version we're building a Proc with the block of code to define the body.  In the second SerializableProc version, we're just passing a String to the constructor that can be used to build a block.  Christian Neukirchen had something very interesting to say about the change:</p>
			<p class="example">Obvious problems of this approach are the lack of closures and editor<br />support (depending on the inverse quality of your editor :P)...</p>
			<p>We'll get back to the lack of closures issue later, but I found the "inverse quality of your editor" claim interesting.  The meaning is that a poor editor may not consider %q{...} equivalent to '...'.  If it doesn't realize a String is being entered, it may continue to syntax highlight the code inside.  Of course, you could always remove the %q whenever you want to see the code highlighting, but that's tedious.</p>
			<p>Getting back to Robin's class, initialize() just stores the String and creates a Proc from it so an Exception will be thrown at construction time if fed invalid code.  The method to_proc() is what builds the Proc object by wrapping the String in "Proc.new { ... }" and calling eval().  Finally, method missing makes SerializableProc behave close to a Proc.  Anytime it sees a method call that isn't initialize() or to_proc(), it creates a Proc object and forwards the message.</p>
			<p>We don't see anything specific to Serialization in Robin's code, because both Marshal (PStore uses Marshal) and YAML can handle a custom class with String instance data.  Like magic, it all just works.</p>
			<p>Robin had a complaint though:</p>
			<p class="example">I imagine my solution is not very fast, as each time a method on the<br />SerializableProc is called, a new Proc object is created.<br /><br />The object could be saved in an instance variable @proc so that speed is<br />only low on the first execution. But that would require the definition of<br />custom dump methods for each Dumper so that it would not attempt to dump<br />@proc.</p>
			<p>My own solution (and others), do cache the Proc and define some custom dump methods.  Let's have a look at how something like that comes out:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> SerializableProc<br />        <span class="keyword">def</span> <span class="keyword">self</span>._load( proc_string )<br />            new(proc_string)<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> initialize( proc_string )<br />            <span class="variable">@code</span> = proc_string<br />            <span class="variable">@proc</span> = <span class="keyword">nil</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> _dump( depth )<br />            <span class="variable">@code</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> method_missing( method, *args )<br />            <span class="keyword">if</span> to_proc.respond_to? method<br />                <span class="variable">@proc</span>.send(method, *args)<br />            <span class="keyword">else</span><br />                <span class="keyword">super</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> to_proc(  )<br />            <span class="keyword">return</span> <span class="variable">@proc</span> <span class="keyword">unless</span> <span class="variable">@proc</span>.nil?<br /><br />            <span class="keyword">if</span> <span class="variable">@code</span> =~ <span class="string">/\A\s*(?:lambda|proc)(?:\s*\{|\s+do).*(?:\}|end)\s*\Z/</span><br />                <span class="variable">@proc</span> = eval <span class="variable">@code</span><br />            <span class="keyword">elsif</span> <span class="variable">@code</span> =~ <span class="string">/\A\s*(?:\{|do).*(?:\}|end)\s*\Z/</span><br />                <span class="variable">@proc</span> = eval <span class="string">"lambda #{@code}"</span><br />            <span class="keyword">else</span><br />                <span class="variable">@proc</span> = eval <span class="string">"lambda { #{@code} }"</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> to_yaml(  )<br />            <span class="variable">@proc</span> = <span class="keyword">nil</span><br />            <span class="keyword">super</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>My initialize() is the same, save that I create a variable to hold the Proc object and I wasn't clever enough to trigger the early Exception when the code is bad.  My to_proc() looks scary but I just try to accept a wider range of Strings, wrapping them in only what they need.  The end result is the same.  Note that any Proc created is cached.  My method_missing() is also very similar.  If the Proc object responds to the method, it is forwarded.  The first line of method_missing() calls to_proc() to ensure we've created one.  After that, it can safely use the @proc variable.</p>
			<p>The _load() class method and _dump() instance method is what it takes to support Marshal.  First, _dump() is expected to return a String that could be used to rebuild the instance.  Then, _load() is passed that String on reload and expected to return the recreated instance.  The String choice is simple in this case, since we're using the source.</p>
			<p>There are multiple ways to support YAML serialization, but I opted for the super simple cheat.  YAML can't serialize a Proc, but it's just a cache that can always be restored.  I just override to_yaml() and clear the cache before handing serialization back to the default method.  My code is unaffected by the Proc's absence and it will recreate it when needed.</p>
			<p>Taking one more step, Dominik Bathon builds the Proc in the constructor and never has to recreate it:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">"delegate"</span><br />    require <span class="string">"yaml"</span><br /><br />    <span class="keyword">class</span> SProc &lt; DelegateClass(Proc)<br /><br />        attr_reader :proc_src<br /><br />        <span class="keyword">def</span> initialize(proc_src)<br />            <span class="keyword">super</span>(eval(<span class="string">"Proc.new { #{proc_src} }"</span>))<br />            <span class="variable">@proc_src</span> = proc_src<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> ==(other)<br />            <span class="variable">@proc_src</span> == other.proc_src <span class="keyword">rescue</span> <span class="keyword">false</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> inspect<br />            <span class="string">"#&lt;SProc: #{@proc_src.inspect}&gt;"</span><br />        <span class="keyword">end</span><br />        <span class="keyword">alias</span> :to_s :inspect<br /><br />        <span class="keyword">def</span> marshal_dump<br />            <span class="variable">@proc_src</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> marshal_load(proc_src)<br />            initialize(proc_src)<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> to_yaml(opts = {})<br />            YAML::quick_emit(<span class="keyword">self</span>.object_id, opts) { |out|<br />                out.map(<span class="string">"!rubyquiz.com,2005/SProc"</span> ) { |map|<br />                    map.add(<span class="string">"proc_src"</span>, <span class="variable">@proc_src</span>)<br />                }<br />            }<br />        <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br />    YAML.add_domain_type(<span class="string">"rubyquiz.com,2005"</span>, <span class="string">"SProc"</span>) { |type, val|<br />        SProc.new(val[<span class="string">"proc_src"</span>])<br />    }<br /><br /></div></div>
			<p>Dominik uses the delegate library, instead of the method_missing() trick.  That's a two step process.  You can see the first step when SPoc is defined to inherit from DelegateClass(Proc), which sets a type for the object so delegate knows which messages to forward.  The second step is the first line of the constructor, which passes the delegate object to the DelegateClass.  That's the instance that will receive forwarded messages.  Dominik also defined a custom ==(), "because that doesn't really work with method_missing/delegate."</p>
			<p>Dominik's code uses a different interface to support Marshal, but does the same thing I did, as you can see.  The YAML support is different.  SProc.to_yaml() spits out a new YAML type, that basically just emits the source.  The code outside of the class adds the YAML support to read this type back in, whenever it is encountered.  Here's what the class looks like when it's resting in a YAML file:</p>
			<p class="example">!rubyquiz.com,2005/SProc <br />proc_src: |2-<br />   |*args|<br />          puts "Hello world"<br />          print "Args: "<br />          p args</p>
			<p>The advantage here is that the YAML export procedure never touches the Proc so it doesn't need to be hidden or removed and rebuilt.</p>
			<p>Florian's solution is also worth mention, though it takes a completely different road to solving the problem.  Time and space don't allow me to recreate and annotate the code here, but Florian described the premise well in the submission message:</p>
			<p class="example">I wrote this a while ago and it works by extracting a proc's origin file <br />name and line number from its .inspect string and using the source code <br />(which usually does not have to be read from disc) -- it works with <br />procs generated in IRB, eval() calls and regular files. It does not work <br />from ruby -e and stuff like "foo".instance_eval "lambda {}".source <br />probably doesn't work either.<br /><br />Usage:<br /><br />   code = lambda { puts "Hello World" }<br />   puts code.source<br />   Marshal.load(Marshal.dump(code)).call<br />   YAML.load(code.to_yaml).call</p>
			<p>The code itself is a fascinating read.  It uses the relatively unknown SCRIPT_LINES__ Hash, has great tricks like overriding eval() to capture that source, and even implements a partial Ruby parser with standard libraries.  I'm telling you, that code reads like a good mystery novel for programmers.  Don't miss it!</p>
			<p>One last point.  I said in the quiz all this is just a hack, no matter how useful it is.  Dave Burt sent a message to Ruby talk along these lines:</p>
			<p class="example">Proc's documentation tells us that "Proc objects are blocks of code that <br />have been bound to a set of local variables." (That is, they are "closures" <br />with "bindings".) Do any of the proposed solutions so far store local <br />variables?<br /><br /># That is, can the following Proc be serialized?<br />  local_var = 42<br />  code = proc { local_var += 1 }  # &lt;= what should that look like in YAML?<br />  code.call  #=&gt; 43</p>
			<p>An excellent point.  These toys we're creating have serious limitations to be sure.  I assume this is the very reason Ruby's Procs cannot be serialized.  Using binding() might make it possible to work around this problem in some instances, but there are clearly some Procs that cannot be cleanly serialized.</p>
			<p>My thanks to all who committed such wonderful code and discussion to this week's quiz.  I know I learned multiple new things and I hope others did too.</p>
			<p>Tomorrow we have a quiz to sample some algorithmic fun...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147703">Robin Stocker</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147706">Florian Groß</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147710">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147751">Christian Neukirchen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147753">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/148082">Ryan Davis</a></li>
			</ol>
			<p><a href="quiz38_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
