<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - MUD Client (#45)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">MUD Client (#45)</span>
			<p>Sy has been searching for a Ruby scriptable MUD client via Ruby Talk and so far, there hasn't been many helpful answers posted.  Let's generate some.</p>
			<p>This week's Ruby Quiz is to create a basic MUD client that must be scriptable in the Ruby programming language.  That's pretty vague, so let me see if I can answer the questions I'm sure at least some of you still have.</p>
			<p>What is a MUD?</p>
			<p>MUD stands for Multi-User Dungeon/Dimension, depending on who you ask.  They are old text-based game servers with many role playing game elements to them.  Here's a fictional example of MUD playing:</p>
			<p class="example">&gt; look<br />Sacred Grove<br /><br />You are standing in the legendary resting place of The Dagger in The Stone.<br />Many have tried to free the mystical blade before, but none were worthy.<br /><br />You can see the Castle of Evil to the west.<br /><br />What's here:<br />  The Dagger in The Stone<br /><br />&gt;look dagger<br />The all-powerful blade begs to be stolen!<br /><br />&gt;get dagger<br />You take the dagger.  (Well, that was easy, wasn't it?)<br /><br />&gt;equip dagger<br />You are now the most dangerous warrior in the kingdom!<br /><br />&gt;west<br />The Gates of Castle of Evil<br /><br />A very big, very black, very evil castle.<br /><br />You can enter the castle to the north, or return to the Sacred Grove in<br />the east.<br /><br />What's here:<br />  Grog, Castle Guardian<br /><br />&gt;north<br />Grog move's in front of the gate and laughs mercilessly at you.<br /><br />&gt;kill grog<br />You slice Grog with the mighty dagger for 5 points of damage.<br />Grog chews off your left ear for 15 points of damage.<br /><br />You swing at Grog and miss.<br />Grog breaks the little finger on your right hand for 10 points of damage.<br /><br />...</p>
			<p>If you would like to find some MUDs to play on, try a listing service like:</p>
			<p><a href="http://www.mudconnect.com/">The MUD Connector</a></p>
			<p>That siteh also has a MUD FAQ that probably answers a lot more questions than this short introduction:</p>
			<p><a href="http://www.mudconnect.com/mudfaq/index.html">The MUD FAQ</a></p>
			<p>What is a MUD client?</p>
			<p>While there are some advanced MUD protocols, the truth is that most of them talk to any Telnet client just fine.  We will focus on that for this quiz, to keep things simple.  Our goal is to create a Ruby scriptable Telnet client, more or less.</p>
			<p>What would we want to script?</p>
			<p>Different people would have different requests I'm sure, but I'll give a few examples.  One idea is that you may want your client to recognize certain commands commands and expand them into many MUD actions:</p>
			<p class="example">&gt; prep for battle<br /><br />&gt; equip Vorpal Sword<br />You ready your weapon of choice.<br /><br />&gt; equip Diamond Armor<br />You protect yourself and still manage to look good.<br /><br />&gt; wear Ring of Invisibility<br />Where did you go?<br /><br />...</p>
			<p>Another interesting possibility is to have functionality where you can execute code when certain output is seen from the server.  Here's an example:</p>
			<p class="example">&gt; kill grog<br />You slash Grog with the dagger for 2 points of damage.<br />Grog disarms you!<br /><br />&gt;get dagger<br />You take up the dagger.<br /><br />You punch Grog in the mouth for 2 points of damage.<br />Grog sings.  You take 25 points of damage to the ear drums.<br /><br />&gt;equip dagger<br />You're now armed and dangerous.<br /><br />You slash Grog with the dagger for 5 points of damage.<br />Grog slugs you for 12 points of damage.<br /><br />...</p>
			<p>Here the idea is that the client noticed you were disarmed and automatically retrieved and equipped your weapon.  This saved you from having to quickly type these commands in the middle of combat.</p>
			<p>There are many other possibilities for scripting, but that gives us a starting point.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Obviously, the first challenge in writing a MUD client is to read messages from the server and write messages to the server.  With many Telnet applications this is a downright trivial challenge, because they generally respond only after you send a command.  MUDs are constantly in motion though, as other characters and the MUD itself trigger events.  This means that the MUD may send you a message in the middle of you typing a command.  Handling that is just a little bit trickier.</p>
			<p>I dealt with the simultaneous read and write issue using two tools:  Threads and character-by-character reading from the terminal.  Writing server messages to the player is the easy part, so I'll explain how I did that first.</p>
			<p>My solution launches a Thread that just continually reads from the server, pushing each line read into a thread-safe queue.  Those lines can later be retrieved by the main event loop as needed.</p>
			<p>Reading from the player is more complicated.  First, you can't just call a blocking method like gets(), because that would halt the writing Thread as well.  (Ruby Threads are in-process.)  Instead, I put the terminal in "raw" mode, so I could read a character at a time from it in a loop.  Sadly, this made my implementation viable for Unix only.</p>
			<p>After each character is read from the keyboard, I need to check if we have pending messages from the server that need to be written to the terminal.  When there are messages waiting though, we can't just print them directly.  Consider that the user might be in the middle of entering a command:</p>
			<p class="example">prompt&gt; look Gr_</p>
			<p>If we just add a server message there, we get a mess:</p>
			<p class="example">prompt&gt; look GrGrog taunts you a second time!_</p>
			<p>We need to separate the server message and then repeat the prompt and partial input:</p>
			<p class="example">prompt&gt; look Gr<br />Grog taunts you a second time!<br /><br />prompt&gt; look Gr_</p>
			<p>That's a little easier for the user to keep up with, but it requires us to keep an input buffer, so we can constantly reprint partial inputs.</p>
			<p>The other challenge with this week's quiz was how to allow the user to script the program.  I used the easiest thing I could think of here.  I decided to filter all input and output into two Proc objects, then make those Procs globally available, and eval() a Ruby configuration file to allow customization.  While I was at it, I placed at much of the client internals in globally accessible variables as possible, to further enhance scriptability.</p>
			<p>That's the plan, let's see how it comes out in actual Ruby code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/local/bin/ruby -w</span><br /><br />    require <span class="string">"thread"</span><br />    require <span class="string">"socket"</span><br />    require <span class="string">"io/wait"</span><br /><br />    <span class="comment"># utility method</span><br />    <span class="keyword">def</span> show_prompt<br />        puts <span class="string">"\r\n"</span><br />        print <span class="string">"#{$prompt} #{$output_buffer}"</span><br />        <span class="global">$stdout</span>.flush<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>In the beginning, I'm just pulling in some standard libraries and declaring a helper method.</p>
			<p>The "thread" library gives me the thread-safe Queue class; "socket" brings in the networking classes; and "io/wait" adds a ready?() method to STDIN I can use to see if characters have been entered by the user.</p>
			<p>The show_prompt() method does exactly as the name implies.  It shows the prompt and any characters the user has entered.  Note that I have to output "\r\n" at the end of each line, since the terminal will be in "raw" mode.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># prepare global (scriptable) data</span><br />    <span class="global">$input_buffer</span>  = Queue.new<br />    <span class="global">$output_buffer</span> = String.new<br /><br />    <span class="global">$end_session</span> = <span class="keyword">false</span><br />    <span class="global">$prompt</span>      = <span class="string">"&gt;"</span><br />    <span class="global">$reader</span>      = lambda { |line| <span class="global">$input_buffer</span> &lt;&lt; line.strip }<br />    <span class="global">$writer</span>      = lambda <span class="keyword">do</span> |buffer|<br />        <span class="global">$server</span>.puts <span class="string">"#{buffer}\r\n"</span><br />        buffer.replace(<span class="string">""</span>)<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># open a connection</span><br />    <span class="keyword">begin</span><br />        host = ARGV.shift || <span class="string">"localhost"</span><br />        port = (ARGV.shift || 61676).to_i<br />        <span class="global">$server</span> = TCPSocket.new(host, port)<br />    <span class="keyword">rescue</span><br />        puts <span class="string">"Unable to open a connection."</span><br />        exit<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># eval() the config file to support scripting</span><br />    config = File.join(ENV[<span class="string">"HOME"</span>], <span class="string">".mud_client_rc"</span>)<br />    <span class="keyword">if</span> File.exists? config<br />        eval(File.read(config))<br />    <span class="keyword">else</span><br />        File.open(config, <span class="string">"w"</span>) { |file| file.puts(&lt;&lt;<span class="string">'END_CONFIG'</span>) }<br />    <span class="comment"># Place any code you would would like to execute inside the Ruby MUD client</span><br />    <span class="comment"># at start-up, in this file.  This file is expected to be valid Ruby syntax.</span><br /><br />    <span class="comment"># Set $prompt to whatever you like as long as it supports to_s().</span><br /><br />    <span class="comment"># You can set $end_session = true to exit the program at any time.</span><br /><br />    <span class="comment"># $reader and $writer hold lambdas that are passes the line read from the</span><br />    <span class="comment"># server and the line read from the user, respectively.</span><br />    <span class="comment">#</span><br />    <span class="comment"># The default $reader is:</span><br />    <span class="comment">#     lambda { |line| $input_buffer &lt;&lt; line.strip }</span><br />    <span class="comment">#</span><br />    <span class="comment"># The default $writer is:</span><br />    <span class="comment">#     lambda do |buffer|</span><br />    <span class="comment">#         $server.puts "#{buffer}\r\n"</span><br />    <span class="comment">#         buffer.replace("")</span><br />    <span class="comment">#     end</span><br /><br />    END_CONFIG<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This section is the scripting support.  First you can see me declaring a bunch of global variables.  The second half of the above code looks for the file "~/.mud_client_rc".  If it exists, it's eval()ed to allow the modification of the global variables.  If it doesn't exist, the file is created with some helpful tips in comment form.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># launch a Thread to read from the server</span><br />    Thread.new(<span class="global">$server</span>) <span class="keyword">do</span> |socket|<br />        <span class="keyword">while</span> line = socket.gets<br />            <span class="global">$reader</span>[line]<br />        <span class="keyword">end</span><br /><br />        puts <span class="string">"Connection closed."</span><br />        exit<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This is the worker Thread described early in my plan.</p>
			<p>It was pointed out on Ruby Talk, that the above line-by-line read will not work with many MUDs.  Many of them print a question, followed by some space (but no newline characters) and expect you to answer the question on the same line.  Supporting that would require a switch from gets() to recvfrom() and then a little code to detect the end of a message, be it a newline or a prompt.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># switch terminal to "raw" mode</span><br />    <span class="global">$terminal_state</span> = <span class="string">`stty -g`</span><br />    system <span class="string">"stty raw -echo"</span><br /><br />    show_prompt<br /><br />    <span class="comment"># main event loop</span><br />    <span class="keyword">until</span> <span class="global">$end_session</span><br />        <span class="keyword">if</span> <span class="global">$stdin</span>.ready?    <span class="comment"># read from user</span><br />            character = <span class="global">$stdin</span>.getc<br />            <span class="keyword">case</span> character<br />            <span class="keyword">when</span> ?\C-c<br />                <span class="keyword">break</span><br />            <span class="keyword">when</span> ?\r, ?\n<br />                <span class="global">$writer</span>[<span class="global">$output_buffer</span>]<br /><br />                show_prompt<br />            <span class="keyword">else</span><br />                <span class="global">$output_buffer</span> &lt;&lt; character<br /><br />                print character.chr<br />                <span class="global">$stdout</span>.flush<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">break</span> <span class="keyword">if</span> <span class="global">$end_session</span><br /><br />        <span class="keyword">unless</span> <span class="global">$input_buffer</span>.empty?   <span class="comment"># read from server</span><br />            puts <span class="string">"\r\n"</span><br />            puts <span class="string">"#{$input_buffer.shift}\r\n"</span> <span class="keyword">until</span> <span class="global">$input_buffer</span>.empty?<br /><br />            show_prompt<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The above is the main event loop described in my plan.  It places the terminal in "raw" mode, so calls to getc() won't require a return to be pressed.  Then it alternately watches for input from the keyboard and input from the server, dealing with each as it comes in.</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="comment"># clean up after ourselves</span><br />    puts <span class="string">"\r\n"</span><br />    <span class="global">$server</span>.close<br />    <span class="keyword">END</span> { system <span class="string">"stty #{$terminal_state}"</span> }<br /><br /></div></div>
			<p>Finally, we clean up our mess before shutting down, closing the connection and returning the terminal to normal.</p>
			<p>Next week's Ruby Quiz comes from inside the halls of NASA, thanks to our own Bill Kleb...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/154914">James Edward Gray II</a></li>
			</ol>
			<p><a href="quiz45_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
