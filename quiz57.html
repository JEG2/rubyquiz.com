<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Weird Numbers (#57)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Weird Numbers (#57)</span>
			<p>by Martin DeMello</p>
			<p>A weird number is defined as a number, n, such that the sum of all its divisors (excluding n itself) is greater than n, but no subset of its divisors sums up to exactly n.</p>
			<p>Write a program to find all the weird numbers less than a given input.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>In reading through all the interesting solutions to this quiz, I noticed two things.  Some solutions were easy to follow and have clever ways to do the work.  Others were very fast, thanks to good optimizations.  Let's examine one of each.</p>
			<p>First, here is Brian Schroeder's complete solution (minus a line I removed):</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/ruby</span><br /><br />    <span class="comment"># Break early version, checking if a number is weird</span><br />    <span class="keyword">def</span> weird_number(n)<br />      sum = 0<br />      subset_sums = Hash.new<br />      subset_sums[0] = <span class="keyword">true</span><br />      <span class="keyword">for</span> d <span class="keyword">in</span> 1...n<br />        <span class="keyword">next</span> <span class="keyword">unless</span> n % d == 0<br />        <span class="comment"># Calculate sum of all divisors</span><br />        sum += d<br />        <span class="comment"># Calculate sums for all subsets</span><br />        subset_sums.keys.each <span class="keyword">do</span> | s |<br />          <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> s + d == n<br />          subset_sums[s + d] = <span class="keyword">true</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      sum &gt; n<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> weird_numbers(range)<br />      range.select { | n | weird_number(n) }<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># Argument parsing</span><br />    raise <span class="string">"Input exactly one number"</span> <span class="keyword">unless</span> ARGV.length == 1<br /><br />    max = ARGV[0].to_i<br /><br />    <span class="comment"># Call it</span><br />    puts weird_numbers(1..max)<br /><br /></div></div>
			<p>This code is not blazing fast, but it's easy to follow and a unique approach.  That's worth a look, I think.</p>
			<p>All the action is in weird_number(), which just returns true or false to indicate if the passed argument is indeed weird.  It begins by initializing an overall sum variable and a Hash for subset_sums.  Notice that 0 is added to subset_sums here.  We will look at that more in a bit.  (All the values of this Hash are set to true, but they are really unused.  Brian just wanted the unique property of Hash keys.)</p>
			<p>The method then walks from 1 to the number, looking for divisors.  When a divisor is found, it's added to the sum and then added to each previous subset_sum (or just 0 on the first occurrence).  Each time a new subset_sum is generated, the total is checked against the number itself.  This allows the code to return an early false, when it finds a match.</p>
			<p>If none of the subset_sums short-circuited the process, a final check is made to ensure that the overall sum exceeds the number.  When it does, a weird number is found.</p>
			<p>The rest of Brian's code is just argument parsing, the search through the range of numbers, and output.  This is very simple stuff.</p>
			<p>I might suggest one change and that would be that printing the numbers as they are found makes the wait a little less tedious, I think.  That's an easy fix.  The last line of code can be switched to:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    (1..max).each { |n| puts n <span class="keyword">if</span> weird_number n }<br /><br /></div></div>
			<p>Brian's code needs over a minute to find the weird numbers from 1 to 10,000.  That's the downside.  If you want to do it faster, you have to find some shortcuts and some submitters found great ones.</p>
			<p>Let's switch gears to Ryan Leavengood's code, which can do the same calculation in under a second.  It starts with a simple helper method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Array<br />      <span class="keyword">def</span> sum<br />        inject(0) <span class="keyword">do</span> |result, i|<br />          result + i<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>I assume the standard Ruby idiom for summation needs little introduction.  Let's move on to the heart of the algorithm:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Integer<br />      <span class="keyword">def</span> weird?<br />        <span class="comment"># No odd numbers are weird within reasonable limits.</span><br />        <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> <span class="keyword">self</span> % 2 == 1<br />        <span class="comment"># A weird number is abundant but not semi-perfect.</span><br />        divisors = calc_divisors<br />        abundance = divisors.sum - 2 * <span class="keyword">self</span><br />        <span class="comment"># First make sure the number is abundant.</span><br />        <span class="keyword">if</span> abundance &gt; 0<br />          <span class="comment"># Now see if the number is semi-perfect. If it is, it isn't weird.</span><br />          <span class="comment"># First thing see if the abundance is in the divisors.</span><br />          <span class="keyword">if</span> divisors.include?(abundance)<br />            <span class="keyword">false</span><br />          <span class="keyword">else</span><br />            <span class="comment"># Now see if any combination sums of divisors yields the abundance.</span><br />            <span class="comment"># We reject any divisors greater than the abundance and reverse the</span><br />            <span class="comment"># result to try and get sums close to the abundance sooner.</span><br />            to_search = divisors.reject{|i| i &gt; abundance}.reverse<br />            sum = to_search.sum<br />            <span class="keyword">if</span> sum == abundance<br />              <span class="keyword">false</span><br />            <span class="keyword">elsif</span> sum &lt; abundance<br />              <span class="keyword">true</span><br />            <span class="keyword">else</span><br />              <span class="keyword">not</span> abundance.sum_in_subset?(to_search)<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">else</span><br />          <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Finding out if a number is weird requires a fair amount of processing.  We need all of the divisors (a lot of work to find on big numbers), subset sums for those divisors, etc.  However, we know some things about weird numbers that can be tested faster.  If less work rules out that process some of the time, it can add up to a big win.</p>
			<p>First of all, there are no known odd weird numbers, so we might as well toss out half of the set right off the bat.  (It's possible there are some very large odd weird numbers, but we would have trouble calculating those anyway.)  Going a step further, there are simple mathematical formulas to determine if a number is abundant or semi-perfect.  We can use those to quickly eliminate many numbers, because weird numbers are always abundant and never semi-perfect.  If we make it that far, we will still have to do the work, but that allows us to skip a good deal of numbers that would have cost us time.</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> calc_divisors<br />        res=[1]<br />        2.upto(Math.sqrt(<span class="keyword">self</span>).floor) <span class="keyword">do</span> |i|<br />          <span class="keyword">if</span> <span class="keyword">self</span> % i == 0<br />            res &lt;&lt; i<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        res.reverse.each <span class="keyword">do</span> |i|<br />          res &lt;&lt; <span class="keyword">self</span> / i<br />        <span class="keyword">end</span><br />        res.uniq<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> sum_in_subset?(a)<br />        <span class="keyword">if</span> <span class="keyword">self</span> &lt; 0<br />          <span class="keyword">false</span><br />        <span class="keyword">elsif</span> a.include?(<span class="keyword">self</span>)<br />          <span class="keyword">true</span><br />        <span class="keyword">else</span><br />          <span class="keyword">if</span> a.length == 1<br />            <span class="keyword">false</span><br />          <span class="keyword">else</span><br />            f = a.first<br />            remaining = a[1..-1]<br />            (<span class="keyword">self</span> - f).sum_in_subset?(remaining) <span class="keyword">or</span> sum_in_subset?(remaining)<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>There are even shortcuts to be found in the work itself.  The biggest is in calculating divisors.  You can just find those between 1 and the square root of the number, then use those to get the rest.  Also, when checking divisor sums, work with the big numbers first, to get totals closer to the actual number that may rule it out quickly.</p>
			<p>Another interesting option, much debated in the quiz solution thread, is the ability to add a cache to the program.  If a weird number is added to the cache when found, future queries can be lightning quick.  Here's a nice bit of code Ryan added just to shut me up about the merits of caching (a noble goal!):</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> WeirdCache<br />      <span class="keyword">def</span> initialize(filename=<span class="string">'.weirdcache'</span>)<br />        <span class="variable">@filename</span> = filename<br />        <span class="keyword">if</span> test(?e, filename)<br />          <span class="variable">@numbers</span> = IO.readlines(filename).map <span class="keyword">do</span> |i|<br />            i.chomp.to_i<br />          <span class="keyword">end</span><br />        <span class="keyword">else</span><br />          <span class="variable">@numbers</span>=[]<br />        <span class="keyword">end</span><br />        <span class="variable">@added</span> = <span class="keyword">false</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> each(&amp;block)<br />        <span class="variable">@numbers</span>.each(&amp;block)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> &lt;&lt;(i)<br />        <span class="variable">@added</span> = <span class="keyword">true</span><br />        <span class="variable">@numbers</span> &lt;&lt; i<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> save<br />        <span class="keyword">if</span> <span class="variable">@added</span><br />          File.open(<span class="variable">@filename</span>, File::RDWR|File::CREAT|File::TRUNC) <span class="keyword">do</span> |file|<br />            file.puts <span class="variable">@numbers</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Nothing tricky there.  We just have a container for numbers with the ability to save it out to disk.  You can see that it is reloaded upon creation.</p>
			<p>Finally, here's the code that ties all this together:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="global">$0</span> == <span class="keyword">__FILE__</span><br />      <span class="keyword">if</span> ARGV.length &lt; 1<br />        puts <span class="string">"Usage: #$0 &lt;upper limit&gt;"</span><br />        exit(1)<br />      <span class="keyword">end</span><br /><br />      puts <span class="string">"Weird numbers up to and including #{ARGV[0]}:"</span><br />      start = Time.now<br />      cache = WeirdCache.new<br />      at_exit {cache.save}<br />      limit = ARGV[0].to_i<br />      i = 69<br />      cache.each <span class="keyword">do</span> |i|<br />        <span class="keyword">if</span> i &lt;= limit<br />          puts i<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      (i+1).upto(limit) <span class="keyword">do</span> |j|<br />        <span class="keyword">if</span> j.weird?<br />          cache &lt;&lt; j<br />          puts j<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />      puts <span class="string">"This took #{Time.now - start} seconds"</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Notice the nice use of variable scoping there.  The variable i is set to 69 before the cache is walked.  (Another optimization.  70 is the first weird number, so we can safely skip anything before that.)  Numbers in the cache will replace i, leaving it holding the highest known weird number.  Then, if the limit is higher than that, the code only needs to calculate from there up.</p>
			<p>I've barely scratched the surface of the solutions here.  There were many more gems hidden in them.  I do recommend browsing the source of the others for picking up new tricks.</p>
			<p>My thanks to all who solved this problem, took my abuse about caching, and especially to Ryan for building what I pestered him for.</p>
			<p>We have two back-to-back quizzes for all you gamers out there coming up next.  First, Kalah anyone?</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168716">Hampton</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168726">Simon Strandgaard</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168718">Rob Leslie</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168729">NILSSON Christer</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168736">Levin Alexander</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168740">Christian Neukirchen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168744">Paolo Capriotti</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168745">Ryan Leavengood</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168752">HornDude77</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168758">Jannis Harder</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168759">Rob Leslie (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168764">Edward Faulkner</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168773">Kenneth Collins</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168798">Ryan Leavengood (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168811">Ryan Leavengood (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168817">Martin DeMello</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168832">Dave Burt</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168834">Kenneth Collins (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168840">Adam Shelly</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168851">Brian Schr&ouml;der</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168859">Simon Kroeger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168888">Mike Harris</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168891">Bob Showalter</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/168971">Moses Hohman</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/169096">Paolo Capriotti (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/169546">Zed Lopez</a></li>
			</ol>
			<p><a href="quiz57_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
