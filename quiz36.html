<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Chess Variants (II) (#36)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Chess Variants (II) (#36)</span>
			<p>If you have not already done so, please read the Chess Variants (I) quiz.  If you would like to work this quiz without working the previous quiz, try adapting one of the Chess Variant (I) solutions submitted by someone else.</p>
			<p>This week's quiz, part two of the Chess Variants quiz, is to modify your chess playing program to support as many of the following variations as possible:</p>
			<p class="example">1.  Fibonacci Chess -- The number of moves a player makes at one time is<br />    determined by the Fibonacci number sequence.  White begins by making one<br />    move, then black responds with one move.  White is then allowed two (1 +<br />    1) moves, then black gets three (1 + 2).  Putting a player in check ends<br />    your turn, even if you have moves remaining.<br /><br />2.  Gun Chess -- Chess is played as normal and the pieces that can be<br />    captured are unaltered, but a capturing piece does not move when taking<br />    an opposing piece.  As long as the move is a legal capture, the opposing<br />    piece is simply removed and the capturing piece in untouched.<br /><br />4.  Madhouse Chess -- When a piece is captured, it is not removed from the<br />    board, but instead moved to the square of the capturing player's choice.<br /><br />3.  Blackhole Chess -- The squares d5 and f5 are considered "blackholes". <br />    Any piece moving onto or over either square vanishes as if it was<br />    captured.  A King moving onto these squares loses the game.<br /><br />5.  Extinction Chess -- Check and checkmate no longer apply.  A player wins<br />    by capturing all of a single piece type of the opposing army (both of<br />    the rooks, for example).  Pawns may promote to Kings and a pawn is<br />    counted as the piece it promotes to.  Promoting your last pawn is a<br />    loss, unless it results in an immediate win.<br /><br />6.  Baseline Chess -- In this variation, the starting position is altered. <br />    All pawns still appear on the usual squares, but players take turns<br />    placing their major pieces along the back rank before play begins. <br />    Castling is not allowed, but the rest of the rules are as normal.<br /><br />7.  Fairy Chess -- Just like normal chess, except the Queen becomes a Fairy.<br />    A Fairy can make the normal moves of a Queen or jump exactly like a<br />    Knight.</p>
			<p>Except as noted above, each variation follows the normal rules of chess from last week's quiz.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Everyone must have worn themselves out on the crazy hard task last week and had no juice left for the easier one this week.</p>
			<p>Since we're implementing these games in terms of some chess library, it's really best if you can restate the game in chess terms.  Let's take Gun Chess, for example.  Pieces don't move when capturing.  That requires me to rewrite my library's move() method, which is too much work because of all the special cases.  Instead, I can just restate the problem:  Whenever a piece captures, it returns to the square it started on.  That is trivial to implement:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># An enhanced chess board for playing Gun Chess.</span><br />    <span class="keyword">class</span> GunChess &lt; Chess::Board<br />        <span class="comment"># Returns a numerical count of all the pieces on the board.</span><br />        <span class="keyword">def</span> count_pieces(  )<br />            find_all { |(square, piece)| piece }.size<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Make standard chess moves, save that capturing pieces do not move.</span><br />        <span class="keyword">def</span> move( from_square, to_square, promote_to = <span class="keyword">nil</span> )<br />            old_count = count_pieces<br /><br />            <span class="keyword">super</span>    <span class="comment"># normal chess move</span><br /><br />            <span class="keyword">if</span> count_pieces &lt; old_count         <span class="comment"># if it was a capture...</span><br />                move(to_square, from_square)    <span class="comment"># move the piece back</span><br />                next_turn                       <span class="comment"># fix the extra turn change</span><br />            <span class="keyword">end</span><br /><br />            <span class="keyword">self</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The overridden move() method is the key here.  It counts the number of pieces on the board (using the helper method count_pieces()), then executes a normal chess move.  Before returning, the pieces are again counted and if the number is less we move the piece back to it's starting square because a capture has just taken place.</p>
			<p>Pop quiz:  Why did I count the pieces, instead of checking for a piece on the to_square (which is probably easier)?</p>
			<p>En-passant.  When capturing en-passant, there is no piece on the to_square, but we can still spot it because the piece count will drop.</p>
			<p>Let's examine another variation.  Fairy Chess is just chess with an upgraded queen.  That should be all the hint you need for an easy implementation.  Subclass Chess::Queen and just add the new moves.</p>
			<p>My library also requires you to update the king's awareness of check slightly.  While it's good to have the ability to change check when needed, this is probably a weakness of my original library.  It could find check using the moves of pieces on the board and then we would just need to add the fairy.</p>
			<p>Anyway, here's what I came up with:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#</span><br />    <span class="comment"># The container for the behavior of a chess fairy.  Fairies are simply</span><br />    <span class="comment"># treated as both a Queen and a Knight.</span><br />    <span class="comment"># </span><br />    <span class="keyword">class</span> Fairy &lt; Chess::Queen<br />        <span class="comment">#</span><br />        <span class="comment"># Returns all the capturing moves for a Fairy on the provided _board_</span><br />        <span class="comment"># at the provided _square_ of the provided _color_.</span><br />        <span class="comment"># </span><br />        <span class="keyword">def</span> <span class="keyword">self</span>.captures( board, square, color )<br />            captures =  Chess::Queen.captures(board, square, color)<br />            captures += Chess::Knight.captures(board, square, color)<br />            captures.sort<br />        <span class="keyword">end</span><br /><br />        <span class="comment">#</span><br />        <span class="comment"># Returns all the non-capturing moves for a Fairy on the provided</span><br />        <span class="comment"># _board_ at the provided _square_ of the provided _color_.</span><br />        <span class="comment"># </span><br />        <span class="keyword">def</span> <span class="keyword">self</span>.moves( board, square, color )<br />            moves =  Chess::Queen.moves(board, square, color)<br />            moves += Chess::Knight.moves(board, square, color)<br />            moves.sort<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># Make the Chess::King aware of the Fairy.</span><br />    <span class="keyword">class</span> FairyAwareKing &lt; Chess::King<br />        <span class="comment"># Enhance in_check? to spot special Fairy moves.</span><br />        <span class="keyword">def</span> <span class="keyword">self</span>.in_check?( bd, sq, col )<br />            <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> Chess::Knight.captures(bd, sq, col).any? <span class="keyword">do</span> |name|<br />                bd[name].is_a?(Fairy)<br />            <span class="keyword">end</span><br /><br />            Chess::King.in_check?( bd, sq, col )<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Make this piece show up as a normal King.</span><br />        <span class="keyword">def</span> to_s(  )<br />            <span class="keyword">if</span> <span class="variable">@color</span> == :white <span class="keyword">then</span> <span class="string">"K"</span> <span class="keyword">else</span> <span class="string">"k"</span> <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># An enhanced chess board for playing Fairy Chess.</span><br />    <span class="keyword">class</span> FairyChess &lt; Chess::Board<br />        <span class="comment"># Setup a normal board, then replace the queens with fairies.</span><br />        <span class="keyword">def</span> setup(  )<br />            <span class="keyword">super</span><br /><br />            <span class="variable">@squares</span>[<span class="string">"d1"</span>] = Fairy.new(<span class="keyword">self</span>, <span class="string">"d1"</span>, :white)<br />            <span class="variable">@squares</span>[<span class="string">"d8"</span>] = Fairy.new(<span class="keyword">self</span>, <span class="string">"d8"</span>, :black)<br />            <span class="variable">@squares</span>[<span class="string">"e1"</span>] = FairyAwareKing.new(<span class="keyword">self</span>, <span class="string">"e1"</span>, :white)<br />            <span class="variable">@squares</span>[<span class="string">"e8"</span>] = FairyAwareKing.new(<span class="keyword">self</span>, <span class="string">"e8"</span>, :black)<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The first class is my fairy.  You can see that my library allows me to access the captures and moves of a queen and a knight.  Adding those together gives us a fairy.</p>
			<p>The second class is my updated king.  It will know when it is in check by a fairy.  Because Fairy is a subclass of Chess::Queen, the old check will already spot Chess::Queen threats from a Fairy.  All I had to add was the Chess::Knight threats.</p>
			<p>Finally, all the new board class has to do is change the initial setup() to include the two new pieces.</p>
			<p>Blackhole Chess is even easier than the above two variations, because it's already stated in easy to implement terms.  You can check to see if a move will cross one of the blackholes, and simply remove the moving piece when it will:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># An enhanced chess board for playing Blackhole Chess.</span><br />    <span class="keyword">class</span> BlackholeChess &lt; Chess::Board<br />        <span class="comment"># </span><br />        <span class="comment"># A general purpose test to see if a _test_ square is between _start_</span><br />        <span class="comment"># and _finish_ squares, on a rank, file or diagonal.</span><br />        <span class="comment"># </span><br />        <span class="keyword">def</span> <span class="keyword">self</span>.between?( start, finish, test )<br />            test_rank,   test_file   = test[1, 1].to_i,   test[0]<br />            start_rank,  start_file  = start[1, 1].to_i,  start[0]<br />            finish_rank, finish_file = finish[1, 1].to_i, finish[0]<br /><br />            ( test_rank == start_rank <span class="keyword">and</span> test_rank == finish_rank <span class="keyword">and</span><br />              test_file &gt;= [start_file, finish_file].min <span class="keyword">and</span><br />              test_file &lt;= [start_file, finish_file].max ) <span class="keyword">or</span><br />            ( test_file == start_file <span class="keyword">and</span> test_file == finish_file <span class="keyword">and</span><br />              test_rank &gt;= [start_rank, finish_rank].min <span class="keyword">and</span><br />              test_rank &lt;= [start_rank, finish_rank].max ) <span class="keyword">or</span><br />            ( (start_file - finish_file).abs ==<br />              (start_rank - finish_rank).abs <span class="keyword">and</span><br />              (start_file - test_file).abs ==<br />              (start_rank - test_rank).abs <span class="keyword">and</span><br />              (test_file - finish_file).abs ==<br />              (test_rank - finish_rank).abs <span class="keyword">and</span><br />              test_file &gt;= [start_file, finish_file].min <span class="keyword">and</span><br />              test_file &lt;= [start_file, finish_file].max <span class="keyword">and</span><br />              test_rank &gt;= [start_rank, finish_rank].min <span class="keyword">and</span><br />              test_rank &lt;= [start_rank, finish_rank].max )<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># End the game if a King goes missing.</span><br />        <span class="keyword">def</span> in_checkmate?( who = <span class="variable">@turn</span> )<br />            <span class="keyword">if</span> find { |(s, p)| p <span class="keyword">and</span> p.color == who <span class="keyword">and</span> p.is_a? Chess::King }<br />                <span class="keyword">super</span><br />            <span class="keyword">else</span><br />                <span class="keyword">true</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Eliminate any piece moving through the blackholes.</span><br />        <span class="keyword">def</span> move( from_square, to_square, promote_to = <span class="keyword">nil</span> )<br />            <span class="keyword">if</span> <span class="keyword">self</span>.<span class="keyword">class</span>.between?(from_square, to_square, <span class="string">"d5"</span>) <span class="keyword">or</span><br />               <span class="keyword">self</span>.<span class="keyword">class</span>.between?(from_square, to_square, <span class="string">"f5"</span>)<br />                <span class="variable">@squares</span>[from_square] = <span class="keyword">nil</span><br />                next_turn<br />            <span class="keyword">else</span><br />                <span class="keyword">super</span><br />            <span class="keyword">end</span><br /><br />            <span class="keyword">self</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Board display with two added blackholes.</span><br />        <span class="keyword">def</span> to_s(  )<br />            <span class="keyword">super</span>.sub( <span class="string">/^(5\s+\|(?:[^|]+\|){3})[^|]+\|([^|]+\|)[^|]+\|/</span>,<br />                       <span class="string">"\\1 * |\\2 * |"</span> )<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The between?() method is my helper for checking if a move will cross over a blackhole.  You can glance down to move() to see it used, just as I described above.  I also have to update in_checkmate?() to recognize a missing king as a losing condition and to_s() to draw the blackholes.</p>
			<p>Fibonacci Chess is the easiest of the four I implemented, as long as your library has something like my next_turn() method to override:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># An enhanced chess board for playing Fibonacci Chess.</span><br />    <span class="keyword">class</span> FibonacciBoard &lt; Chess::Board<br />        <span class="comment"># Setup chess board and initialize move count sequence.</span><br />        <span class="keyword">def</span> initialize(  )<br />            <span class="keyword">super</span><br /><br />            <span class="variable">@fib1</span>  = <span class="keyword">nil</span><br />            <span class="variable">@fib2</span>  = <span class="keyword">nil</span><br />            <span class="variable">@count</span> = 1<br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Advance turn, as players complete moves in the Fibonacci sequence.</span><br />        <span class="keyword">def</span> next_turn(  )<br />            <span class="keyword">if</span> <span class="variable">@fib1</span>.nil?<br />                <span class="variable">@fib1</span> = 1<br />            <span class="keyword">elsif</span> <span class="variable">@fib2</span>.nil?<br />                <span class="variable">@fib2</span> = 2<br />                next_turn <span class="keyword">if</span> in_check?(<span class="variable">@turn</span> == :white ? :black : :white)<br />            <span class="keyword">elsif</span> <span class="variable">@count</span>.zero? <span class="keyword">or</span><br />                  in_check?(<span class="variable">@turn</span> == :white ? :black : :white)<br />                <span class="variable">@fib1</span>, <span class="variable">@fib2</span> = <span class="variable">@fib2</span>, <span class="variable">@fib1</span> + <span class="variable">@fib2</span><br />                <span class="variable">@count</span> = <span class="variable">@fib2</span> - 1<br />            <span class="keyword">else</span><br />                <span class="variable">@count</span> -= 1<br />                <span class="keyword">return</span><br />            <span class="keyword">end</span><br /><br />            <span class="keyword">super</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># Return a String description of the moves remaining.</span><br />        <span class="keyword">def</span> moves_remaining(  )<br />            <span class="keyword">if</span> <span class="variable">@fib1</span>.nil? <span class="keyword">or</span> <span class="variable">@fib2</span>.nil? <span class="keyword">or</span> <span class="variable">@count</span>.zero?<br />                <span class="string">"last move"</span><br />            <span class="keyword">else</span><br />                <span class="string">"#{@count + 1} moves"</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>As you can see, I just changed the traditional one turn flop to roll after Fibonacci N moves or the other player is placed in check, whichever comes first.  The moves_remaining() method was a hook for the interface to give you a move countdown on your turn.</p>
			<p>I didn't implement the other three variations, but I would use the same technique.  Just shift their changes to something as close as possible to chess.</p>
			<p>For example, with Madhouse Chess, you can use a very similar move() override to my Gun Chess example.  Save a dup() of the board, instead of just the piece count, because you'll need access to the soon-to-be captured piece.  Make a normal chess move, then check the before and after piece counts.  If it dropped, prompt the player to select a square and move the captured piece from the old board to the new one at that location.</p>
			<p>Baseline Chess is the easiest variation of all, I think.  With my library, you can just override Chess::Board.setup() to prompt for the starting squares.  Disabling castling is also trivial.  Just make a nonsense move with the king after he's placed to the exact same square he was on.  This makes the king think he has moved and so he won't allow castling moves.</p>
			<p>Extinction Chess is probably the hardest variation (conceptually speaking--it's actually very little code).  The first step is overriding Chess::Board.in_checkmate?() to spot the new win condition.  Just walk the board looking for one of everything.  Then you need to subclass Chess::King as I did in Fairy Chess to shut off check.  Just replace in_check?() with something that always returns false.  Don't forget to override Chess::Board.setup() to swap the old king out for the new one.</p>
			<p>Okay, that's all for chess variants.  Sorry again for the time sink element of this one.  Faster quizzes are coming soon.</p>
			<p>Let me remind everyone that Ruby Quiz is taking a break this weekend to encourage anyone who would like to to compete in the ICFP 05 programming contest.  That contest is a lot of work, but they usually have excellent challenges and I think it's worth the effort.  Ruby has had a small showing in previous years, so we need all the people showing off our favorite language we can get!  Hope to see some familiar names there.</p>
			<p>Ruby Quiz returns a week from tomorrow, when we'll build inference engines...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/145943">James Edward Gray II</a></li>
			</ol>
			<p><a href="quiz36_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
