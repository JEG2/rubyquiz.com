<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - To Excel (#17)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">To Excel (#17)</span>
			<p>Years ago, on a job developing custom reporting software, this was one of the side tasks.  Parsing a report may sound boring, but I urge you to at least download this report and peek inside.  It's a tragic example of database output gone wrong.</p>
			<p><a href="http://www.rubyquiz.com/report.zip">The Report</a></p>
			<p>(I've doctored the report heavily to protect my client, but the spirit of the data remains the same.  I went out of my way to keep the report's little quirks while fudging all the data.)</p>
			<p>My job was literally described as, "I need to take this straight into Excel, no clean up or Wizards required."  Some of you may want to stop reading there and make your own interpretation of that.  Feel free.</p>
			<p>I actually felt uncomfortable with that description and asked to look over an employee's shoulder as they used the report.  I learned a lot from that.  Here's some hints for those that like a little more direction:</p>
			<p class="example">CSV files go "straight into Excel," for all practical purposes.<br /><br />Page headers are not needed and actually get in the way.<br /><br />The "Period" of the report, is useful information though.<br /><br />As are column headers.  This is a Qty/Pounds report.  They also run<br />Qty/Dollars reports.<br /><br />Dashed lines are not helpful in Excel.<br /><br />The report footer is not needed.<br /><br />Excel is a much better tool when actually working with numbers.<br /><br />Everything should fit comfortably into cells.  A single piece of<br />data should not be broken up between two or more cells.<br /><br />However, the employees are very use to this report format and<br />something familiar to them would be preferred.<br /><br />Be warned, this is one of their small reports.  Run in February,<br />it covers only two months of sales.  December reports are many<br />times larger.</p>
			<p>I did a few other things to this report, but that should be plenty for the quiz.</p>
			<p>This report is used daily by over 20 employees.  Think about how much clean up time that adds up to.  They've done it for many years!</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Probably the first question to ask when looking at this quiz is, what makes this report so unfriendly, not just to Excel, but to work with in general?</p>
			<p>1. There's a lot of junk we don't need.  Headers, footers, dashed lines.  All that needs to go, so we can focus on the data.</p>
			<p>2. The data itself isn't pure.  Have a look at these two fragments:</p>
			<p class="example">50,589     358 %%%%  56,652     430 %%%%<br />924,553 704,028   31  1,612K  1,226K</p>
			<p>Those aren't numbers in there.  Yuck.</p>
			<p>3. This report is ALMOST a fixed width file, which would help a lot, but it fails in a few areas:</p>
			<p class="example">TEE_X_101 26-Mar-2002 15:26                        1: GE<br />                                                        <br /><br />                                         ---------------<br />                                         Current  LastYr<br />Part Code       Description               Period  Period<br />--------------- ------------------------ ------- -------<br />  Salesperson  00 NOBODY<br />    Customer  1036 COMPANY 501<br />      SA Sort Code  1.43 WATER DOLLS<br />78-143FS        17/8# SS MODEL                10       0<br />                                         ------- -------<br />      SA Sort Code subtotals                  10       0<br /><br />      SA Sort Code  3.3 REMOTE CONTROL CARS<br />74270           Model 35357-DBL                0       0<br />921137-73       LARGE 19 X 18 X 14            30       0<br />                                         ------- -------<br />      SA Sort Code subtotals                  30       0<br />                                         ------- -------<br />    Customer subtotals                        40       0<br /><br />    Customer  14457 COMPANY 518<br />      SA Sort Code  11.5 KITCHEN SETS<br />943437          19/8# SS MODEL                 0       0<br />                                         ------- -------<br />      SA Sort Code subtotals                   0       0<br />                                         ------- -------<br />    Customer subtotals                         0       0<br /><br />    Customer  1824 COMPANY 529<br />      SA Sort Code  19.4 SLIDES<br />8394            2.5 OZ                         0      20<br />8341            .21 SIZE PLASTIC, NO BATT      0      10<br />18363           .29 SIZE PLASTIC, NO BATT      0      24<br />                                         ------- -------<br />      SA Sort Code subtotals                   0      54<br />                                         ------- -------<br />    Customer subtotals                         0      54</p>
			<p>Use the dashed lines as a guide and you can see how the sub-headers (Salesperson, Customer, and SA Sort Code) don't fit into columns.  Subtotal lines have the same problem.  Also notice that the Description content is allowed to overflow it's column by one character.  That's a mess.</p>
			<p>4. This one is less obvious, but equally real.  The data isn't very useful in this format.  Christian Neukirchen did a nice job of recognizing this and taking steps to correct it.</p>
			<p>Now that we've identified the issues, let's work through them.  When I began playing with a foreign report like this, I do just that:  Play around a bit.  My first script may not end up being the one I keep, but I need to get familiar with the data.  I'll show you what works for me, step by step.</p>
			<p>Whenever I think, "I need to translate this into..." I mentally switch that to:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">while</span> line = ARGF.gets  <span class="comment"># traditional Unix filter</span><br /><br />        print line<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>It may not be much, but it's a start.  Now, let's tackle problem number 1 and jettison the junk.  The majority of it is those silly page headers.  Those should be easy enough to drop.  We stop printing when we enter a header and start up again when we leave.</p>
			<p>I think in patterns, so I would then start looking for a way to spot that I'm entering a header.  I'm leery to anchor against arbitrary text, if I don't have too, so I would like to find something better.  If you're familiar with these page print style reports, you might have a good guess of what comes before that header.  Even if you're not, it pays to look at a foreign document with the "invisible characters" turned on, if your editor can do that.  Here's what a header really looks like:</p>
			<p class="example">      SA Sort Code subtotals                  20       0<br /><br />\f  &lt;-- Look what's hiding here!  A form-feed character.<br />TEE_X_101 26-Mar-2002 15:26                        1: GE<br />                                                        <br /><br />                                         ---------------<br />                                         Current  LastYr<br />Part Code       Description               Period  Period<br />--------------- ------------------------ ------- -------<br />      SA Sort Code  5.207 BUILDING BLOCKS</p>
			<p>That makes spotting the headers easy.  The very first one doesn't have the form-feed, but that's not hard to work around.</p>
			<p>Once we're in a header, the last line is just a solid line of dashes and spaces.  Just be careful to distinguish it from the other dashed line in the header and you can build a solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    header = <span class="keyword">true</span>  <span class="comment"># start in header</span><br />    <span class="keyword">while</span> line = ARGF.gets<br />        <span class="keyword">if</span> header  <span class="comment"># we're inside the header</span><br />            header = <span class="keyword">false</span> <span class="keyword">if</span> line =~ <span class="string">/^-[- ]+-$/</span>  <span class="comment"># watch for the end</span><br />        <span class="keyword">else</span>  <span class="comment"># we're not in the header</span><br />            <span class="keyword">if</span> line =~ <span class="string">/\f/</span>  <span class="comment"># watch for header beginning</span><br />                header = <span class="keyword">true</span><br />                <span class="keyword">next</span><br />            <span class="keyword">end</span><br /><br />            print line<br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>If you run that on the report, you'll see that we did indeed remove all the page headers.  I showed (and even submitted) that version because it's easy to break down and understand, but if all that code bothers you, we can shorten it up:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">while</span> line = ARGF.gets<br />        <span class="comment"># the next line skips all headers</span><br />        <span class="keyword">next</span> <span class="keyword">if</span> (<span class="global">$.</span> == 1 <span class="keyword">or</span> line =~ <span class="string">/\f/</span>) .. line =~ <span class="string">/^-[- ]+-$/</span><br /><br />        print line<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That does exactly the same thing, making use of Ruby's versatile Ranges.  The range acts as a toggle here.  When the first condition becomes true, the Range will evaluate to true (skipping lines with next()) until the second condition becomes true.  Then the process begins again.  My first condition searches for line one of the report or a form-feed character.  The second condition looks for the solid line of dashes.  Again, the code works the same, so you can use whatever you are comfortable with.</p>
			<p>We're not done dropping junk yet!  Let's toss out dashed lines and the report footer.  Both are trivial:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">while</span> line = ARGF.gets<br />        <span class="keyword">next</span> <span class="keyword">if</span> (<span class="global">$.</span> == 1 <span class="keyword">or</span> line =~ <span class="string">/\f/</span>) .. line =~ <span class="string">/^-[- ]+-$/</span><br />        <span class="keyword">next</span> <span class="keyword">if</span> line =~ <span class="string">/--$/</span>  <span class="comment"># skip dashed lines</span><br /><br />        print line<br /><br />        <span class="keyword">break</span> <span class="keyword">if</span> line =~ <span class="string">/^Report Totals/</span>  <span class="comment"># stop with "Report Totals"</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>What's the report look like now?</p>
			<p class="example">  Salesperson  00 NOBODY<br />    Customer  1036 COMPANY 501<br />      SA Sort Code  1.43 WATER DOLLS<br />78-143FS        17/8# SS MODEL                10       0<br />      SA Sort Code subtotals                  10       0<br /><br />      SA Sort Code  3.3 REMOTE CONTROL CARS<br />74270           Model 35357-DBL                0       0<br />921137-73       LARGE 19 X 18 X 14            30       0<br />      SA Sort Code subtotals                  30       0<br />    Customer subtotals                        40       0<br /><br />    Customer  14457 COMPANY 518<br />      SA Sort Code  11.5 KITCHEN SETS<br />943437          19/8# SS MODEL                 0       0<br />      SA Sort Code subtotals                   0       0<br />    Customer subtotals                         0       0</p>
			<p>We're making progress.  It's almost readable.</p>
			<p>There are four types of lines left in this report that we need to deal with.  Yes, I'm sure it's four and not three.  Sub-headers, product sales, subtotals and blank lines.  At this point, I would try to build selectors to handle each of them:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">while</span> line = ARGF.gets<br />        <span class="keyword">next</span> <span class="keyword">if</span> (<span class="global">$.</span> == 1 <span class="keyword">or</span> line =~ <span class="string">/\f/</span>) .. line =~ <span class="string">/^-[- ]+-$/</span><br />        <span class="keyword">next</span> <span class="keyword">if</span> line =~ <span class="string">/--$/</span><br /><br />        <span class="comment"># handle blank lines...</span><br />        <span class="keyword">if</span> line !~ <span class="string">/\S/</span><br />            print <span class="string">"  BLANK:  "</span>, line<br /><br />        <span class="comment"># handle subtotals</span><br />        <span class="keyword">elsif</span> line =~ <span class="string">/^.+?totals(?:\s+(?:-?[\d,]+K?|%+)){12}\s*$/</span>i<br />            print <span class="string">"  TOTAL:  "</span>, line<br /><br />        <span class="comment"># hande product sales</span><br />        <span class="keyword">elsif</span> line =~ <span class="string">/^\S/</span><br />            print <span class="string">"PRODUCT:  "</span>, line<br /><br />        <span class="comment"># handle subheaders</span><br />        <span class="keyword">else</span><br />            print <span class="string">" HEADER:  "</span>, line<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">break</span> <span class="keyword">if</span> line =~ <span class="string">/^Report Totals/</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Uh oh, scary Regexp in there.  Let's break it down:</p>
			<p class="example">^ # the beginning of the line<br />    .+?    # skip some of the beginning looking for...<br />    totals # the word totals (to match subtotals or Report Totals with /i)<br />    (?: # grouping<br />        \s+ # some whitespace<br />        (?: # start group<br />            -?     # an optional minus<br />            [\d,]+ # a comma separated digit sequence<br />            K?     # an optional trailing K<br />            |      # or ...<br />            %+     # a run of % signs<br />        ) # end group<br />    ){12} # end group -- find exactly 12 of those<br />    \s*   # optional trailing whitespace<br />$ # the end of the line</p>
			<p>In short, it's just looking for the word "totals" followed by 12 things that could be numbers in this report.  You really don't even need an expression that complex, in this case, but since the headers can hold arbitrary text (company names) I want to make sure I'm matching what I'm looking for.  Ruby will even let you drop that commented Regexp in your code with /x if you like.</p>
			<p>Notice that I'm being careful to use generic patterns.  For example, I never match Salesperson, Company or SA Sort Code.  What if the company happens to have another report that includes Brokers?  (Trick question.  I know it to be true in this case!)  These patterns will treat that like any other sub-header and just work as expected.</p>
			<p>So does that successfully locate everything?</p>
			<p class="example"> HEADER:    Salesperson  00 NOBODY<br /> HEADER:      Customer  1036 COMPANY 501<br /> HEADER:        SA Sort Code  1.43 WATER DOLLS<br />PRODUCT:  78-143FS        17/8# SS MODEL                10       0<br />  TOTAL:        SA Sort Code subtotals                  10       0<br />  BLANK:  <br /> HEADER:        SA Sort Code  3.3 REMOTE CONTROL CARS<br />PRODUCT:  74270           Model 35357-DBL                0       0<br />PRODUCT:  921137-73       LARGE 19 X 18 X 14            30       0<br />  TOTAL:        SA Sort Code subtotals                  30       0<br />  TOTAL:      Customer subtotals                        40       0<br />  BLANK:  <br /> HEADER:      Customer  14457 COMPANY 518<br /> HEADER:        SA Sort Code  11.5 KITCHEN SETS<br />PRODUCT:  943437          19/8# SS MODEL                 0       0<br />  TOTAL:        SA Sort Code subtotals                   0       0<br />  TOTAL:      Customer subtotals                         0       0</p>
			<p>Sure does.  Now it's easy to just transform that data into CSV, which will fix our not-quite-fixed-width-columns problem:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">"csv"</span><br /><br />    <span class="keyword">while</span> line = ARGF.gets<br />        <span class="keyword">next</span> <span class="keyword">if</span> (<span class="global">$.</span> == 1 <span class="keyword">or</span> line =~ <span class="string">/\f/</span>) .. line =~ <span class="string">/^-[- ]+-$/</span><br />        <span class="keyword">next</span> <span class="keyword">if</span> line =~ <span class="string">/--$/</span><br /><br />        <span class="keyword">if</span> line !~ <span class="string">/\S/</span><br />            puts CSV.generate_line([<span class="string">""</span>])<br /><br />        <span class="keyword">elsif</span> line =~ <span class="string">/^(.+?totals)((?:\s+(?:-?[\d,]+K?|%+)){12})\s*$/</span>i<br />            puts CSV.generate_line([<span class="string">""</span>, <span class="global">$1</span>.lstrip, *<span class="global">$2</span>.split(<span class="string">" "</span>)])<br /><br />        <span class="keyword">elsif</span> line =~ <span class="string">/^(\S+)\s+(.+?)((?:\s+(?:-?[\d,]+K?|%+)){12})\s*$/</span><br />            puts CSV.generate_line([<span class="global">$1</span>, <span class="global">$2</span>, *<span class="global">$3</span>.split(<span class="string">" "</span>)])<br /><br />        <span class="keyword">else</span><br />            puts CSV.generate_line([<span class="string">""</span>, line.strip])<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">break</span> <span class="keyword">if</span> line =~ <span class="string">/^Report Totals/</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>I snuck another nasty Regexp in there didn't I?  Actually, if you look closely, you'll see that it's nearly identical to the other one, save that it also catches product descriptions.  It's just there to help me locate all the parts of the line.  After capturing the parts, I use split() to break them up, strip() to clean them, and let Ruby's CSV handle the rest.</p>
			<p>If you open the CSV output from this in Excel, you'll see that I've just shifted sub-headers and subtotals into the second column.  That pretty much maintains the familiar report format, while eliminating the column breakup issues.</p>
			<p>That's really a lot of the clean up work done already.  The nagging problem is that Excel doesn't consider 1,612K or %%%% numbers.  We can fix the first one easy enough, but what the heck is causing the %%%%s?</p>
			<p>More detective work is needed.</p>
			<p>Those %%%% entries only happen in the small "Pct Var" column, which is four characters wide.  "Var" huh?  Variance maybe?  If you look around a bit, the formula is easy to calculate from a row like this:</p>
			<p class="example">                                         Current  LastYr  Pct<br />Part Code       Description               Period  Period  Var<br />--------------- ------------------------ ------- ------- ----<br /><br />613433          .22 SIZE PLASTIC, NO BATT     65       1 6400</p>
			<p>That looks like (65 - 1) * 100.  That doesn't make much sense though, because we're probably talking about a percentage.  More likely is (65 - 1) / 1 * 100.  You can test that on other rows to prove that it is indeed correct.</p>
			<p>Okay, so why are we getting %%%%s?</p>
			<p class="example">Current  LastYr  Pct <br />    YTD     YTD  Var <br />------- ------- ---- <br /><br />    125       1 %%%% </p>
			<p>(125 - 1) / 1 * 100 = 12400.  That's five characters and we're only allowed four.  It's a column overflow problem.  Our CSV approach has no such limitation, so we can recalculate those numbers and add them to the output.</p>
			<p>Here's a routine to clean up the numbers:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> clean( numbers )<br />        <span class="comment"># turn them back into numbers...</span><br />        numbers.map! <span class="keyword">do</span> |n|<br />            n.gsub!(<span class="string">","</span>, <span class="string">""</span>)  <span class="comment"># drop commas</span><br />            <span class="keyword">if</span> n.sub!(<span class="string">/K$/</span>, <span class="string">""</span>)  <span class="comment"># when there's a K...</span><br />                n.to_i * 1000    <span class="comment"># multiple by 1,000</span><br />            <span class="keyword">elsif</span> n !~ <span class="string">/%/</span><br />                n.to_i           <span class="comment"># numify</span><br />            <span class="keyword">else</span><br />                n<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># recalculate %%%% columns...</span><br />        numbers.each_with_index <span class="keyword">do</span> |n, i|<br />            <span class="keyword">if</span> n.to_s =~ <span class="string">/%/</span><br />                numbers[i] = ( (numbers[i - 2] - numbers[i - 1]) /<br />                               numbers[i - 1].to_f * 100 ).to_i<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        numbers  <span class="comment"># return results</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>To use that, we just call it twice:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">while</span> line = ARGF.gets<br />        <span class="keyword">next</span> <span class="keyword">if</span> (<span class="global">$.</span> == 1 <span class="keyword">or</span> line =~ <span class="string">/\f/</span>) .. line =~ <span class="string">/^-[- ]+-$/</span><br />        <span class="keyword">next</span> <span class="keyword">if</span> line =~ <span class="string">/--$/</span><br /><br />        <span class="keyword">if</span> line !~ <span class="string">/\S/</span><br />            puts CSV.generate_line([<span class="string">""</span>])<br /><br />        <span class="keyword">elsif</span> line =~ <span class="string">/^(.+?totals)((?:\s+(?:-?[\d,]+K?|%+)){12})\s*$/</span>i<br />            <span class="comment"># first call...</span><br />            puts CSV.generate_line([<span class="string">""</span>, <span class="global">$1</span>.lstrip, *clean(<span class="global">$2</span>.split(<span class="string">" "</span>))])<br /><br />        <span class="keyword">elsif</span> line =~ <span class="string">/^(\S+)\s+(.+?)((?:\s+(?:-?[\d,]+K?|%+)){12})\s*$/</span><br />            <span class="comment"># second call...</span><br />            puts CSV.generate_line([<span class="global">$1</span>, <span class="global">$2</span>, *clean(<span class="global">$3</span>.split(<span class="string">" "</span>))])<br /><br />        <span class="keyword">else</span><br />            puts CSV.generate_line([<span class="string">""</span>, line.strip])<br />        <span class="keyword">end</span><br /><br />        <span class="keyword">break</span> <span class="keyword">if</span> line =~ <span class="string">/^Report Totals/</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The rest of my solution (not shown) was boring header parsing, to print out the column labels and the report "Period".  You can follow the link in the sidebar if you want to examine that.</p>
			<p>At this point, we've solved problems 1, 2 and 3 from the beginning of this summary.  I want to talk a little about problem 4, then I promise to end this ridiculously long message.</p>
			<p>Christian Neukirchen's short solution (not shown) does away with sub-header and subtotal lines.  That filter tacks on the Salesperson, Customer and SA Sort Code to each product entry.  This makes all the needed information available on every line.  This is a big win for using Excel's filters, making the report a lot easier to examine and change.</p>
			<p>When I did this project for work, I did the same thing.  However, I put the metadata at the back of the line and left in the sub-headers, subtotals and blanks.  I also added a column to identify each type of line:  Header, total, data or blank.  This gave me all the same benefits as Christian's code has, while keeping the familiar format.  I could filter down to the "data" lines to have nearly identical results.  This feature turned out to be a big hit, drastically increasing company productivity.</p>
			<p>Sorry for sending in a quiz that "looked too much like real work".  I promise, we're back to fun and games tomorrow...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/129315">Jacob Fugal</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/129324">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/129374">Christian Neukirchen</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/129424">Fear Dubh</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/129496">Graham Foster</a></li>
			</ol>
			<p><a href="quiz17_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
