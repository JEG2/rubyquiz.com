<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Pen and Paper (#90)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Pen and Paper (#90)</span>
			<p>by Eric DUMINIL</p>
			<p>Some classmates and I used to play a lot of pen and paper games while sitting  in the last row of the classroom.  My favorite game was this one.</p>
			<p>We had to fill a 5x5 board as fast as possible with numbers from 1 to 25, beginning at a random position and then going from one square to another:</p>
			<p class="example">- jumping over 2 squares when traveling horizontally or vertically<br />- jumping over 1 square when traveling diagonally.</p>
			<p>Here is an example with numbers from 1 to 14 (it would be impossible to keep on filling the board, since 1, 13, and 8 are blocking the way):</p>
			<p class="example"> ------------------- <br />|  .   1   4   .  14|<br />| 10   .   .  11   6|<br />|  3   .   8   2   .|<br />|  .  12   5   .  13|<br />|  9   .   .   .   7|<br /> -------------------</p>
			<p>Here is a completed 5x5 board:</p>
			<p class="example"> ------------------- <br />| 14   1   8  25   2|<br />|  6  23  16   5  22|<br />| 18  10  13  19   9|<br />| 15   4   7  24   3|<br />| 12  20  17  11  21|<br /> ------------------- </p>
			<p>Though this game is impossible with 2x2, 3x3 or 4x4 boards, it appears that NxN boards can be filled when N&gt;4 (or n=1). For example, 6x6:</p>
			<p class="example"> -----------------------  <br />| 33  21  10  32  35  11| <br />| 16  26   5  13  25   6| <br />|  9  31  34  22  30   1| <br />|  4  20  17  27  36  12| <br />| 15  23   8  14  24   7| <br />| 18  28   3  19  29   2| <br /> -----------------------  </p>
			<p>7x7:</p>
			<p class="example"> ---------------------------  <br />| 46  33  26   8  32  35   9| <br />| 17  14   5  37  15   6  38| <br />| 27  22  47  34  25  48  31| <br />| 45  42  16   7  43  36  10| <br />| 18  13   4  21  12   3  39| <br />| 28  23  44  29  24  49  30| <br />|  1  41  19   2  40  20  11| <br /> ---------------------------</p>
			<p>Here comes the quiz!</p>
			<p class="example">- Write a ruby script that fills a board (with a given NxN size)<br />  as fast as possible<br />- Try to fill the biggest board you can with this script, in a<br />  reasonable amount of time (let's say 48 hours minus scripting time)</p>
			<p>You get extra points for:</p>
			<p class="example">- Finding more about this game (name, origin, related articles)<br />- Filling a 5x5 board with only pen and paper<br />- Filling a bigger board with only pen and paper<br />- Finding the worst attempt possible for a given size. For example,<br />  getting stuck after 10 steps on a 5x5 board is pretty bad:<br /><br />  -------------------<br /> |  .   6   3   .   7|<br /> |  .   .   9   .   .|<br /> |  4   1   .   5   2|<br /> |  .   .   .   .   8|<br /> |  .   .  10   .   .|<br />  -------------------<br /> <br />- Filling a board with a cycle pattern, i.e. where you can jump from<br />  the last square to the first square:<br />  <br />   -------------------  <br />  | 22  10   7  23  11| <br />  | 14  19   4   1  16| <br />  |  8  24  12   9   6| <br />  | 21   2  15  20   3| <br />  | 13  18   5  25  17| <br />   ------------------- <br />  <br />   ----------------------- <br />  | 16   9  27  17   8  28|<br />  | 35  12   6  30  13  23|<br />  | 26  18  15  10  19   2|<br />  |  5  31  34  22   7  29|<br />  | 36  11  25   1  14  24|<br />  | 33  21   4  32  20   3|<br />   -----------------------</p>
			<p>I can't wait to look at your solutions!</p>
			<p>I daresay that brute-forcing won't help you much (it took me 98,268,583 attempts and 4 days on a decent computer to fill a 10x10 board) but I don't know many other ways to fill a board.</p>
			<p>Have fun with this quiz.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I enjoyed this problem.  It's fun to play with and gives you a little room to get creative with solving techniques.</p>
			<p>As many people pointed out, this is pretty much the Knight's Tour problem with some unusual Knight jumps.  Most solutions will solve either problem, if you change their idea of neighbor squares.  The good news about that is that we can take advantage of the shortcuts people use to solve that problem.</p>
			<p>The most straightforward solution to this problem is I can dream up is:</p>
			<p class="example">1.  Pick a random starting square<br />2.  Make a list of all the possible moves from the current square<br />3.  If there are no moves, undo the last move and try the next choice<br />    from that square<br />4.  Otherwise, make the first move in the list<br />5.  Goto step 2 until the grid is full</p>
			<p>That's a boring brute force approach, which is the computer science term for "try everything until something works."  When it gets stuck somewhere, it backtracks and tries another jump.  It may, at times, need to backtrack several steps to get back to a place where it could try another move.</p>
			<p>This approach has one major plus and one major minus.  First, the good news:  it will find a solution.  The bad news:  eventually.  Because it has to check every possibility, it can take a good long while to find a path that works.  The bigger the board gets, the more places it has to check.  The waits get longer and longer.</p>
			<p>Now, when solving the Knight's Tour there is a common shortcut that often leads to a solution much faster.  Luckily it works here too.  The idea is that, you should visit the squares with the least choices first.  Those are the places you are likely to run out of options, so getting them out of the way while you still have plenty of open squares increases your chances of making it around the board.  This is called the HC Warnsdorff heuristic, because HC Warnsdorff made the suggestion all the way back in 1823.</p>
			<p>The downside of the HC Warnsdorff heuristic is that is doesn't always work.  Depending on your starting position and which squares you visit first, it can paint itself into a corner.  The problem is more common on certain board sizes, but it does happen.  The upside is, it's so darn quick (because it doesn't backtrack), you can do multiple searches and still be quicker than the brute force approach.  If one attempt fails, just try again.  Most solutions used this approach.</p>
			<p>I found one more corner to cut.  When the quiz mentioned circular solutions, it made me realize you could cheat a bit, if you had one.  If you can go from the end of the line back to the beginning (the definition of a circular solution), you can start anywhere on that path and follow it for the entire length to get all the numbers out.  In truth, these are all the same solution (in my opinion), but the numbers move around so they look different.  It's also lightning quick to shift all the numbers by some offset.  Sadly it can be pretty slow to find a circular solution in the first place.  It's a trade off.</p>
			<p>Another technique, subdividing the grid and piecing together multiple smaller solutions, was used be Elliot Temple.  See the later postings in the quiz thread for a good discussion of that approach.</p>
			<p>OK, let's get to the code already!</p>
			<p>I'm going to so show my solution, just because it takes both shortcuts and I'm very familiar with how it works.  I do not think my solution came out the cleanest though, so definitely go through the others to find some pretty code.  Here's the beginning of my solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby -w</span><br /><br />    require <span class="string">"enumerator"</span><br /><br />    <span class="keyword">class</span> PenAndPaperGame<br />      <span class="keyword">def</span> <span class="keyword">self</span>.circular_solutions<br />        <span class="variable">@circular</span> ||= <span class="keyword">if</span> File.exist?(<span class="string">"circular_solutions.dump"</span>)<br />          File.open(<span class="string">"circular_solutions.dump"</span>) { |file| Marshal.load(file) }<br />        <span class="keyword">else</span><br />          Array.new<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> initialize(size)<br />        <span class="variable">@size</span>    = size<br />        <span class="variable">@largest</span> = <span class="variable">@size</span> * <span class="variable">@size</span><br /><br />        <span class="variable">@grid</span> = Array.new(<span class="variable">@largest</span>)<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>I pull in enumerator here, because I'm addicted.  Can't wait until that library is in the core.</p>
			<p>The class method here is my persistent memory for circular solutions.  It reads the data file, if it exists, and creates an Array of circular solutions at various sizes.  If we don't have the file, a new Array is used.  The ||= caching operator is used for the assignment so we only look the value up once.</p>
			<p>The constructor is trivial and almost every solution had one just like it.  We record the size, figure out what the largest number needs to be, and build the grid Array.</p>
			<p>The Array was a dumb choice on my part.  It somehow made me feel more manly to use a one dimensional Array and deal with the two dimensional indexing.  However, looking at David Trans super clear 45 line solution that uses normal nested Arrays just made me feel dumb.</p>
			<p>Here's the cheat solver I described earlier:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">def</span> solve<br />      <span class="keyword">if</span> <span class="keyword">self</span>.<span class="keyword">class</span>.circular_solutions[<span class="variable">@size</span>].nil?<br />        solve_manually<br />      <span class="keyword">else</span><br />        <span class="variable">@grid</span>  = <span class="keyword">self</span>.<span class="keyword">class</span>.circular_solutions[<span class="variable">@size</span>]<br />        offset = <span class="variable">@grid</span>[rand(<span class="variable">@grid</span>.size)]<br />        <span class="variable">@grid</span>.map! { |n| (n + offset) % <span class="variable">@largest</span> + 1 }<br />        to_s<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>If we haven't yet found a circular solution for this size, a handoff is made to solve_manually().  If we do have one, the else clause is a full (cheating) solution.  We set the grid to the complete solution, choose a random value from the grid (similar to picking a starting square), adjust all the values in the grid by the chosen starting point, and print the results.</p>
			<p>Now that we've looked at my super cheat, let's get to a real solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">def</span> solve_manually<br />      x, y  = rand(<span class="variable">@size</span>), rand(<span class="variable">@size</span>)<br />      count = mark(x, y)<br /><br />      loop <span class="keyword">do</span><br />        to = jumps(x, y)<br />        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">class</span>.new(<span class="variable">@size</span>).solve_manually <span class="keyword">if</span> to.empty?<br /><br />        scores    = rate_jumps(to)<br />        low       = scores.min<br />        next_jump = to.enum_for(:each_with_index).select <span class="keyword">do</span> |jump|<br />          scores[jump.last] == low<br />        <span class="keyword">end</span>.sort_by { rand }.first.first<br /><br />        count = mark(*(next_jump + [count]))<br />        x, y  = next_jump<br /><br />        <span class="keyword">if</span> count &gt; <span class="variable">@largest</span><br />          <span class="keyword">if</span> circular?<br />            <span class="keyword">self</span>.<span class="keyword">class</span>.circular_solutions[<span class="variable">@size</span>] = <span class="variable">@grid</span><br />            File.open(<span class="string">"circular_solutions.dump"</span>, <span class="string">"w"</span>) <span class="keyword">do</span> |file|<br />              Marshal.dump(<span class="keyword">self</span>.<span class="keyword">class</span>.circular_solutions, file)<br />            <span class="keyword">end</span><br />            <span class="keyword">return</span> to_s<br />          <span class="keyword">else</span><br />            puts <span class="string">"Found this solution:"</span><br />            puts to_s<br />            puts <span class="string">"Continuing search for a circular solution..."</span><br />            <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">class</span>.new(<span class="variable">@size</span>).solve_manually<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method looks big, but hopefully it's fairly high level and thus easy enough to read.  First, we select a random starting x and y and mark() that square.  Then we dive into the main solution loop.</p>
			<p>In the loop, we pull all possible jumps() from this square and make sure we have at least one choice.  If we don't, we got stuck and can't find a solution so we just build a new solver, trigger the search for another attempt, and return the results of that.</p>
			<p>If we did get some jumps, we need to score them, based on how many moves we would have from there.  The call to rate_jumps() does this.  Then we pluck out the low score as our target move.  The complicated ball of iterators right after that is just a lazy way to select a random move from all the choices matching the lowest score, which gets slotted into next_jump.</p>
			<p>With a jump selected we mark the new square and move.</p>
			<p>Before we loop(), we check to see if that was the final mark.  When it is, we have a solution, but we want to check if it's a circular solution we could reuse for cheating.  If it is circular, we add it to the collection and update our storage file.  Then we show the solution.  When it's not circular, we go ahead and show it, but trigger another search to see if we can hunt down a circular solution.</p>
			<p>Here's the printing code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">def</span> to_s<br />      width  = <span class="variable">@largest</span>.to_s.size<br />      border = <span class="string">" -"</span> + ([<span class="string">"-"</span> * width] * <span class="variable">@size</span>).join(<span class="string">"-"</span>) + <span class="string">"- \n"</span><br /><br />      border +<br />      <span class="variable">@grid</span>.enum_for(:each_slice, <span class="variable">@size</span>).inject(String.new) <span class="keyword">do</span> |grid, row|<br />        grid + <span class="string">"| "</span> + row.map { |n| n.to_s.center(width) }.join(<span class="string">" "</span>) + <span class="string">" |\n"</span><br />      <span class="keyword">end</span> +<br />      border<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Nothing too tricky here.  We find a cell size and build a border.  Then we print a border, each row, and another border.  The complicated row iteration is just another sign that I used the wrong Array.</p>
			<p>Here are the missing helper methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      private<br /><br />      <span class="keyword">def</span> at(x, y)<br />        x + y * <span class="variable">@size</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> mark(current_x, current_y, mark = 1)<br />        <span class="variable">@grid</span>[at(current_x, current_y)] = mark<br />        mark + 1<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> jumps(from_x, from_y, grid = <span class="variable">@grid</span>)<br />        [ [-3,  0],<br />          [3,   0],<br />          [0,  -3],<br />          [0,   3],<br />          [2,   2],<br />          [-2,  2],<br />          [2,  -2],<br />          [-2, -2] ].map <span class="keyword">do</span> |jump|<br />          [from_x + jump.first, from_y + jump.last]<br />        <span class="keyword">end</span>.select <span class="keyword">do</span> |jump|<br />          jump.all? { |to| (0...<span class="variable">@size</span>).include? to } <span class="keyword">and</span> grid[at(*jump)].nil?<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> rate_jumps(choices)<br />        choices.map { |jump| jumps(*jump).size }<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> circular?<br />        grid                       = <span class="variable">@grid</span>.dup<br />        grid[grid.index(<span class="variable">@largest</span>)] = <span class="keyword">nil</span><br /><br />        x, y = grid.index(1).divmod(<span class="variable">@size</span>).reverse<br /><br />        <span class="keyword">not</span> jumps(x, y, grid).empty?<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The at() method is used to turn x and y coordinates into an index for the one dimensional grid I am using.  mark() will place a number in the indicated square and return the next mark that should be placed.  (This was another odd choice.  I have no idea why I didn't use an instance variable here.)</p>
			<p>The jumps() method uses offset to locate all possible moves from the current location.  It then filters those by removing any out-of-bound indices and any squares that aren't nil.  rate_jumps() is just a thin shell over jumps to count the moves available at each step.</p>
			<p>The circular?() check duplicates the solved grid, knocks the last move back to nil, locates the starting square, and checks to see if the starting square now has one jump (to the only nil square).</p>
			<p>Using those pieces, here's the application code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$PROGRAM_NAME</span><br />      size = ARGV.first &amp;&amp; ARGV.first =~ <span class="string">/\A-s(?:ize)?\Z/</span> ? ARGV.last.to_i : 5<br />      puts PenAndPaperGame.new(size).solve<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>That just reads the size parameter or sets the default to 5 and kicks off the solver process.</p>
			<p>A big thank you to all those who were so creative with their solutions this time around.  You guys taught me how to finish off my own solution.</p>
			<p>Tomorrow we will play around with interactively defining Ruby methods...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208179">Elliot Temple</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208187">Elliot Temple (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208198">Suraj N. Kurapati</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208202">Justin Collins</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208210">Boris Prinz</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208232">Sander Land</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208239">Suraj N. Kurapati (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208254">Robert Evans</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208275">darren kirby</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208295">Daniel Martin</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208300">darren kirby (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208395">Rick DeNatale</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208598">James Edward Gray II</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208650">David Tran</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208663">Mitchell Koch</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208664">Morton Goldberg</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208675">David Tran (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208862">David Tran (3)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/208961">Morton Goldberg (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/209002">John Baylor</a></li>
			</ol>
			<p><a href="quiz90_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
