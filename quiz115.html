<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Mailing List Files (#115)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Mailing List Files (#115)</span>
			<p>The Ruby Talk mailing list archives will show files attached to incoming messages.  However, it's not always easy to get at the data from these files using the archives alone.  The attachments are sometimes displayed in not-too-readable formats:</p>
			<p><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/190780">An Example</a></p>
			<p><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/226884">Another Example</a></p>
			<p>This is tough for those of us who like to play with Ruby Quiz solutions.</p>
			<p>This week's quiz is to write a program that takes a message id number as a command-line argument and "downloads" any attachments from that message.  Assume message ids are for Ruby Talk posts by default, but you may want to provide an option to override that so we can support lists like Ruby Core as well.</p>
			<p>If no path is given, write the attachments to the working directory.  When there is a path, your code should place the files there instead.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I've been playing a little with TMail lately, which is what really inspired this quiz.  I thought that a simple solution to this problem would be to pull the pages down with open-uri and then dump them into TMail and just pull the attachments from that.  It turns out to be a bit harder to do that than I expected, but one solution did follow that path.</p>
			<p>What I love about this plan is the fact that you are just stitching the real tools together.  I like leaning on libraries to get tons of functionality with just a few lines of code.  Apparently, so does Louis J Scoras!  Check out this list of dependencies that kick-starts his solution (I've removed the excellent comments in the code to save space):</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment">#!/usr/bin/env ruby</span><br /><br />    require <span class="string">'action_mailer'</span><br />    require <span class="string">'cgi'</span><br />    require <span class="string">'delegate'</span><br />    require <span class="string">'elif'</span><br />    require <span class="string">'fileutils'</span><br />    require <span class="string">'hpricot'</span><br />    require <span class="string">'open-uri'</span><br />    require <span class="string">'tempfile'</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>Wow.</p>
			<p>Let's start with the standard libraries.  Louis pulls in cgi to handle HTML escapes, delegate to wrap existing classes, fileutils for easy directory creation, open-uri to fetch web pages with, and tempfile for creating temporary files, of course.  That's an impressive set of tools all of which ship with Ruby.</p>
			<p>The other three dependancies are external.  You can get them all as gems.  action_mailer is a component of the Rails framework used to handle email.  Louis doesn't actually use the action_mailer part, just the bundled TMail dependency.  This is a trick for getting TMail as a gem.</p>
			<p>elif is a little library I wrote as a solution to an earlier quiz (#64).  It reads files line by line, but in reverse order.  In other words, you get the last line first, then the next to last line, all the way up to the first line.</p>
			<p>hpricot is a fun little HTML parser from Why the Lucky Stiff.  It has a very unique interface that makes it popular for web scraping usage.</p>
			<p>Now that Louis has imported all the tools he could find, he's ready to do some fetching.  Here's the start of that code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> Quiz115<br />    <span class="keyword">class</span> QuizMail &lt; DelegateClass(TMail::Mail)<br />        <span class="keyword">class</span> &lt;&lt; <span class="keyword">self</span><br />          attr_reader :archive_base_url<br /><br />          <span class="keyword">def</span> archive_base_url<br />            <span class="variable">@archive_base_url</span> ||<br />            <span class="string">"http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/"</span><br />          <span class="keyword">end</span><br /><br />          <span class="keyword">def</span> solutions(quiz_number)<br />            doc = Hpricot(<br />              open(<span class="string">"http://www.rubyquiz.com/quiz#{quiz_number}.html"</span>)<br />            )<br />            (doc<span class="string">/'#links'/</span><span class="string">'li/a'</span>).collect <span class="keyword">do</span> |link|<br />              [CGI.unescapeHTML(link.inner_text), link[<span class="string">'href'</span>]]<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>This object we are examining now is a TMail enhancement, via delegation.  This section has some class methods added for easy usability.  I believe the attr_reader line is actually intended to be attr_writer though, giving you a way to override the base URL.  The reader is defined manually and just defaults to the Ruby Talk mailing list.</p>
			<p>The solutions() method is a neat added feature of the code which will allows you to pass in a Ruby Quiz number in order to fetch all the solution emails for that quiz.  Here you can see some Hpricot parsing.  Its XPath-in-Ruby style syntax is used to pull the solution links off of the quiz page at rubyquiz.com.</p>
			<p>Let's get to the real meat of this class now:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> initialize(mail)<br />        temp_path = to_temp_file(mail)<br />        boundary  = MIME::BoundaryFinder.new(temp_path).find_boundary<br /><br />        <span class="variable">@tmail</span> = TMail::Mail.load(temp_path)<br />        <span class="variable">@tmail</span>.set_content_type <span class="string">'multipart'</span>, <span class="string">'mixed'</span>,<br />          <span class="string">'boundary'</span> =&gt; boundary <span class="keyword">if</span> boundary<br /><br />        <span class="keyword">super</span>(<span class="variable">@tmail</span>)<br />      <span class="keyword">end</span><br /><br />      private<br /><br />      <span class="keyword">def</span> to_temp_file(mail)<br />        temp = Tempfile.new(<span class="string">'qmail'</span>)<br /><br />        temp.write(<span class="keyword">if</span> (Integer(mail) <span class="keyword">rescue</span> <span class="keyword">nil</span>)<br />          url = <span class="keyword">self</span>.<span class="keyword">class</span>.archive_base_url + mail<br />          open(url) { |f| x = cleanse_html f.read }<br />        <span class="keyword">else</span><br />          web = URI.parse(mail).scheme == <span class="string">'http'</span><br />          open(mail) { |m| web ? cleanse_html(m.read) : m.read }<br />        <span class="keyword">end</span>)<br /><br />        temp.close<br />        temp.path<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> cleanse_html(str)<br />        CGI.unescapeHTML(<br />          str.gsub(<span class="string">/\A.*?&lt;div id="header"&gt;/</span>mi,<span class="string">''</span>).gsub(<span class="string">/&lt;[^&gt;]*&gt;/</span>m, <span class="string">''</span>)<br />        )<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>In initialize() the passed mail reference is fetched into a temporary file and a special boundary search is performed, which we will examine in detail in just a moment.  The temp file is then handed off to TMail.  After that a content_type header is synthesized, as long as we found a boundary.</p>
			<p>The actual fetch is made in to_temp_file().  The code that fills the Tempfile is a little tricky there, but all is really does is recognize when we are loading via the web so it can cleanse_html().  That method just strips the tags around the message and unescapes entities.</p>
			<p>Now we need to dig into that boundary problem I sidestepped earlier.  The messages on the web archives are missing their Content-type header and we need to restore it in order to get TMail to accept the message.  With messages that contain attachments, that header should be multipart/mixed.  However, the header also points to a special boundary string that divides the parts of the message.  We have to find that string so we can set it in the header.</p>
			<p>The next class handles that operation:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">module</span> MIME<br />      <span class="keyword">class</span> BoundaryFinder<br />        <span class="keyword">def</span> initialize(file)<br />          <span class="variable">@elif</span> = ::Elif.new(file)<br />          <span class="variable">@in_attachment_headers</span> = <span class="keyword">false</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> find_boundary<br />          <span class="keyword">while</span> line = <span class="variable">@elif</span>.gets<br />            <span class="keyword">if</span> <span class="variable">@in_attachment_headers</span><br />              <span class="keyword">if</span> boundary = look_for_mime_boundary(line)<br />                <span class="keyword">return</span> boundary<br />              <span class="keyword">end</span><br />            <span class="keyword">else</span><br />              look_for_attachment(line)<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />          <span class="keyword">nil</span><br />        <span class="keyword">end</span><br /><br />        private<br /><br />        <span class="keyword">def</span> look_for_attachment line<br />          <span class="keyword">if</span> line =~ <span class="string">/^content-disposition\s*:\s*attachment/</span>i<br />            puts <span class="string">"Found an attachment"</span> <span class="keyword">if</span> <span class="global">$DEBUG</span><br />            <span class="variable">@in_attachment_headers</span> = <span class="keyword">true</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="keyword">def</span> look_for_mime_boundary line<br />          <span class="keyword">unless</span> line =~ <span class="string">/^\S+\s*:\s*/</span> || <span class="comment"># Not a mail header</span><br />                 line =~ <span class="string">/^\s+/</span>           <span class="comment"># Continuation line?</span><br />            puts <span class="string">"I think I found it...#{line}"</span> <span class="keyword">if</span> <span class="global">$DEBUG</span><br />            line.strip.gsub(<span class="string">/^--/</span>, <span class="string">''</span>)<br />          <span class="keyword">else</span><br />            <span class="keyword">nil</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This class is a trivial parser that hunts for the missing boundary.  It uses Elif to read the file backwards, watching for an attachment to come up.  When it detects that it is inside an attachment, it switches modes.  In the new mode if skips over headers and continuation lines until it reaches the first line that doesn't seem to be part of the headers.  That's the boundary.</p>
			<p>The rest of the code just put's these tools to work:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    include Quiz115<br />    include FileUtils<br /><br />    <span class="keyword">def</span> process_mail(mailh, outdir)<br />    <span class="keyword">begin</span><br />      t = QuizMail.new(mailh)<br />      <span class="keyword">if</span> t.has_attachments?<br />        t.attachments.each <span class="keyword">do</span> |attachment|<br />          outpath = File.join(outdir, attachment.original_filename)<br />          puts <span class="string">"\tWriting: #{outpath}"</span><br />          File.open(outpath, <span class="string">'w'</span>) <span class="keyword">do</span> |out|<br />            out.puts attachment.read<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">else</span><br />        outfile = File.join(outdir, <span class="string">'solution.txt'</span>)<br />        File.open(outfile, <span class="string">'w'</span>) {|f| f.write t.body}<br />      <span class="keyword">end</span><br />    <span class="keyword">rescue</span> =&gt; e<br />      puts <span class="string">"Couldn't parse mail correctly. Sorry! (E: #{e})"</span><br />    <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> to_dirname(solver)<br />    solver.downcase.delete(<span class="string">'!#$&amp;*?(){}'</span>).gsub(<span class="string">/\s+/</span>, <span class="string">'_'</span>)<br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>process_mail() builds a QuizMail object out of the passed reference number, then copies the attachments from TMail to files in the indicated directory.  If the message has no attachments, you just get the full message instead.</p>
			<p>to_dirname() is a directory name sanitize for when the code in downloading the solutions from a quiz, as mentioned earlier.</p>
			<p>Here's the application code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    query  = ARGV[0]<br />    outdir = ARGV[1] || <span class="string">'.'</span><br /><br />    <span class="keyword">unless</span> query<br />    <span class="global">$stderr</span>.puts <span class="string">"You must specify either a ruby-talk message id, or a<br />    quiz number (prefixed by 'q')"</span><br />    exit 1<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">if</span> query =~ <span class="string">/\Aq/</span>i<br />    quiz_number = query.sub(<span class="string">/\Aq/</span>i, <span class="string">''</span>)<br />    puts <span class="string">"Fetching all solutions for quiz \##{quiz_number}"</span><br /><br />    QuizMail.solutions(quiz_number).each <span class="keyword">do</span> |solver, url|<br />      puts <span class="string">"Fetching solution from #{solver}."</span><br /><br />      dirname    = to_dirname(solver)<br />      solver_dir = File.join(outdir, dirname)<br /><br />      mkdir_p solver_dir<br />      process_mail(url, solver_dir)<br />    <span class="keyword">end</span><br />    <span class="keyword">else</span><br />    process_mail(query, outdir)<br />    <span class="keyword">end</span><br /><br />    exit 0<br /><br /></div></div>
			<p>This code just pulls in the arguments, and runs them through one of two processes.  If the number is prefixed with a q, the code scrapes rubyquiz.com for that quiz number and pulls all the solutions.  It creates a directory for each solution, then processes each of those messages.  Otherwise, it handles just the individual message.</p>
			<p>My thanks to those who helped me solve this problem for all quiz fans.  We now have an excellent resource to share with people who ask about retrieving the garbled solutions.</p>
			<p>Tomorrow, it's back to fun and games for the quiz, but this time we're on a search for pure strategy...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/240776">brian hammond</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/240777">brian hammond (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/240806">Christoffer Lern&ouml;</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/240921">John Browning</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/241080">Louis J Scoras</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/241092">Petr Kovar</a></li>
			</ol>
			<p><a href="quiz115_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
