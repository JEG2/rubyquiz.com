<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Markov Chains (#74)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Markov Chains (#74)</span>
			<p>This week's Ruby Quiz is about text generation.  That's right, we're going to teach your computer to weave tall tales.</p>
			<p>At its most basic level, a solution might be:</p>
			<p class="example">&gt;&gt; (1..30).map { (("a".."z").to_a + [" "] * 10)[rand(36)] }.join<br />=&gt; "fb mcr hhluesjbhtf swm eehokmi"</p>
			<p>However, let's make our goal to get as close to English looking sentences as possible.  One way you might do this is using a technique called Markov Chains.</p>
			<p>To use Markov Chains, you read some text document(s), making note of which characters commonly follow which characters or which words commonly follow other words (it works for either scale).  Then, when generating text, you just select a character or word to output, based on the characters or words that came before it.</p>
			<p>The number of previous characters or words considered is called the "order" and you can adjust that to try and find a natural feel.  For example, here is some generated text using a second order word chain derived from the Sherlock Holmes novel "The Hound of the Baskervilles" by Arthur Conan Doyle:</p>
			<p class="example">The stars shone cold and bright, while a crushing weight of responsibility<br />from my shoulders. Suddenly my thoughts with sadness. Then on the lady's<br />face. "What can I assist you?"</p>
			<p>If you need text's to prime your program with, I suggest searching Project Gutenberg:</p>
			<p><a href="http://www.gutenberg.org/">Project Gutenberg</a></p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I owe myself a signed copy of my book.  Err, I mean, this was a popular quiz!  That's always great because I have so many wonderful selections of code to talk about in the summary, but it can also be hard because I have so many wonderful selections of code to talk about in the summary.  All of the solutions were terrificly educational, even the ones I don't have time to discuss below.  Everyone who reads this summary is bound by Ruby Law (can be tried in the Ruby Courts) to go look through the rest of the submissions.</p>
			<p>Now that we have the legal formalities out of the way, let's dig into a solution.  Jon Egil Strand wrote in with descriptions of several practical applications for Markov Chains and this bit of code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> MarkovChain<br />      <span class="keyword">def</span> initialize(text)<br />        <span class="variable">@words</span> = Hash.new<br />        wordlist = text.split<br />        wordlist.each_with_index <span class="keyword">do</span> |word, index|<br />          add(word, wordlist[index + 1]) <span class="keyword">if</span> index &lt;= wordlist.size - 2<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> add(word, next_word)<br />        <span class="variable">@words</span>[word] = Hash.new(0) <span class="keyword">if</span> !<span class="variable">@words</span>[word]<br />        <span class="variable">@words</span>[word][next_word] += 1<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> get(word)<br />        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> !<span class="variable">@words</span>[word]<br />        followers = <span class="variable">@words</span>[word]<br />        sum = followers.inject(0) {|sum,kv| sum += kv[1]}<br />        random = rand(sum)+1<br />        partial_sum = 0<br />        next_word = followers.find <span class="keyword">do</span> |word, count|<br />          partial_sum += count<br />          partial_sum &gt;= random<br />        <span class="keyword">end</span>.first<br />        next_word<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    mc = MarkovChain.new(<br />      File.read(<span class="string">"Agatha Christie - The Mysterious Affair at Styles.txt"</span>)<br />    )<br /><br />    sentence = <span class="string">""</span><br />    word = <span class="string">"Murder"</span><br />    <span class="keyword">until</span> sentence.count(<span class="string">"."</span>) == 4<br />      sentence &lt;&lt; word &lt;&lt; <span class="string">" "</span><br />      word = mc.get(word)<br />    <span class="keyword">end</span><br />    puts sentence &lt;&lt; <span class="string">"\n\n"</span><br /><br /></div></div>
			<p>Let's examine the MarkovChain object first, as it is where the real work is done.  In initialize() you can see that a Hash is created, the text is split() on whitespace, and then each pair of adjacent words are passed to the add() method.</p>
			<p>In add(), the first word is used to key the Hash we saw created in initialize(), adding a frequency Hash as the value the first time a new word is seen.  The following word is then added to the counts in the frequency Hash.  Obviously, we are just working with a first order chain here, since we only ever track the word that immediately preceded the current word.</p>
			<p>The real work is done in the get() method, where we pass the current word and are returned a reasonable follow-up word.  The word is checked to make sure we have seen it, then the frequency Hash is pulled for that word.  Next, the frequencies of all possible follow-up words are summed and a random selection is made in that range.  Finally, the frequency Hash is walked one last time, and the random number used to select and return the indicated word.</p>
			<p>The rest of the solution code follows the class.  First a MarkovChain is constructed from an Agatha Christie novel.  Then a variable is prepared to hold the output (called sentence, but it will actually hold a few sentences) and a starting word appropriate to the content is hand-picked.  The script then loops, using get() to choose words one by one until it has collected at least four sentences of output, which are dumped to the user before we exit.</p>
			<p>The above code does not deal with punctuation at all, which can be both good and bad.  The upside is that you will see some natural punctuation, like commas and they will generally even appear in reasonable places since they are attached to the word from the original text.  The downside is that you may get something like an opening quote, but never get the closing quote.  Sometimes it works out naturally, and sometimes it doesn't.</p>
			<p>Now, in this whole discussion, I was loosely throwing around this "frequency Hash" term that I never bothered to define.  Allow me to fix that now.  The frequency Hash is obviously just a Hash with keys being the words that can follow and values being a count of how many times that word was seen to follow in the original text.  Dominik Bathon included excellent examples of how this looks in his submission email.  Using Dominik's trivial example text of:</p>
			<p class="example">q s a w s. a s w q s. q w s a a w. s q a w s.</p>
			<p>Jon's code will produce a Hash tree that looks like:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    { <span class="string">"w."</span> =&gt; {<span class="string">"s"</span>  =&gt; 1},<br />      <span class="string">"w"</span>  =&gt; {<span class="string">"s."</span> =&gt; 2, <span class="string">"q"</span> =&gt; 1, <span class="string">"s"</span>  =&gt; 1},<br />      <span class="string">"a"</span>  =&gt; {<span class="string">"w."</span> =&gt; 1, <span class="string">"a"</span> =&gt; 1, <span class="string">"w"</span>  =&gt; 2, <span class="string">"s"</span> =&gt; 1},<br />      <span class="string">"s."</span> =&gt; {<span class="string">"a"</span>  =&gt; 1, <span class="string">"q"</span> =&gt; 1},<br />      <span class="string">"q"</span>  =&gt; {<span class="string">"a"</span>  =&gt; 1, <span class="string">"w"</span> =&gt; 1, <span class="string">"s."</span> =&gt; 1, <span class="string">"s"</span> =&gt; 1},<br />      <span class="string">"s"</span>  =&gt; {<span class="string">"w"</span>  =&gt; 1, <span class="string">"a"</span> =&gt; 2, <span class="string">"q"</span>  =&gt; 1} }<br /><br /></div></div>
			<p>You can really see how punctuation changes things there, since "w" and "w." are different words.</p>
			<p>The right hand side of that (the values of the top level Hash), shows the frequency breakdown.  "w" occurs 2 times after an "a", but "s" occurs just once following the same word.</p>
			<p>Domink then went on to show how a person might change that representation.  Here are two significant changes:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    { <span class="string">"w"</span> =&gt; { <span class="string">"q"</span> =&gt; [<span class="string">"s"</span>],<br />               <span class="string">"s"</span> =&gt; [<span class="string">"."</span>, <span class="string">"a"</span>, <span class="string">"."</span>] },<br />      <span class="string">"a"</span> =&gt; { <span class="string">"a"</span> =&gt; [<span class="string">"w"</span>],<br />               <span class="string">"w"</span> =&gt; [<span class="string">"s"</span>, <span class="string">"."</span>, <span class="string">"s"</span>],<br />               <span class="string">"s"</span> =&gt; [<span class="string">"w"</span>] },<br />      <span class="string">"q"</span> =&gt; { <span class="string">"a"</span> =&gt; [<span class="string">"w"</span>],<br />               <span class="string">"w"</span> =&gt; [<span class="string">"s"</span>],<br />               <span class="string">"s"</span> =&gt; [<span class="string">"a"</span>, <span class="string">"."</span>] },<br />      <span class="string">"s"</span> =&gt; { <span class="string">"w"</span> =&gt; [<span class="string">"q"</span>],<br />               <span class="string">"a"</span> =&gt; [<span class="string">"w"</span>, <span class="string">"a"</span>],<br />               <span class="string">"q"</span> =&gt; [<span class="string">"a"</span>] } }<br /><br /></div></div>
			<p>Note that punctuation is handled differently here, because I'm now using Dominik's examples and his code used a different implementation.  In Dominik's code, periods, exclamation marks, and question marks are treated as their own words and most other punctuation is ignored.</p>
			<p>Now try to ignore the tree structure of the above for now and just focus again on that right-hand side.  This is still just a frequency Hash, though it is now disguised as an Array.  If you have the Hash {"a" =&gt; 1, "." =&gt; 2}, you could select the next word just as we saw Jon do earlier.  However, the Array [".", "a", "."] represents the same data and we can select a word just by randomly selecting a member.  The duplication ensures that the odds are still the same.</p>
			<p>The other obvious change is that we are now taking into account an order for the chain.  This works out pretty naturally, just by nesting Hashes to the depth of the order.  We then walk the tree to find out what comes next.  For example, if we have a "w" followed by a "a", we get to our now familiar Array of choices for the next word [".", "a", "."].</p>
			<p>But wait, Dominik goes one step further:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    { [<span class="string">"q"</span>, <span class="string">"a"</span>] =&gt; [<span class="string">"w"</span>],<br />      [<span class="string">"q"</span>, <span class="string">"w"</span>] =&gt; [<span class="string">"s"</span>],<br />      [<span class="string">"s"</span>, <span class="string">"q"</span>] =&gt; [<span class="string">"a"</span>],<br />      [<span class="string">"w"</span>, <span class="string">"q"</span>] =&gt; [<span class="string">"s"</span>],<br />      [<span class="string">"s"</span>, <span class="string">"w"</span>] =&gt; [<span class="string">"q"</span>],<br />      [<span class="string">"a"</span>, <span class="string">"s"</span>] =&gt; [<span class="string">"w"</span>],<br />      [<span class="string">"w"</span>, <span class="string">"s"</span>] =&gt; [<span class="string">"."</span>, <span class="string">"a"</span>, <span class="string">"."</span>],<br />      [<span class="string">"s"</span>, <span class="string">"a"</span>] =&gt; [<span class="string">"w"</span>, <span class="string">"a"</span>],<br />      [<span class="string">"q"</span>, <span class="string">"s"</span>] =&gt; [<span class="string">"a"</span>, <span class="string">"."</span>],<br />      [<span class="string">"a"</span>, <span class="string">"a"</span>] =&gt; [<span class="string">"w"</span>],<br />      [<span class="string">"a"</span>, <span class="string">"w"</span>] =&gt; [<span class="string">"s"</span>, <span class="string">"."</span>, <span class="string">"s"</span>] }<br /><br /></div></div>
			<p>This is exactly the same as the tree above, except that the Hash tree of preceding words has been flattened into a single Array of words, used to key the Hash.  This is possible because Ruby's Arrays are hashable.  Isn't that handy?  The gain is speed.  Since we only have to make one Hash lookup to get to the frequency Array, it works a little quicker.</p>
			<p>Now that we have gone through the trouble of understanding Dominik's data structure, the code should be a breeze.  Let's take a look:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="global">$0</span> == <span class="keyword">__FILE__</span><br />      order = 2<br />      n = 10<br />      <span class="keyword">while</span> ARGV[0] =~ <span class="string">/\A-([on])([1-9]\d*)\z/</span><br />        <span class="keyword">if</span> <span class="global">$1</span> == <span class="string">"o"</span><br />          order = Integer(<span class="global">$2</span>)<br />        <span class="keyword">else</span><br />          n = Integer(<span class="global">$2</span>)<br />        <span class="keyword">end</span><br />        ARGV.shift<br />      <span class="keyword">end</span><br />      mc = MarkovChainer.new(order)<br />      mc.add_text(ARGF.read)<br />      n.times {<br />        puts mc.generate_sentence<br />      }<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This is the last little bit of Dominik's code, but it kicks the process off.  You can see that it selects defaults for the order and number of sentences to produce, but then updates them from the provided command-line options.  Next, a MarkovChainer is built and fed the combined contents of ARGF.  Finally, the requested number of sentences are generated with a simple method call repeated inside of an iterator.</p>
			<p>Let's look at the pieces of MarkovChainer used to read text:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> MarkovChainer<br />      attr_reader :order<br />      <span class="keyword">def</span> initialize(order)<br />        <span class="variable">@order</span> = order<br />        <span class="variable">@beginnings</span> = []<br />        <span class="variable">@freq</span> = {}<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> add_text(text)<br />        <span class="comment"># make sure each paragraph ends with some sentence terminator</span><br />        text.gsub!(<span class="string">/\n\s*\n/</span>m, <span class="string">"."</span>)<br />        text &lt;&lt; <span class="string">"."</span><br />        seps = <span class="string">/([.!?])/</span><br />        sentence = <span class="string">""</span><br />        text.split(seps).each { |p|<br />          <span class="keyword">if</span> seps =~ p<br />            add_sentence(sentence, p)<br />            sentence = <span class="string">""</span><br />          <span class="keyword">else</span><br />            sentence = p<br />          <span class="keyword">end</span><br />        }<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br />      private<br /><br />      <span class="keyword">def</span> add_sentence(str, terminator)<br />        words = str.scan(<span class="string">/[\w']+/</span>)<br />        <span class="keyword">return</span> <span class="keyword">unless</span> words.size &gt; order <span class="comment"># ignore short sentences</span><br />        words &lt;&lt; terminator<br />        buf = []<br />        words.each { |w|<br />          buf &lt;&lt; w<br />          <span class="keyword">if</span> buf.size == order + 1<br />            (<span class="variable">@freq</span>[buf[0..-2]] ||= []) &lt;&lt; buf[-1]<br />            buf.shift<br />          <span class="keyword">end</span><br />        }<br />        <span class="variable">@beginnings</span> &lt;&lt; words[0, order]<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The initialize() method shows a familiar setup, save that new Array we haven't talked about yet.  We will tackle that when it comes up.</p>
			<p>add_text() isn't much more complicated.  It ensures the document it is dealing with contains complete sentences, then breaks it on the end-of-line punctuation characters I mentioned earlier.  The trick here is that you need to notice the parentheses in the Regexp handed to split().  Ordinarily, split() will remove the match used to divide the chunks, but when the match includes capturing parentheses, those captures are returned as items of their own.  So, the final iterator of the method reads the sentence then the punctuation that followed it and hands those over to add_sentence().</p>
			<p>add_sentence() is where the data structure we analyzed earlier gets built.  The sentence is separated into words, including the end-of-line punctuation don't forget.  Then those words are pushed into a buffer one at a time.  When the buffer has enough words stored to satisfy the order, it starts filling the Hash of frequency Arrays for this chain.  Finally, we see what that extra Array is used for.  It holds beginnings, or groups of words used to start a sentence (when we wouldn't have previous words to check frequencies for).  You can see those being stored in the last line of this method.</p>
			<p>Here's the other side of that class, text writing:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> MarkovChainer<br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> generate_sentence<br />        res = <span class="variable">@beginnings</span>[rand(<span class="variable">@beginnings</span>.size)]<br />        loop {<br />          <span class="keyword">unless</span> nw = next_word_for(res[-order, order])<br />            <span class="keyword">return</span> res[0..-2].join(<span class="string">" "</span>) + res.last<br />          <span class="keyword">end</span><br />          res &lt;&lt; nw<br />        }<br />      <span class="keyword">end</span><br /><br />      private<br /><br />      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> next_word_for(words)<br />        arr = <span class="variable">@freq</span>[words]<br />        arr &amp;&amp; arr[rand(arr.size)]<br />      <span class="keyword">end</span><br /><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Not much here, as you can see.  With the data structure built, the problem practically solves itself.</p>
			<p>The interface method, generate_sentence(), starts by selecting a beginning from the Array of possible beginnings.  It then iterates using next_word_for() to grab follow-up words until a nil is returned (after an end-of-line character, since we didn't give follow-ups for them).  Whatever we have at that point becomes the returned sentence, after adding a sprinkle of whitespace between the words.</p>
			<p>The helper method, next_word_for(), just does the lookup from the frequency Array.  Don't let that fancy last line throw you, it's just a shortcut to keep from calling []() when arr is nil.</p>
			<p>A huge thank you to all who came out of hiding to get the quiz rolling again.  I just knew I would find a problem you couldn't resist eventually.</p>
			<p>The response to the Ruby Quiz contest has been strong and tomorrow we will start our run of contributed quizzes with an offering from Pat Eyler...</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188283">Albert Vernon Smith</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188285">Joern Dinkla</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188293">Ross Bamford</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188294">Jon Egil Strand</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188295">Himadri Choudhury</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188309">Logan Capaldo</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188310">Simon Kroeger</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188319">Barry Dmytro</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188322">Brian Ardrey</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188358">Tom Rauchenwald</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188364">Matthew Moss</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188369">Shane Emmons</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188370">Pedro Suarez</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188420">Dominik Bathon</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188439">joey</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188448">Shane Emmons (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188471">Joern Dinkla (2)</a></li>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/188522">chuck sonic</a></li>
				<li><a href="http://groups.google.com/group/comp.lang.ruby/msg/29bceabf5b8ce84b">Sergey Volkov</a></li>
			</ol>
			<p><a href="quiz74_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
