<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Ruby Quiz - Yahtzee (#19)</title>
	<link rel="stylesheet" type="text/css" href="quiz.css" />
	<link rel="stylesheet" type="text/css" href="print.css" media="print" />
</head><body>
	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Yahtzee (#19)</span>
			<p>In my family, we use games to spend time together and even learn from.  When the kids in the family need help spelling, we get the Scrabble board out.  When you're learning to count, we break out Yahtzee.  Yahtzee remains a favorite for many of us adults because it's fast and we can talk over it.  We spend many evenings rolling the dice and keeping score.</p>
			<p>This week's quiz is to make a program that plays Yahtzee.</p>
			<p>The rules of Yahtzee are not complex.  On your turn, you roll five dice.  If desired, you make pick up any number of them and re-roll.  You're allowed up to two re-rolls or three total rolls counting the original toss.  When you're finished rolling, you score the roll in any "category" you like.</p>
			<p>A game of Yahtzee is 13 turns.  Sometimes players play alone to see how good of a score they can get.  Other times, they play against others:  High score wins.</p>
			<p>Yahtzee has thirteen categories where you can place a score, one for each roll.  The categories are divided into two sections.  The "top" section (located on the top half of the score card) contains:  Ones, Twos, Threes, Fours, Fives and Sixes.  To score in those categories, you simply count the total of all dice matching the name.</p>
			<p>The "bottom" categories are more varied.  There is a Three of a Kind and Four of a Kind.  To score in either of those you need the indicated three or four of any one number shown on the dice.  As long as you have the needed duplicates, you score the total of all your dice.</p>
			<p>There is a category for a Full House, worth 25 points.  This requires two of one number and three of another to be shown on the dice.</p>
			<p>There's also Small Straight and Large Straight.  They require a sequence to be shown on the dice.  For example, 2, 3, 4 and 5 can be a Small Straight.  The Small Straight requires a run of at least four dice and is worth 30 points.  Large Straight requires all five dice to be in order and is worth 40 points.</p>
			<p>The supreme category is the Yahtzee.  This requires a five of a kind roll.  All dice must show the same number.  When you have that, you can score 50 points here.</p>
			<p>If you roll more than one Yahtzee in a game, after scoring the first one for 50, the subsequent Yahtzees give you a 100 bonus point each.  You must still count these Yahtzees somewhere; either in the top for the appropriate number or if that is full, it can be used as a wildcard for any category in the bottom, scored normally.</p>
			<p>Finally, there's is a catch-all Chance category.  You can score any roll here simply by totaling all the dice.</p>
			<p>You must score each and every roll in exactly one category.  This means it is common to "scratch" categories late in the game, when you cannot get the right combination.  A scratch is worth zero points.</p>
			<p>When the categories are filled in, the top and bottom are totaled separately.  If the top is greater than or equal to 63 points, you add in a 35 point "bonus".  The two section totals are then combined to give the overall score.</p>
			<p>That's all there is to Yahtzee, but your program can be more complicated if you like.  Those looking for an bigger challenge should consider these additions:</p>
			<p class="example">1.  Add a computer AI that takes turns with the player.  The more<br />    intelligently it plays the better.<br /><br />2.  My favorite variation of Yahtzee is Triple Yahtzee.  It's played just<br />    like normal Yahtzee, except that you fill in three columns of categories<br />    at once, placing scores in any column you please.  At the end of the<br />    game, the second column's score is doubled and the third is tripled,<br />    then all three columns are totaled to create the overall score.  Add<br />    support for Triple Yahtzee.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Well, there wasn't any discussion or submissions this week, save my own.  Guess that means you'll have to suffer through my code this week.</p>
			<p>There are really two aspects to a game of Yahtzee:  Dice rolling and score keeping.  With dice rolling, you need to be able to handle a roll of multiple dice and re-rolls of selected dice.  You'll need to be able to display and examine this roll, of course.  Then, you'll need to be able to sum all the dice or just certain dice.</p>
			<p>Finally, when it's time to score those rolls, you need some way to match die against patterns.  Three of a Kind, Four of a Kind, Full House and Yahtzee are repetition patterns.  You're looking for any number to appear on the dice a set number of times.  With Full House, you're actually looking for two different dice to appear a different number of times.</p>
			<p>Small Straight and Large Straight need another form of pattern matching:  Sequence patterns.  Here you're searching for a run on the dice of a specified length, but the actual numbers in the run don't matter.</p>
			<p>Here's the class I coded up to cover those needs:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Namespace for all things Yahtzee.</span><br />    <span class="keyword">module</span> Yahtzee<br />        <span class="comment"># An object for managing the rolls of a Yahtzee game.</span><br />        <span class="keyword">class</span> Roll<br />            <span class="comment">#</span><br />            <span class="comment"># Create an instance of Roll.  Methods can then be used the</span><br />            <span class="comment"># examine the results of the roll and re-roll dice.</span><br />            <span class="comment">#</span><br />            <span class="keyword">def</span> initialize(  )<br />                <span class="variable">@dice</span> = Array.new(5) { rand(6) + 1 }<br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Examine the individual dice of a Roll.</span><br />            <span class="keyword">def</span> []( index )<br />                <span class="variable">@dice</span>[index]<br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Count occurrences of a set of pips.</span><br />            <span class="keyword">def</span> count( *pips )<br />                <span class="variable">@dice</span>.inject(0) <span class="keyword">do</span> |total, die|<br />                    <span class="keyword">if</span> pips.include?(die) <span class="keyword">then</span> total + 1 <span class="keyword">else</span> total <span class="keyword">end</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Add all occurrences of a set of pips, or all the dice.</span><br />            <span class="keyword">def</span> sum( *pips )<br />                <span class="keyword">if</span> pips.size == 0<br />                    <span class="variable">@dice</span>.inject(0) { |total, die| total + die }<br />                <span class="keyword">else</span><br />                    <span class="variable">@dice</span>.inject(0) <span class="keyword">do</span> |total, die|<br />                        <span class="keyword">if</span> pips.include?(die) <span class="keyword">then</span> total + die <span class="keyword">else</span> total <span class="keyword">end</span><br />                    <span class="keyword">end</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment">#</span><br />            <span class="comment"># Examines Roll for a pattern of dice, returning true if found.  </span><br />            <span class="comment"># Patterns can be of the form:</span><br />            <span class="comment">#</span><br />            <span class="comment">#     roll.matches?(1, 2, 3, 4)</span><br />            <span class="comment">#</span><br />            <span class="comment"># Which validates a sequence, regardless of the actual pips on</span><br />            <span class="comment"># the dice.</span><br />            <span class="comment">#</span><br />            <span class="comment"># You can also use the form:</span><br />            <span class="comment"># </span><br />            <span class="comment">#     roll.matches?(*%w{x x x y y})</span><br />            <span class="comment">#</span><br />            <span class="comment"># To validate repititions.</span><br />            <span class="comment">#</span><br />            <span class="comment"># The two forms can be mixed in any combination and when they</span><br />            <span class="comment"># are, both must match completely.</span><br />            <span class="comment">#</span><br />            <span class="keyword">def</span> matches?( *pattern )<br />                digits, letters = pattern.partition { |e| e.is_a?(Integer) }<br />                matches_digits?(digits) <span class="keyword">and</span> matches_letters?(letters)<br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Re-roll selected _dice_.</span><br />            <span class="keyword">def</span> reroll( *dice )<br />                <span class="keyword">if</span> dice.size == 0<br />                    <span class="variable">@dice</span> = Array.new(5) { rand(6) + 1 }<br />                <span class="keyword">else</span><br />                    indices = [ ]<br />                    pool    = <span class="variable">@dice</span>.dup<br />                    dice.each <span class="keyword">do</span> |d|<br />                        i = pool.index(d) <span class="keyword">or</span><br />                            raise ArgumentError, <span class="string">"Dice not found."</span><br />                        indices &lt;&lt; i<br />                        pool[i] = -1<br />                    <span class="keyword">end</span><br /><br />                    indices.each { |i| <span class="variable">@dice</span>[i] = rand(6) + 1 }<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment"># To make printing out rolls easier.</span><br />            <span class="keyword">def</span> to_s(  )<br />                <span class="string">"#{@dice[0..-2].join(',')} and #{@dice[-1]}"</span><br />            <span class="keyword">end</span><br /><br />            private<br /><br />            <span class="comment"># Verifies matching of sequence patterns.</span><br />            <span class="keyword">def</span> matches_digits?( digits )<br />                <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> digits.size &lt; 2<br /><br />                digits.sort!<br />                test = <span class="variable">@dice</span>.uniq.sort<br />                loop <span class="keyword">do</span><br />                    (0..(<span class="variable">@dice</span>.length - digits.length)).each <span class="keyword">do</span> |index|<br />                        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> test[index, digits.length] == digits<br />                    <span class="keyword">end</span><br /><br />                    digits.collect! { |d| d + 1 }<br />                    <span class="keyword">break</span> <span class="keyword">if</span> digits.last &gt; 6<br />                <span class="keyword">end</span><br /><br />                <span class="keyword">false</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Verifies matching of repetition patterns.</span><br />            <span class="keyword">def</span> matches_letters?( letters )<br />                <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> letters.size &lt; 2<br /><br />                counts = Hash.new(0)<br />                letters.each { |l| counts[l] += 1 }<br />                counts = counts.values.sort.reverse<br /><br />                pips = <span class="variable">@dice</span>.uniq<br />                counts.each <span class="keyword">do</span> |c|<br />                    <span class="keyword">unless</span> match = pips.find { |p| count(p) &gt;= c }<br />                        <span class="keyword">return</span> <span class="keyword">false</span><br />                    <span class="keyword">end</span><br />                    pips.delete(match)<br />                <span class="keyword">end</span><br /><br />                <span class="keyword">true</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The descriptions and comments above should make that class pretty transparent, I hope.</p>
			<p>The method matches?() is my dice pattern matching system.  It understands arrays of letters and/or numbers, feeding the correct sets to the private methods matches_digits?() and matches_letters?().</p>
			<p>Letters are used to check repetition.  For example, the pattern used to match a Full House is %w{x x x y y}.  That requires three of any one number and two of a different number.</p>
			<p>Numbers are used to check sequence patterns.  As another example, the pattern to match a Small Straight is [1, 2, 3, 4].  That requires that there be four different numbers shown on the dice, each exactly one apart from one of the other numbers.  Which numbers are shown doesn't matter.</p>
			<p>As an interesting aside, the above class proved tricky to unit test.  Well, for me anyway.  I didn't end up posting my tests because I was ashamed of the hack I used.  Perhaps this should be a separate quiz...</p>
			<p>Scoring is pretty simple.  We just need a Scorecard object that holds categories we can add points to and totals based on those categories.  We need to be able to print that, of course, and allow the user to identify categories using some form of label.  Here's what I came up with for that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Namespace for all things Yahtzee.</span><br />    <span class="keyword">module</span> Yahtzee<br />        <span class="comment"># A basic score tracking object.</span><br />        <span class="keyword">class</span> Scorecard<br />            <span class="comment"># Create an instance of Scorecard.  Add categories and totals,</span><br />            <span class="comment"># track score and display results as needed.</span><br />            <span class="keyword">def</span> initialize(  )<br />                <span class="variable">@categories</span> = [ ]<br />            <span class="keyword">end</span><br /><br />            <span class="comment">#</span><br />            <span class="comment"># Add one or more categories to this Scorecard.  Order is </span><br />            <span class="comment"># maintained.</span><br />            <span class="comment">#</span><br />            <span class="keyword">def</span> add_categories( *categories )<br />                categories.each <span class="keyword">do</span> |cat|<br />                    <span class="variable">@categories</span> &lt;&lt; [cat, 0]<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment">#</span><br />            <span class="comment"># Add a total, with a block to calculate it from passed a</span><br />            <span class="comment"># categories Hash.</span><br />            <span class="comment">#</span><br />            <span class="keyword">def</span> add_total( name, &amp;calculator )<br />                <span class="variable">@categories</span> &lt;&lt; [name, calculator]<br />            <span class="keyword">end</span><br /><br />            <span class="comment">#</span><br />            <span class="comment"># The primary score action method.  Adds _count_ points to the</span><br />            <span class="comment"># category at _index_.</span><br />            <span class="comment">#</span><br />            <span class="keyword">def</span> count( index, count )<br />                <span class="variable">@categories</span>.assoc(category(index))[1] += count<br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Lookup the score of a given category.</span><br />            <span class="keyword">def</span> []( name )<br />                <span class="variable">@categories</span>.assoc(name)[1]<br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Lookup a category name, by _index.</span><br />            <span class="keyword">def</span> category( index )<br />                id = 0<br />                <span class="variable">@categories</span>.each_with_index <span class="keyword">do</span> |(name, count_or_calc), i|<br />                    <span class="keyword">next</span> <span class="keyword">unless</span> count_or_calc.is_a?(Numeric)<br />                    id += 1<br />                    <span class="keyword">return</span> <span class="variable">@categories</span>[i][0] <span class="keyword">if</span> id == index<br />                <span class="keyword">end</span><br /><br />                raise ArgumentError, <span class="string">"Invalid category."</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Support for easy printing.</span><br />            <span class="keyword">def</span> to_s(  )<br />                id = 0<br />                <span class="variable">@categories</span>.inject(<span class="string">""</span>) <span class="keyword">do</span> |disp, (name, count_or_calc)|<br />                    <span class="keyword">if</span> count_or_calc.is_a?(Numeric)<br />                        id += 1<br />                        disp + <span class="string">"%3d: %-20s %4d\n"</span> % [id, name, count_or_calc]<br />                    <span class="keyword">else</span><br />                        disp + <span class="string">"     %-20s %4d\n"</span> %<br />                            [name, count_or_calc.call(to_hash)]<br />                    <span class="keyword">end</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment"># Convert category listing to a Hash.</span><br />            <span class="keyword">def</span> to_hash(  )<br />                <span class="variable">@categories</span>.inject(Hash.new) <span class="keyword">do</span> |hash, (name, count_or_calc)|<br />                    <span class="keyword">if</span> count_or_calc.is_a?(Numeric)<br />                        hash[name] = count_or_calc<br />                    <span class="keyword">end</span><br />                    hash<br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Using that isn't too tough.  Create a Scorecard and add categories and totals to it.  Categories are really just a name that can be associated with a point count.  Totals are passed in as a block of code that can calculate the total as needed.  The block is passed a hash of category names and their current points, when called.  Moving into the "main" section of my program, we can see how I use this to build Yahtzee's Scorecard:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Console game interface.</span><br />    <span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="global">$0</span><br />        <span class="comment"># Assemble Scorecard.</span><br />        score = Yahtzee::Scorecard.new()<br />        UPPER = <span class="string">%w{Ones Twos Threes Fours Fives Sixes}</span><br />        UPPER_TOTAL = lambda <span class="keyword">do</span> |cats|<br />            cats.inject(0) <span class="keyword">do</span> |total, (cat, count)|<br />                <span class="keyword">if</span> UPPER.include?(cat) <span class="keyword">then</span> total + count <span class="keyword">else</span> total <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        score.add_categories(*UPPER)<br />        score.add_total(<span class="string">"Bonus"</span>) <span class="keyword">do</span> |cats|<br />            upper = UPPER_TOTAL.call(cats)<br />            <span class="keyword">if</span> upper &gt;= 63 <span class="keyword">then</span> 35 <span class="keyword">else</span> 0 <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        score.add_total(<span class="string">"Upper Total"</span>) <span class="keyword">do</span> |cats|<br />            upper = UPPER_TOTAL.call(cats)<br />            <span class="keyword">if</span> upper &gt;= 63 <span class="keyword">then</span> upper + 35 <span class="keyword">else</span> upper <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        LOWER = [ <span class="string">"Three of a Kind"</span>, <span class="string">"Four of a Kind"</span>, <span class="string">"Full House"</span>,<br />                  <span class="string">"Small Straight"</span>, <span class="string">"Large Straight"</span>, <span class="string">"Yahtzee"</span>, <span class="string">"Chance"</span> ]<br />        bonus_yahtzees = 0<br />        LOWER_TOTAL = lambda <span class="keyword">do</span> |cats|<br />            cats.inject(bonus_yahtzees) <span class="keyword">do</span> |total, (cat, count)|<br />                <span class="keyword">if</span> LOWER.include?(cat) <span class="keyword">then</span> total + count <span class="keyword">else</span> total <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        score.add_categories(*LOWER[0..-2])<br />        score.add_total(<span class="string">"Bonus Yahtzees"</span>) { bonus_yahtzees }<br />        score.add_categories(LOWER[-1])<br />        score.add_total(<span class="string">"Lower Total"</span>, &amp;LOWER_TOTAL)<br />        score.add_total(<span class="string">"Overall Total"</span>) <span class="keyword">do</span> |cats|<br />            upper = UPPER_TOTAL.call(cats)<br />            <span class="keyword">if</span> upper &gt;= 63<br />                upper + 35 + LOWER_TOTAL.call(cats)<br />            <span class="keyword">else</span><br />                upper + LOWER_TOTAL.call(cats)<br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        <span class="comment"># ...</span><br /><br /></div></div>
			<p>I make a little use of the fact that Ruby's blocks are closures there, especially with the Bonus Yahtzees total.  I simply have it refer to a bonus_yahtzees variable, which the game engine can increase as needed.</p>
			<p>Let's step into that engine now.  Here's the section that handles dice rolling:</p>
			<div class="code"><span class="type">ruby</span><div class="body">        <span class="comment"># ...</span><br /><br />        <span class="comment"># Game.</span><br />        puts <span class="string">"\nWelcome to Yahtzee!"</span><br />        scratches = (1..13).to_a<br />        13.times <span class="keyword">do</span><br />            <span class="comment"># Rolling...</span><br />            roll = Yahtzee::Roll.new<br />            rolls = 2<br />            <span class="keyword">while</span> rolls &gt; 0<br />                puts <span class="string">"\nYou rolled #{roll}."</span><br />                print <span class="string">"Action:  "</span> +<br />                      <span class="string">"(c)heck score, (s)core, (q)uit or #s to reroll?  "</span><br />                choice = STDIN.gets.chomp<br />                <span class="keyword">case</span> choice<br />                <span class="keyword">when</span> <span class="string">/^c/</span>i<br />                    puts <span class="string">"\nScore:\n#{score}"</span><br />                <span class="keyword">when</span> <span class="string">/^s/</span>i<br />                    <span class="keyword">break</span><br />                <span class="keyword">when</span> <span class="string">/^q/</span>i<br />                    exit<br />                <span class="keyword">else</span><br />                    <span class="keyword">begin</span><br />                        pips = choice.gsub(<span class="string">/\s+/</span>, <span class="string">""</span>).split(<span class="string">//</span>).map <span class="keyword">do</span> |n|<br />                            Integer(n)<br />                        <span class="keyword">end</span><br />                        roll.reroll(*pips)<br />                        rolls -= 1<br />                    <span class="keyword">rescue</span><br />                        puts <span class="string">"Error:  That not a valid reroll."</span><br />                    <span class="keyword">end</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br /><br />            <span class="comment"># ...</span><br /><br /></div></div>
			<p>Most of that code is for processing user interface commands.  The actual dice roll handling is just calls to the correct methods of Roll at the correct times.</p>
			<p>Finally, here's the scoring portion of the game:</p>
			<div class="code"><span class="type">ruby</span><div class="body">            <span class="comment"># ...</span><br /><br />            <span class="comment"># Scoring...</span><br />            loop <span class="keyword">do</span><br />                <span class="keyword">if</span> roll.matches?(*<span class="string">%w{x x x x x}</span>) <span class="keyword">and</span> score[<span class="string">"Yahtzee"</span>] == 50<br />                    bonus_yahtzees += 100<br /><br />                    <span class="keyword">if</span> scratches.include?(roll[0])<br />                        score.count(roll[0], roll.sum(roll[0]))<br />                        scratches.delete(choice)<br />                        puts <span class="string">"Bonus Yahtzee scored in "</span> +<br />                             <span class="string">"#{score.category(roll[0])}."</span><br />                        <span class="keyword">break</span><br />                    <span class="keyword">end</span><br /><br />                    puts <span class="string">"Bonus Yahtzee!  100 points added.  "</span> +<br />                         <span class="string">"Score in lower section as a wild-card."</span><br />                    bonus_yahtzee = <span class="keyword">true</span><br />                <span class="keyword">else</span><br />                    bonus_yahtzee = <span class="keyword">false</span><br />                <span class="keyword">end</span><br /><br />                print <span class="string">"\nScore:\n#{score}\n"</span> +<br />                      <span class="string">"Where would you like to count your #{roll} "</span> +<br />                      <span class="string">"(# of category)?  "</span><br />                <span class="keyword">begin</span><br />                    choice = Integer(STDIN.gets.chomp)<br />                    raise <span class="string">"Already scored."</span> <span class="keyword">unless</span> scratches.include?(choice)<br />                    <span class="keyword">case</span> choice<br />                    <span class="keyword">when</span> 1..6<br />                        score.count(choice, roll.sum(choice))<br />                    <span class="keyword">when</span> 7<br />                        <span class="keyword">if</span> roll.matches?(*<span class="string">%w{x x x}</span>) <span class="keyword">or</span> bonus_yahtzee<br />                            score.count(choice, roll.sum())<br />                        <span class="keyword">end</span><br />                    <span class="keyword">when</span> 8<br />                        <span class="keyword">if</span> roll.matches?(*<span class="string">%w{x x x x}</span>) <span class="keyword">or</span> bonus_yahtzee<br />                            score.count(choice, roll.sum())<br />                        <span class="keyword">end</span><br />                    <span class="keyword">when</span> 9<br />                        <span class="keyword">if</span> roll.matches?(*<span class="string">%w{x x x y y}</span>) <span class="keyword">or</span> bonus_yahtzee<br />                            score.count(choice, 25)<br />                        <span class="keyword">end</span><br />                    <span class="keyword">when</span> 10<br />                        <span class="keyword">if</span> roll.matches?(1, 2, 3, 4) <span class="keyword">or</span> bonus_yahtzee<br />                            score.count(choice, 30)<br />                        <span class="keyword">end</span><br />                    <span class="keyword">when</span> 11<br />                        <span class="keyword">if</span> roll.matches?(1, 2, 3, 4, 5) <span class="keyword">or</span> bonus_yahtzee<br />                            score.count(choice, 40)<br />                        <span class="keyword">end</span><br />                    <span class="keyword">when</span> 12<br />                        <span class="keyword">if</span> roll.matches?(*<span class="string">%w{x x x x x}</span>)<br />                            score.count(choice, 50)<br />                        <span class="keyword">end</span><br />                    <span class="keyword">when</span> 13<br />                        score.count(choice, roll.sum)<br />                    <span class="keyword">end</span><br />                    scratches.delete(choice)<br />                    <span class="keyword">break</span><br />                <span class="keyword">rescue</span><br />                    puts <span class="string">"Error:  Invalid category choice."</span><br />                <span class="keyword">end</span><br />            <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        print <span class="string">"\nFinal Score:\n#{score}\nThanks for playing.\n\n"</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The first if block in there is watching for Bonus Yahtzees, which are the hardest thing to track in a Yahtzee game.  If a second Yahtzee is thrown, it increments the bonus_yahtzee variable (so the Scorecard total will change), then it tries to score the Yahtzee in the correct slot of the Upper section.  If that slot is already full, it warns the code below to allow wild-card placement by setting the boolean variable bonus_yahtzee.</p>
			<p>The rest of the scoring code is a case statement that validates dice patterns and scores them correctly.  It looks like a lot of code, but it's very basic in function.  I'm really just stitching Roll and Scorecard together here.</p>
			<p>That's all there is to my version of Yahtzee.  I didn't do the extra challenges, obviously.  It's pretty easy to add Triple Yahtzee to this version.  The AI is a bigger challenge, if you want it to play well.  Those I'll leave as a challenge for the reader.</p>
			<p>You already know what tomorrow's quiz is.  You asked for it.</p>
		</div>
		<div id="logo"><img src="images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/131198">James Edward Gray II</a></li>
			</ol>
			<p><a href="quiz19_sols.zip">Download Solutions</a></p>
			<p><a href="index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>
